{"version":3,"sources":["meteor://ðŸ’»app/packages/artwells_queue/queue.js","meteor://ðŸ’»app/packages/artwells_queue/lib/model.js","meteor://ðŸ’»app/packages/artwells_queue/lib/server/server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/packages/artwells_queue.js","sourcesContent":["Queue = {};\nif (typeof Queue.loglevel === \"undefined\") {\n    Queue.loglevel = 3; /* 3 only includes lock conflicts.  2,3 includes successes */\n}\nif (typeof Queue.logLife === \"undefined\") {\n    Queue.logLife = 30; /* days to keep logfiles */\n}\nif (typeof Queue.ephemeralLogLife === \"undefined\") {\n    Queue.ephemeralLogLife = 1800000; /* milliseconds to keep ephemeral log statuses */\n}\nif (typeof Queue.ephemeralLogStatuses === \"undefined\") {\n    Queue.ephemeralLogStatuses = ['lockfailed','success']; /* statuses to purge from logs quickly */\n}\n\nif (typeof Queue.defaultPriority === \"undefined\") {\n    Queue.defaultPriority = 5;/* 1 is highest */\n}\nif (typeof Queue.defaultStatus === \"undefined\") {\n    Queue.defaultStatus = \"pending\";/* by changing this to some other new word, you can make sure queue items are \"blessed\" in \"pending\" through another process. */\n}\nif (typeof Queue.keepsuccess === \"undefined\") {\n    Queue.keepsuccess = true; /* keep successful in queue as record */\n}\nif (typeof Queue.lockLife === \"undefined\") {\n    Queue.lockLife = 30; /* minutes to keep lockfiles */\n}\nif (typeof Queue.completedLife === \"undefined\") {\n    Queue.completedLife = 30; /* days to keep completed tasks */\n}\n","/**\n* queue schema\n*\n*{\n*    \"_id\" : ObjectId,\n*    \"status\" : string,\n*    \"priority\" : int, // 1s first\n*    \"command\" : string,\n*    \"execute_after\" : ISODate,\n*    \"lock_name\" : string, //only allow one task of this name to be queued\n*    \"history\" : {\n*   },\n*    \"reattempt\" :  int //number of minutes to requeue\n*    \"log_success\" : boolean\n*    \"created_at\": ISODate,\n*    \"updated_at\": ISODate\n*}\n*\n*/\n\n\n/**\n*  queuelog schema\n*\n*  \"_id\" : ObjectId,\n*   \"status\" : string, // lockfailed\n*   \"created_at\" : ISODate\n*   \"command\" : string,\n*   \"parent_id\": string\n*  \"data\": {\n*     results\n*  }\n*\n*/\n\n/**\n*  queuereadrun schema\n*\n*  \"_id\" : ObjectId\n*   \"created_at\" : ISODate\n*   \"command\" : string,\n*   \"name\" : string,\n*   \"permission\" : int //notimplemented yet\n*   \"enabled\" : boolean\n*\n*/\n\n\n/**\n* queueinterval schema\n* \"_id\" : ObjectId\n* \"name\" : string,\n* \"created_at\" : ISODate\n* \"updated_at\" : ISODate\n* \"deleted_at\" : ISODate\n* \"last_run\": ISODate\n* \"command\": string\n* \"enabled \": boolean\n* \"locked\": boolean\n* \"handle\":{\n*   [interval handle] \n*}\n* \n*/\n\nQueue.entries = new Mongo.Collection(\"queue\");\nQueue.log = new Mongo.Collection(\"queuelog\");\n//Queue.readyrun = new Mongo.Collection(\"queuereadyrun\");\nQueue.queueintervals = new Meteor.Collection(\"queueintervals\"); // matb33:collection-hooks needs a Meteor collection\nQueue.intervalhandles = [];\n\nif (Meteor.isServer) {\n    Queue.entries._ensureIndex({ lock_name: 1 }, { unique: true, sparse: true });\n//    Queue.readyrun._ensureIndex({ name: 1 }, { unique: true, sparse: true });\n    Queue.queueintervals._ensureIndex({ name: 1 }, { unique: true, sparse: true });\n    /*just until Meteor bring findAndModify */\n    if (typeof Queue.entries.findAndModify === \"undefined\") {\n        Queue.entries.findAndModify = function (query, sort, mod) {\n            sort.reactive = false;\n            var results = Queue.entries.find(query, sort, {reactive: true}).fetch();\n            var modified = Queue.entries.update(query, mod, {multi: true});\n            if (modified) {\n                return results;\n            }\n        };\n    }\n    /* end fake findAndModify */\n}\n\nQueue.queueintervals.before.update(function (userId, doc, fieldNames, modifier, options) {\n    Meteor.clearInterval(Queue.intervalhandles[doc._id]); \n    command = doc.command;   \n    if (modifier.$set.command){\n        command = modifier.$set.command;\n    }\n    interval = doc.interval;\n    if (modifier.$set.interval){\n        interval = modifier.$set.interval;\n    }\n    handle = Meteor.setInterval(function(){eval(command)}, interval);\n    /* reassign the handle */\n    Queue.intervalhandles[doc._id] = handle;\n    modifier.$set.updated_at = new Date();\n});\n\n\n","Queue.purgeOldLogs = function () {\n    var before = new Date();\n    before.setDate(before.getDate() - Queue.logLife);\n    Queue.log.remove({created_at: {$lte: before}});\n\n    /* remove more ephemeral statuses */\n    var ephemeral = new Date();\n    ephemeral.setTime(ephemeral.getTime() - Queue.ephemeralLogLife )\n    Queue.log.remove({created_at: {$lte: ephemeral},  status: {$in: Queue.ephemeralLogStatuses}});\n\n};\n\nQueue.purgeOldLocks = function (before) {\n    if (typeof before === \"undefined\" || before === null) {\n        before = new Date();\n        before.setMinutes(before.getMinutes() - Queue.lockLife);\n    }\n   Queue.entries.remove({created_at: {$lte: before}, lock_name: {$exists: true}});\n};\n\nQueue.purgeCompletedTasks = function (before) {\n    if (typeof before === \"undefined\" || before === null) {\n        before = new Date();\n        before.setDate(before.getDate() - Queue.completedLife);\n    }\n    Queue.entries.remove({updated_at: {$lte: before}, status: 'completed'});\n};\n\nQueue.add = function (entry) {\n    var res = false;\n    /*command, name,  priority, execute_after, reattempt, lock_name, logsuccesses*/\n    var entryarray = [];\n    if (typeof entry !== \"object\" || entry === null) {\n        return false;\n    }\n    if (typeof entry.command !== \"string\") {\n        return false;\n    }\n    entryarray.command = entry.command;\n\n    if (typeof entry.execute_after === \"undefined\" || entry.execute_after === null) {\n        entry.execute_after = new Date();\n    }\n    entryarray.execute_after = entry.execute_after;\n    /* force default state through this method */\n    entryarray.status = Queue.defaultStatus;\n\n\n    entryarray.priority = Queue.defaultPriority; /* default to mediocre default*/\n\n    if (typeof entry.priority === \"number\") {\n        entryarray.priority = entry.priority;\n    }\n\n    if (typeof entry.name === \"string\") {\n        entryarray.name = entry.name;\n    }\n\n    if (typeof entry.lock_name === \"string\") {\n        entryarray.lock_name = entry.lock_name;\n    }\n\n    if (typeof entry.execute_after === \"object\") {\n        entryarray.execute_after = entry.execute_after;\n    }\n\n    if (typeof entry.log_success === \"boolean\") {\n        entryarray.log_success = entry.log_success;\n    }\n\n    if (typeof entry.reattempt === \"number\") {\n        entryarray.reattempt = entry.reattempt;\n    }\n    if (typeof entry.created_at !== \"undefined\") {\n        entryarray.created_at = new Date(entry.created_at);\n    }\n    else{\n        entryarray.created_at = new Date();\n    }\n\n    entryarray.updated_at = new Date();\n\n    try {\n        res = Queue.entries.insert(entryarray);\n    } catch (e) {\n        /* lock errors are expected and should be logged only if verbose */\n        if (e.err !== 'undefined' && e.err.indexOf('E11000') === 0 &&\n            Queue.loglevel > 2) {\n            Queue.log.insert({command: 'Queue.add failed ' + entryarray.lock_name, status: 'lockfailed', data: e.err, created_at: new Date()});\n    } else if (Queue.loglevel > 0) {\n        /* otherwise include the whole stack */\n        Queue.log.insert({command: 'Queue.add failed ' + entryarray.lock_name, status: 'lockfailed', data: e, created_at: new Date()});\n    }\n}\nreturn res;\n};\n\n/* not much now, but might need to be complicated in the future */\nQueue.remove = function (entryId) {\n    return Queue.entries.remove({_id: entryId});\n};\n\n/* sets all found entries as 'locked'\n* @TODO by-priority\n*/\nQueue.get = function (args) {\n    /* defaults status: pending,execute_after:now, */\n    var getstatus = \"pending\"; /* default retrieval status */\n    var execute_after = new Date();\n    /* do NOT use Queue.defaultStatus for getstatus, as you want to allow defaultStatus to serve an optional other purpose */\n    if (typeof args.execute_after !== \"undefined\" || args.execute_after === null) {\n        execute_after = args.execute_after;\n    }\n\n    if (typeof args.status === \"string\") {\n        getstatus = args.status;\n    }\n\n    return Queue.entries.findAndModify({execute_after: {$lte: execute_after}, status: getstatus}, {sort: {priority: 1}},\n        {$set: {status: 'locked'}}\n        );\n\n};\n\n/* just used for testing but will be helpful for \"blessed\" level*/\nQueue.changeStatus = function (id, status) {\n    var modified = Queue.entries.update({_id: id}, {$set: {status: status}});\n    if (modified === 1) {\n        return true;\n    }\n    return false;\n};\n\n/* @TODO: add some sanity checks */\nQueue.process = function (entry) {\n    var result = false;\n    var message = 'failed';\n    var history = null;\n    try {\n        result = new Function(entry.command)();\n    } catch (e) {\n        result = false;\n        message = e.err;\n    }\n    if (result !== false) {\n        if (entry.log_success ||  Queue.loglevel > 1) {\n            Queue.log.insert({command: entry.command, parent_id: entry._id, status: 'success', data: result, created_at: new Date()});\n        }\n        if (Queue.keepsuccess) {\n            if (typeof entry.history !== \"undefined\") {\n                history = entry.history + ' command returned true (' + new Date() + ');';\n            } else {\n                history = 'command returned true (' + new Date() + ');';\n            }\n            var modified = Queue.entries.update({_id: entry._id}, {$set: {status: 'completed', history: history, updated_at: new Date()}});\n            if (modified !== 1 && Queue.loglevel > 0) {\n                Queue.log.insert({command: 'update on succes', parent_id: entry._id, status: 'exception', data: 'unable to update entry', created_at: new Date()});\n            }\n        }\n        return true;\n    }\n\n    if (Queue.loglevel > 0) {\n        Queue.log.insert({command: entry.command, parent_id: entry._id, status: 'exception', data: message, created_at: new Date()});\n    }\n\n    if (entry.reattempt > 0) {\n        var execdate = new Date();\n        execdate.setMinutes(execdate.getMinutes() + entry.reattempt);\n        var reattemptmodified = Queue.entries.update({_id: entry._id}, {$set: {status: 'pending', execute_after: execdate}});\n        if (reattemptmodified !== 1 && Queue.loglevel > 0) {\n            Queue.log.insert({command: entry.command, parent_id: entry._id, status: 'exception', data: 'unable to requeue command', created_at: new Date()});\n        }\n    } else {\n        if (typeof entry.history !== \"undefined\") {\n            history = entry.history + ' command returned false (' + new Date() + ');';\n        } else {\n            history = ' command returned false (' + new Date() + ');';\n        }\n        var historymodified = Queue.entries.update({_id: entry._id}, {$set: {status: 'failed', history: history, updated_at: new Date()}});\n        if (historymodified !== 1 && Queue.loglevel > 0) {\n            Queue.log.insert({command: entry.command, parent_id: entry._id, status: 'exception', data: 'unable to requeue command', created_at: new Date()});\n        }\n    }\n    return false;\n};\n\n\nQueue.run = function (args) {\n    /* hacky locking with entry table */\n    if (typeof args === \"undefined\") {\n        args = [];\n    }\n    var entry = [];\n    var future = new Date();\n    var getargs = [];\n    future.setDate(future.getDate() + 600); /* put it out there so it doesn't execute */\n    entry.command = 'return true;';\n    entry.lock_name = 'query.run';\n    entry.execute_after = future;\n    var lock = Queue.add(entry);\n    if (lock === false) {\n        if (Queue.loglevel > 0) {\n            Queue.log.insert({command: 'Queue.run failed due to locking ' + entry.lock_name, status: 'lockfailed', created_at: new Date()});\n        }\n        return false;\n    }\n\n    /* lock obtained */\n    if (typeof args.execute_after === \"undefined\" || args.execute_after === null) {\n        args.execute_after = new Date();\n    }\n    getargs.execute_after = args.execute_after;\n    /* @TODO: add args for status and execute_after */\n    var all = Queue.get(getargs);\n    _.each(all, function (entry) {\n        Queue.process(entry);\n    });\n    /* lock */\n    Queue.remove(lock);\n    return true;\n};\n/* @TODO decide if readyrun is really needed */\n/*\nQueue.addReadyRun = function(args){\n    /* name, command, enabled, created_at * /\n    var ready = [];\n    if (typeof args !== \"object\" || args === null) {\n        return false;\n    }\n    if (typeof args.command !== \"string\") {\n        return false;\n    }\n    if (typeof args.name !== \"string\") {\n        return false;\n    }\n\n    ready.created_at = new Date();\n    if (typeof args.enabled === \"undefined\") {\n        ready.enabled = true;\n    }\n    else{\n        ready.enabled = entryenabled;\n    }\n    ready.name = args.name;\n    ready.command = args.command;\n\n    try {\n        res = Queue.readyrun.insert(ready);\n        if (Queue.loglevel > 1) {\n            Queue.log.insert({command: 'Queue.addREadyFunction success for' + ready.name, parent_id: entry._id, status: 'success', data: res, created_at: new Date()});\n        }\n    } catch (e) {\n        if (Queue.loglevel > 0) {\n            Queue.log.insert({command: 'Queue.addREadyFunction failed for' + ready.name, status: 'exception', data: e, created_at: new Date()});\n        }\n    }\n    return res;\n}\n*/\n\nQueue.setInterval = function(name, command, interval){\n    \n    var res = false;\n    /*command, name,  priority, execute_after, reattempt, lock_name, logsuccesses*/\n    var entryarray = [];\n    if (typeof name !== \"string\") {\n        return false;\n    }\n    entryarray.name = name;\n    \n    if (typeof command !== \"string\")  {\n        return false;\n    }\n    entryarray.command = command;\n\n    if ( typeof interval !== \"number\"){\n        return false;\n    }\n    entryarray.interval = interval;\n\n    entryarray.enabled = true;\n    entryarray.locked = false;\n\n    entryarray.updated_at = new Date();\n    entryarray.created_at = new Date();\n\n    handle = Meteor.setInterval(function(){eval(command)}, interval);\n    Queue.queueintervals.remove({name:name},function(){});\n    \n    try {\n        id = Queue.queueintervals.insert(entryarray);\n        Queue.intervalhandles[id] = handle;\n        if (Queue.loglevel > 2) {\n                Queue.log.insert({command: 'Queue.interval added: ' + entryarray.name + ', id:' + id, status: 'success', data: 'handle:' + entryarray.handle, created_at: new Date()});\n        }\n    } catch (e) {\n        if (Queue.loglevel > 0) {\n            /* otherwise include the whole stack */\n            Queue.log.insert({command: 'Queue.interval failed ' + entryarray.name, status: 'exception', data: e, created_at: new Date()});\n        }\n    }\n    return id;\n}\n\n\nQueue.clearInterval = function(id) {\n    Meteor.clearInterval(Queue.intervalhandles[id]);\n    delete Queue.intervalhandles[id];\n    return Queue.queueintervals.remove({_id:id});\n}\n\n\n\nif (typeof Houston !== \"undefined\"){\n    Meteor.startup(function () {\n        Meteor.methods({\n            addQueueRunNow : function() { \n            try{\n                    Houston.methods(\"queue\", {\n                        \"Run Now\": function (queue) {\n                            Queue.process(queue);\n                            return queue.command + \" completed.\";\n                        }\n                    });\n                }\n                catch(e){\n                //    console.log(e);\n                }\n            },\n            \n            addQueueStopInterval: function() { \n                try{\n                    Houston.methods(\"queueintervals\", {\n                        \"Stop\": function (queueinterval) {\n\n                               Queue.clearInterval(queueinterval._id);\n                            return queueinterval._id + \" completed.\";\n                        }\n                    });\n                }\n                catch(e){\n                //    console.log(e);\n                }\n            }\n     });\n\n    });\n}\n\nQueue.changeMainInterval = function(interval){\n    Meteor.clearInterval(Queue.intervalhandles[Queue.manIntervalId]); \n    Queue.manIntervalId = Queue.setInterval('Main -- DONT STOP', 'Queue.run()', interval);\n}\n\n\n\nQueue.manIntervalId = Queue.setInterval('Main -- DONT STOP', 'Queue.run()', 5000); /* once every five seconds */\n\n\n"]}