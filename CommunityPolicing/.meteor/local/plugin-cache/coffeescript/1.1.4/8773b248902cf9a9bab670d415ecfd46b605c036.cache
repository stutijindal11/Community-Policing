{"source":"__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\nvar getUserQuerySelector, userValidator;\n\nthis.Auth || (this.Auth = {});\n\n\n/*\n  A valid user will have exactly one of the following identification fields: id, username, or email\n */\n\nuserValidator = Match.Where(function(user) {\n  check(user, {\n    id: Match.Optional(String),\n    username: Match.Optional(String),\n    email: Match.Optional(String)\n  });\n  if (_.keys(user).length === !1) {\n    throw new Match.Error('User must have exactly one identifier field');\n  }\n  return true;\n});\n\n\n/*\n  Return a MongoDB query selector for finding the given user\n */\n\ngetUserQuerySelector = function(user) {\n  if (user.id) {\n    return {\n      '_id': user.id\n    };\n  } else if (user.username) {\n    return {\n      'username': user.username\n    };\n  } else if (user.email) {\n    return {\n      'emails.address': user.email\n    };\n  }\n  throw new Error('Cannot create selector from invalid user');\n};\n\n\n/*\n  Log a user in with their password\n */\n\nthis.Auth.loginWithPassword = function(user, password) {\n  var authToken, authenticatingUser, authenticatingUserSelector, hashedToken, passwordVerification, ref;\n  if (!user || !password) {\n    throw new Meteor.Error(401, 'Unauthorized');\n  }\n  check(user, userValidator);\n  check(password, String);\n  authenticatingUserSelector = getUserQuerySelector(user);\n  authenticatingUser = Meteor.users.findOne(authenticatingUserSelector);\n  if (!authenticatingUser) {\n    throw new Meteor.Error(401, 'Unauthorized');\n  }\n  if (!((ref = authenticatingUser.services) != null ? ref.password : void 0)) {\n    throw new Meteor.Error(401, 'Unauthorized');\n  }\n  passwordVerification = Accounts._checkPassword(authenticatingUser, password);\n  if (passwordVerification.error) {\n    throw new Meteor.Error(401, 'Unauthorized');\n  }\n  authToken = Accounts._generateStampedLoginToken();\n  hashedToken = Accounts._hashLoginToken(authToken.token);\n  Accounts._insertHashedLoginToken(authenticatingUser._id, {\n    hashedToken: hashedToken\n  });\n  return {\n    authToken: authToken.token,\n    userId: authenticatingUser._id\n  };\n};\n","sourceMap":{"version":3,"file":"/lib/auth.coffee.js","sourceRoot":"","sources":["/packages/nimble_restivus/lib/auth.coffee"],"names":[],"mappings":";AAAA,IAAA;;AAAA,IAAC,CAAA,SAAD,IAAC,CAAA,OAAS;;;AAEV;;;;AAGA,aAAA,GAAgB,KAAK,CAAC,KAAN,CAAY,SAAC,IAAD;EAC1B,KAAA,CAAM,IAAN,EACE;IAAA,EAAA,EAAI,KAAK,CAAC,QAAN,CAAe,MAAf,CAAJ;IACA,QAAA,EAAU,KAAK,CAAC,QAAN,CAAe,MAAf,CADV;IAEA,KAAA,EAAO,KAAK,CAAC,QAAN,CAAe,MAAf,CAFP;GADF;EAKA,IAAG,CAAC,CAAC,IAAF,CAAO,IAAP,CAAY,CAAC,MAAb,KAAuB,CAAI,CAA9B;AACE,UAAU,IAAA,KAAK,CAAC,KAAN,CAAY,6CAAZ,EADZ;;AAGA,SAAO;AATmB,CAAZ;;;AAYhB;;;;AAGA,oBAAA,GAAuB,SAAC,IAAD;EACrB,IAAG,IAAI,CAAC,EAAR;AACE,WAAO;MAAC,KAAA,EAAO,IAAI,CAAC,EAAb;MADT;GAAA,MAEK,IAAG,IAAI,CAAC,QAAR;AACH,WAAO;MAAC,UAAA,EAAY,IAAI,CAAC,QAAlB;MADJ;GAAA,MAEA,IAAG,IAAI,CAAC,KAAR;AACH,WAAO;MAAC,gBAAA,EAAkB,IAAI,CAAC,KAAxB;MADJ;;AAIL,QAAU,IAAA,KAAA,CAAM,0CAAN;AATW;;;AAYvB;;;;AAGA,IAAC,CAAA,IAAI,CAAC,iBAAN,GAA0B,SAAC,IAAD,EAAO,QAAP;AACxB,MAAA;EAAA,IAAG,CAAI,IAAJ,IAAY,CAAI,QAAnB;AACE,UAAU,IAAA,MAAM,CAAC,KAAP,CAAa,GAAb,EAAkB,cAAlB,EADZ;;EAIA,KAAA,CAAM,IAAN,EAAY,aAAZ;EACA,KAAA,CAAM,QAAN,EAAgB,MAAhB;EAGA,0BAAA,GAA6B,oBAAA,CAAqB,IAArB;EAC7B,kBAAA,GAAqB,MAAM,CAAC,KAAK,CAAC,OAAb,CAAqB,0BAArB;EAErB,IAAG,CAAI,kBAAP;AACE,UAAU,IAAA,MAAM,CAAC,KAAP,CAAa,GAAb,EAAkB,cAAlB,EADZ;;EAEA,IAAG,mDAA+B,CAAE,kBAApC;AACE,UAAU,IAAA,MAAM,CAAC,KAAP,CAAa,GAAb,EAAkB,cAAlB,EADZ;;EAIA,oBAAA,GAAuB,QAAQ,CAAC,cAAT,CAAwB,kBAAxB,EAA4C,QAA5C;EACvB,IAAG,oBAAoB,CAAC,KAAxB;AACE,UAAU,IAAA,MAAM,CAAC,KAAP,CAAa,GAAb,EAAkB,cAAlB,EADZ;;EAIA,SAAA,GAAY,QAAQ,CAAC,0BAAT,CAAA;EACZ,WAAA,GAAc,QAAQ,CAAC,eAAT,CAAyB,SAAS,CAAC,KAAnC;EACd,QAAQ,CAAC,uBAAT,CAAiC,kBAAkB,CAAC,GAApD,EAAyD;IAAC,aAAA,WAAD;GAAzD;AAEA,SAAO;IAAC,SAAA,EAAW,SAAS,CAAC,KAAtB;IAA6B,MAAA,EAAQ,kBAAkB,CAAC,GAAxD;;AA3BiB","sourcesContent":["@Auth or= {}\n\n###\n  A valid user will have exactly one of the following identification fields: id, username, or email\n###\nuserValidator = Match.Where (user) ->\n  check user,\n    id: Match.Optional String\n    username: Match.Optional String\n    email: Match.Optional String\n\n  if _.keys(user).length is not 1\n    throw new Match.Error 'User must have exactly one identifier field'\n\n  return true\n\n\n###\n  Return a MongoDB query selector for finding the given user\n###\ngetUserQuerySelector = (user) ->\n  if user.id\n    return {'_id': user.id}\n  else if user.username\n    return {'username': user.username}\n  else if user.email\n    return {'emails.address': user.email}\n\n  # We shouldn't be here if the user object was properly validated\n  throw new Error 'Cannot create selector from invalid user'\n\n\n###\n  Log a user in with their password\n###\n@Auth.loginWithPassword = (user, password) ->\n  if not user or not password\n    throw new Meteor.Error 401, 'Unauthorized'\n\n  # Validate the login input types\n  check user, userValidator\n  check password, String\n\n  # Retrieve the user from the database\n  authenticatingUserSelector = getUserQuerySelector(user)\n  authenticatingUser = Meteor.users.findOne(authenticatingUserSelector)\n\n  if not authenticatingUser\n    throw new Meteor.Error 401, 'Unauthorized'\n  if not authenticatingUser.services?.password\n    throw new Meteor.Error 401, 'Unauthorized'\n\n  # Authenticate the user's password\n  passwordVerification = Accounts._checkPassword authenticatingUser, password\n  if passwordVerification.error\n    throw new Meteor.Error 401, 'Unauthorized'\n\n  # Add a new auth token to the user's account\n  authToken = Accounts._generateStampedLoginToken()\n  hashedToken = Accounts._hashLoginToken authToken.token\n  Accounts._insertHashedLoginToken authenticatingUser._id, {hashedToken}\n\n  return {authToken: authToken.token, userId: authenticatingUser._id}\n"]}}