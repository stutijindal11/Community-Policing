{"source":"__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\nvar          \n    indexOf = [].indexOf || function (item) {\n  for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item) return i;\n  }return -1;\n};\n\nthis.Restivus = function () {\n  function Restivus(options) {\n    var corsHeaders;\n    this._routes = [];\n    this._config = {\n      paths: [],\n      useDefaultAuth: false,\n      apiPath: 'api/',\n      version: null,\n      prettyJson: false,\n      auth: {\n        token: 'services.resume.loginTokens.hashedToken',\n        user: function user() {\n          var token;\n          if (this.request.headers['x-auth-token']) {\n            token = Accounts._hashLoginToken(this.request.headers['x-auth-token']);\n          }\n          return {\n            userId: this.request.headers['x-user-id'],\n            token: token\n          };\n        }\n      },\n      defaultHeaders: {\n        'Content-Type': 'application/json'\n      },\n      enableCors: true\n    };\n    _.extend(this._config, options);\n    if (this._config.enableCors) {\n      corsHeaders = {\n        'Access-Control-Allow-Origin': '*',\n        'Access-Control-Allow-Headers': 'Origin, X-Requested-With, Content-Type, Accept'\n      };\n      if (this._config.useDefaultAuth) {\n        corsHeaders['Access-Control-Allow-Headers'] += ', X-User-Id, X-Auth-Token';\n      }\n      _.extend(this._config.defaultHeaders, corsHeaders);\n      if (!this._config.defaultOptionsEndpoint) {\n        this._config.defaultOptionsEndpoint = function () {\n          this.response.writeHead(200, corsHeaders);\n          return this.done();\n        };\n      }\n    }\n    if (this._config.apiPath[0] === '/') {\n      this._config.apiPath = this._config.apiPath.slice(1);\n    }\n    if (_.last(this._config.apiPath) !== '/') {\n      this._config.apiPath = this._config.apiPath + '/';\n    }\n    if (this._config.version) {\n      this._config.apiPath += this._config.version + '/';\n    }\n    if (this._config.useDefaultAuth) {\n      this._initAuth();\n    } else if (this._config.useAuth) {\n      this._initAuth();\n      console.warn('Warning: useAuth API config option will be removed in Restivus v1.0 ' + '\\n    Use the useDefaultAuth option instead');\n    }\n    return this;\n  }\n\n  /**\n    Add endpoints for the given HTTP methods at the given path\n  \n    @param path {String} The extended URL path (will be appended to base path of the API)\n    @param options {Object} Route configuration options\n    @param options.authRequired {Boolean} The default auth requirement for each endpoint on the route\n    @param options.roleRequired {String or String[]} The default role required for each endpoint on the route\n    @param endpoints {Object} A set of endpoints available on the new route (get, post, put, patch, delete, options)\n    @param endpoints.<method> {Function or Object} If a function is provided, all default route\n        configuration options will be applied to the endpoint. Otherwise an object with an `action`\n        and all other route config options available. An `action` must be provided with the object.\n   */\n\n  Restivus.prototype.addRoute = function (path, options, endpoints) {\n    var route;\n    route = new share.Route(this, path, options, endpoints);\n    this._routes.push(route);\n    route.addToApi();\n    return this;\n  };\n\n  /**\n    Generate routes for the Meteor Collection with the given name\n   */\n\n  Restivus.prototype.addCollection = function (collection, options) {\n    var collectionEndpoints, collectionRouteEndpoints, endpointsAwaitingConfiguration, entityRouteEndpoints, excludedEndpoints, methods, methodsOnCollection, path, routeOptions;\n    if (options == null) {\n      options = {};\n    }\n    methods = ['get', 'post', 'put', 'delete', 'getAll'];\n    methodsOnCollection = ['post', 'getAll'];\n    if (collection === Meteor.users) {\n      collectionEndpoints = this._userCollectionEndpoints;\n    } else {\n      collectionEndpoints = this._collectionEndpoints;\n    }\n    endpointsAwaitingConfiguration = options.endpoints || {};\n    routeOptions = options.routeOptions || {};\n    excludedEndpoints = options.excludedEndpoints || [];\n    path = options.path || collection._name;\n    collectionRouteEndpoints = {};\n    entityRouteEndpoints = {};\n    if (_.isEmpty(endpointsAwaitingConfiguration) && _.isEmpty(excludedEndpoints)) {\n      _.each(methods, function (method) {\n        if (indexOf.call(methodsOnCollection, method) >= 0) {\n          _.extend(collectionRouteEndpoints, collectionEndpoints[method].call(this, collection));\n        } else {\n          _.extend(entityRouteEndpoints, collectionEndpoints[method].call(this, collection));\n        }\n      }, this);\n    } else {\n      _.each(methods, function (method) {\n        var configuredEndpoint, endpointOptions;\n        if (indexOf.call(excludedEndpoints, method) < 0 && endpointsAwaitingConfiguration[method] !== false) {\n          endpointOptions = endpointsAwaitingConfiguration[method];\n          configuredEndpoint = {};\n          _.each(collectionEndpoints[method].call(this, collection), function (action, methodType) {\n            return configuredEndpoint[methodType] = _.chain(action).clone().extend(endpointOptions).value();\n          });\n          if (indexOf.call(methodsOnCollection, method) >= 0) {\n            _.extend(collectionRouteEndpoints, configuredEndpoint);\n          } else {\n            _.extend(entityRouteEndpoints, configuredEndpoint);\n          }\n        }\n      }, this);\n    }\n    this.addRoute(path, routeOptions, collectionRouteEndpoints);\n    this.addRoute(path + \"/:id\", routeOptions, entityRouteEndpoints);\n    return this;\n  };\n\n  /**\n    A set of endpoints that can be applied to a Collection Route\n   */\n\n  Restivus.prototype._collectionEndpoints = {\n    get: function get(collection) {\n      return {\n        get: {\n          action: function action() {\n            var entity;\n            entity = collection.findOne(this.urlParams.id);\n            if (entity) {\n              return {\n                status: 'success',\n                data: entity\n              };\n            } else {\n              return {\n                statusCode: 404,\n                body: {\n                  status: 'fail',\n                  message: 'Item not found'\n                }\n              };\n            }\n          }\n        }\n      };\n    },\n    put: function put(collection) {\n      return {\n        put: {\n          action: function action() {\n            var entity, entityIsUpdated;\n            entityIsUpdated = collection.update(this.urlParams.id, this.bodyParams);\n            if (entityIsUpdated) {\n              entity = collection.findOne(this.urlParams.id);\n              return {\n                status: 'success',\n                data: entity\n              };\n            } else {\n              return {\n                statusCode: 404,\n                body: {\n                  status: 'fail',\n                  message: 'Item not found'\n                }\n              };\n            }\n          }\n        }\n      };\n    },\n    \"delete\": function _delete(collection) {\n      return {\n        \"delete\": {\n          action: function action() {\n            if (collection.remove(this.urlParams.id)) {\n              return {\n                status: 'success',\n                data: {\n                  message: 'Item removed'\n                }\n              };\n            } else {\n              return {\n                statusCode: 404,\n                body: {\n                  status: 'fail',\n                  message: 'Item not found'\n                }\n              };\n            }\n          }\n        }\n      };\n    },\n    post: function post(collection) {\n      return {\n        post: {\n          action: function action() {\n            var entity, entityId;\n            entityId = collection.insert(this.bodyParams);\n            entity = collection.findOne(entityId);\n            if (entity) {\n              return {\n                statusCode: 201,\n                body: {\n                  status: 'success',\n                  data: entity\n                }\n              };\n            } else {\n              return {\n                statusCode: 400,\n                body: {\n                  status: 'fail',\n                  message: 'No item added'\n                }\n              };\n            }\n          }\n        }\n      };\n    },\n    getAll: function getAll(collection) {\n      return {\n        get: {\n          action: function action() {\n            var entities;\n            entities = collection.find().fetch();\n            if (entities) {\n              return {\n                status: 'success',\n                data: entities\n              };\n            } else {\n              return {\n                statusCode: 404,\n                body: {\n                  status: 'fail',\n                  message: 'Unable to retrieve items from collection'\n                }\n              };\n            }\n          }\n        }\n      };\n    }\n  };\n\n  /**\n    A set of endpoints that can be applied to a Meteor.users Collection Route\n   */\n\n  Restivus.prototype._userCollectionEndpoints = {\n    get: function get(collection) {\n      return {\n        get: {\n          action: function action() {\n            var entity;\n            entity = collection.findOne(this.urlParams.id, {\n              fields: {\n                profile: 1\n              }\n            });\n            if (entity) {\n              return {\n                status: 'success',\n                data: entity\n              };\n            } else {\n              return {\n                statusCode: 404,\n                body: {\n                  status: 'fail',\n                  message: 'User not found'\n                }\n              };\n            }\n          }\n        }\n      };\n    },\n    put: function put(collection) {\n      return {\n        put: {\n          action: function action() {\n            var entity, entityIsUpdated;\n            entityIsUpdated = collection.update(this.urlParams.id, {\n              $set: {\n                profile: this.bodyParams\n              }\n            });\n            if (entityIsUpdated) {\n              entity = collection.findOne(this.urlParams.id, {\n                fields: {\n                  profile: 1\n                }\n              });\n              return {\n                status: \"success\",\n                data: entity\n              };\n            } else {\n              return {\n                statusCode: 404,\n                body: {\n                  status: 'fail',\n                  message: 'User not found'\n                }\n              };\n            }\n          }\n        }\n      };\n    },\n    \"delete\": function _delete(collection) {\n      return {\n        \"delete\": {\n          action: function action() {\n            if (collection.remove(this.urlParams.id)) {\n              return {\n                status: 'success',\n                data: {\n                  message: 'User removed'\n                }\n              };\n            } else {\n              return {\n                statusCode: 404,\n                body: {\n                  status: 'fail',\n                  message: 'User not found'\n                }\n              };\n            }\n          }\n        }\n      };\n    },\n    post: function post(collection) {\n      return {\n        post: {\n          action: function action() {\n            var entity, entityId;\n            entityId = Accounts.createUser(this.bodyParams);\n            entity = collection.findOne(entityId, {\n              fields: {\n                profile: 1\n              }\n            });\n            if (entity) {\n              return {\n                statusCode: 201,\n                body: {\n                  status: 'success',\n                  data: entity\n                }\n              };\n            } else {\n              ({\n                statusCode: 400\n              });\n              return {\n                status: 'fail',\n                message: 'No user added'\n              };\n            }\n          }\n        }\n      };\n    },\n    getAll: function getAll(collection) {\n      return {\n        get: {\n          action: function action() {\n            var entities;\n            entities = collection.find({}, {\n              fields: {\n                profile: 1\n              }\n            }).fetch();\n            if (entities) {\n              return {\n                status: 'success',\n                data: entities\n              };\n            } else {\n              return {\n                statusCode: 404,\n                body: {\n                  status: 'fail',\n                  message: 'Unable to retrieve users'\n                }\n              };\n            }\n          }\n        }\n      };\n    }\n  };\n\n  /*\n    Add /login and /logout endpoints to the API\n   */\n\n  Restivus.prototype._initAuth = function () {\n    var logout, self;\n    self = this;\n\n    /*\n      Add a login endpoint to the API\n    \n      After the user is logged in, the onLoggedIn hook is called (see Restfully.configure() for\n      adding hook).\n     */\n    this.addRoute('login', {\n      authRequired: false\n    }, {\n      post: function post() {\n        var auth, e, error, extraData, ref, ref1, response, searchQuery, user;\n        user = {};\n        if (this.bodyParams.user) {\n          if (this.bodyParams.user.indexOf('@') === -1) {\n            user.username = this.bodyParams.user;\n          } else {\n            user.email = this.bodyParams.user;\n          }\n        } else if (this.bodyParams.username) {\n          user.username = this.bodyParams.username;\n        } else if (this.bodyParams.email) {\n          user.email = this.bodyParams.email;\n        }\n        try {\n          auth = Auth.loginWithPassword(user, this.bodyParams.password);\n        } catch (error) {\n          e = error;\n          return {\n            statusCode: e.error,\n            body: {\n              status: 'error',\n              message: e.reason\n            }\n          };\n        }\n        if (auth.userId && auth.authToken) {\n          searchQuery = {};\n          searchQuery[self._config.auth.token] = Accounts._hashLoginToken(auth.authToken);\n          this.user = Meteor.users.findOne({\n            '_id': auth.userId\n          }, searchQuery);\n          this.userId = (ref = this.user) != null ? ref._id : void 0;\n        }\n        response = {\n          status: 'success',\n          data: auth\n        };\n        extraData = (ref1 = self._config.onLoggedIn) != null ? ref1.call(this) : void 0;\n        if (extraData != null) {\n          _.extend(response.data, {\n            extra: extraData\n          });\n        }\n        return response;\n      }\n    });\n    logout = function logout() {\n      var authToken, extraData, hashedToken, index, ref, response, tokenFieldName, tokenLocation, tokenPath, tokenRemovalQuery, tokenToRemove;\n      authToken = this.request.headers['x-auth-token'];\n      hashedToken = Accounts._hashLoginToken(authToken);\n      tokenLocation = self._config.auth.token;\n      index = tokenLocation.lastIndexOf('.');\n      tokenPath = tokenLocation.substring(0, index);\n      tokenFieldName = tokenLocation.substring(index + 1);\n      tokenToRemove = {};\n      tokenToRemove[tokenFieldName] = hashedToken;\n      tokenRemovalQuery = {};\n      tokenRemovalQuery[tokenPath] = tokenToRemove;\n      Meteor.users.update(this.user._id, {\n        $pull: tokenRemovalQuery\n      });\n      response = {\n        status: 'success',\n        data: {\n          message: 'You\\'ve been logged out!'\n        }\n      };\n      extraData = (ref = self._config.onLoggedOut) != null ? ref.call(this) : void 0;\n      if (extraData != null) {\n        _.extend(response.data, {\n          extra: extraData\n        });\n      }\n      return response;\n    };\n\n    /*\n      Add a logout endpoint to the API\n    \n      After the user is logged out, the onLoggedOut hook is called (see Restfully.configure() for\n      adding hook).\n     */\n    return this.addRoute('logout', {\n      authRequired: true\n    }, {\n      get: function get() {\n        console.warn(\"Warning: Default logout via GET will be removed in Restivus v1.0. Use POST instead.\");\n        console.warn(\"    See https://github.com/kahmali/meteor-restivus/issues/100\");\n        return logout.call(this);\n      },\n      post: logout\n    });\n  };\n\n  return Restivus;\n}();\n\nRestivus = this.Restivus;","sourceMap":{"version":3,"sources":[],"names":[],"mappings":";","file":"/packages/nimble:restivus/lib/restivus.coffee.map","sourcesContent":[]}}