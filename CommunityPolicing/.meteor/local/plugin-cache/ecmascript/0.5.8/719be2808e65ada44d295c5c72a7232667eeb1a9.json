{"metadata":{"usedHelpers":["typeof"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/qunit/qunit.js","filenameRelative":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/qunit/qunit.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/qunit/qunit.js.map","sourceFileName":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/qunit/qunit.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"qunit"},"ignored":false,"code":"var _typeof;module.import(\"babel-runtime/helpers/typeof\",{\"default\":function(v){_typeof=v}});\n/*!\n * QUnit 1.20.0\n * http://qunitjs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2015-10-27T17:53Z\n */\n\n(function (global) {\n\n\tvar QUnit = {};\n\n\tvar Date = global.Date;\n\tvar now = Date.now || function () {\n\t\treturn new Date().getTime();\n\t};\n\n\tvar setTimeout = global.setTimeout;\n\tvar clearTimeout = global.clearTimeout;\n\n\t// Store a local window from the global to allow direct references.\n\tvar window = global.window;\n\n\tvar defined = {\n\t\tdocument: window && window.document !== undefined,\n\t\tsetTimeout: setTimeout !== undefined,\n\t\tsessionStorage: function () {\n\t\t\tvar x = \"qunit-test-string\";\n\t\t\ttry {\n\t\t\t\tsessionStorage.setItem(x, x);\n\t\t\t\tsessionStorage.removeItem(x);\n\t\t\t\treturn true;\n\t\t\t} catch (e) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}()\n\t};\n\n\tvar fileName = (sourceFromStacktrace(0) || \"\").replace(/(:\\d+)+\\)?/, \"\").replace(/.+\\//, \"\");\n\tvar globalStartCalled = false;\n\tvar runStarted = false;\n\n\tvar toString = Object.prototype.toString,\n\t    hasOwn = Object.prototype.hasOwnProperty;\n\n\t// returns a new Array with the elements that are in a but not in b\n\tfunction diff(a, b) {\n\t\tvar i,\n\t\t    j,\n\t\t    result = a.slice();\n\n\t\tfor (i = 0; i < result.length; i++) {\n\t\t\tfor (j = 0; j < b.length; j++) {\n\t\t\t\tif (result[i] === b[j]) {\n\t\t\t\t\tresult.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t// from jquery.js\n\tfunction inArray(elem, array) {\n\t\tif (array.indexOf) {\n\t\t\treturn array.indexOf(elem);\n\t\t}\n\n\t\tfor (var i = 0, length = array.length; i < length; i++) {\n\t\t\tif (array[i] === elem) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\t/**\n  * Makes a clone of an object using only Array or Object as base,\n  * and copies over the own enumerable properties.\n  *\n  * @param {Object} obj\n  * @return {Object} New object with only the own properties (recursively).\n  */\n\tfunction objectValues(obj) {\n\t\tvar key,\n\t\t    val,\n\t\t    vals = QUnit.is(\"array\", obj) ? [] : {};\n\t\tfor (key in meteorBabelHelpers.sanitizeForInObject(obj)) {\n\t\t\tif (hasOwn.call(obj, key)) {\n\t\t\t\tval = obj[key];\n\t\t\t\tvals[key] = val === Object(val) ? objectValues(val) : val;\n\t\t\t}\n\t\t}\n\t\treturn vals;\n\t}\n\n\tfunction extend(a, b, undefOnly) {\n\t\tfor (var prop in meteorBabelHelpers.sanitizeForInObject(b)) {\n\t\t\tif (hasOwn.call(b, prop)) {\n\n\t\t\t\t// Avoid \"Member not found\" error in IE8 caused by messing with window.constructor\n\t\t\t\t// This block runs on every environment, so `global` is being used instead of `window`\n\t\t\t\t// to avoid errors on node.\n\t\t\t\tif (prop !== \"constructor\" || a !== global) {\n\t\t\t\t\tif (b[prop] === undefined) {\n\t\t\t\t\t\tdelete a[prop];\n\t\t\t\t\t} else if (!(undefOnly && typeof a[prop] !== \"undefined\")) {\n\t\t\t\t\t\ta[prop] = b[prop];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn a;\n\t}\n\n\tfunction objectType(obj) {\n\t\tif (typeof obj === \"undefined\") {\n\t\t\treturn \"undefined\";\n\t\t}\n\n\t\t// Consider: typeof null === object\n\t\tif (obj === null) {\n\t\t\treturn \"null\";\n\t\t}\n\n\t\tvar match = toString.call(obj).match(/^\\[object\\s(.*)\\]$/),\n\t\t    type = match && match[1];\n\n\t\tswitch (type) {\n\t\t\tcase \"Number\":\n\t\t\t\tif (isNaN(obj)) {\n\t\t\t\t\treturn \"nan\";\n\t\t\t\t}\n\t\t\t\treturn \"number\";\n\t\t\tcase \"String\":\n\t\t\tcase \"Boolean\":\n\t\t\tcase \"Array\":\n\t\t\tcase \"Set\":\n\t\t\tcase \"Map\":\n\t\t\tcase \"Date\":\n\t\t\tcase \"RegExp\":\n\t\t\tcase \"Function\":\n\t\t\tcase \"Symbol\":\n\t\t\t\treturn type.toLowerCase();\n\t\t}\n\t\tif ((typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) === \"object\") {\n\t\t\treturn \"object\";\n\t\t}\n\t}\n\n\t// Safe object type checking\n\tfunction is(type, obj) {\n\t\treturn QUnit.objectType(obj) === type;\n\t}\n\n\tvar getUrlParams = function getUrlParams() {\n\t\tvar i, current;\n\t\tvar urlParams = {};\n\t\tvar location = window.location;\n\t\tvar params = location.search.slice(1).split(\"&\");\n\t\tvar length = params.length;\n\n\t\tif (params[0]) {\n\t\t\tfor (i = 0; i < length; i++) {\n\t\t\t\tcurrent = params[i].split(\"=\");\n\t\t\t\tcurrent[0] = decodeURIComponent(current[0]);\n\n\t\t\t\t// allow just a key to turn on a flag, e.g., test.html?noglobals\n\t\t\t\tcurrent[1] = current[1] ? decodeURIComponent(current[1]) : true;\n\t\t\t\tif (urlParams[current[0]]) {\n\t\t\t\t\turlParams[current[0]] = [].concat(urlParams[current[0]], current[1]);\n\t\t\t\t} else {\n\t\t\t\t\turlParams[current[0]] = current[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn urlParams;\n\t};\n\n\t// Doesn't support IE6 to IE9, it will return undefined on these browsers\n\t// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\n\tfunction extractStacktrace(e, offset) {\n\t\toffset = offset === undefined ? 4 : offset;\n\n\t\tvar stack, include, i;\n\n\t\tif (e.stack) {\n\t\t\tstack = e.stack.split(\"\\n\");\n\t\t\tif (/^error$/i.test(stack[0])) {\n\t\t\t\tstack.shift();\n\t\t\t}\n\t\t\tif (fileName) {\n\t\t\t\tinclude = [];\n\t\t\t\tfor (i = offset; i < stack.length; i++) {\n\t\t\t\t\tif (stack[i].indexOf(fileName) !== -1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tinclude.push(stack[i]);\n\t\t\t\t}\n\t\t\t\tif (include.length) {\n\t\t\t\t\treturn include.join(\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stack[offset];\n\n\t\t\t// Support: Safari <=6 only\n\t\t} else if (e.sourceURL) {\n\n\t\t\t\t// exclude useless self-reference for generated Error objects\n\t\t\t\tif (/qunit.js$/.test(e.sourceURL)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// for actual exceptions, this is useful\n\t\t\t\treturn e.sourceURL + \":\" + e.line;\n\t\t\t}\n\t}\n\n\tfunction sourceFromStacktrace(offset) {\n\t\tvar error = new Error();\n\n\t\t// Support: Safari <=7 only, IE <=10 - 11 only\n\t\t// Not all browsers generate the `stack` property for `new Error()`, see also #636\n\t\tif (!error.stack) {\n\t\t\ttry {\n\t\t\t\tthrow error;\n\t\t\t} catch (err) {\n\t\t\t\terror = err;\n\t\t\t}\n\t\t}\n\n\t\treturn extractStacktrace(error, offset);\n\t}\n\n\t/**\n  * Config object: Maintain internal state\n  * Later exposed as QUnit.config\n  * `config` initialized at top of scope\n  */\n\tvar config = {\n\t\t// The queue of tests to run\n\t\tqueue: [],\n\n\t\t// block until document ready\n\t\tblocking: true,\n\n\t\t// by default, run previously failed tests first\n\t\t// very useful in combination with \"Hide passed tests\" checked\n\t\treorder: true,\n\n\t\t// by default, modify document.title when suite is done\n\t\taltertitle: true,\n\n\t\t// HTML Reporter: collapse every test except the first failing test\n\t\t// If false, all failing tests will be expanded\n\t\tcollapse: true,\n\n\t\t// by default, scroll to top of the page when suite is done\n\t\tscrolltop: true,\n\n\t\t// depth up-to which object will be dumped\n\t\tmaxDepth: 5,\n\n\t\t// when enabled, all tests must call expect()\n\t\trequireExpects: false,\n\n\t\t// add checkboxes that are persisted in the query-string\n\t\t// when enabled, the id is set to `true` as a `QUnit.config` property\n\t\turlConfig: [{\n\t\t\tid: \"hidepassed\",\n\t\t\tlabel: \"Hide passed tests\",\n\t\t\ttooltip: \"Only show tests and assertions that fail. Stored as query-strings.\"\n\t\t}, {\n\t\t\tid: \"noglobals\",\n\t\t\tlabel: \"Check for Globals\",\n\t\t\ttooltip: \"Enabling this will test if any test introduces new properties on the \" + \"global object (`window` in Browsers). Stored as query-strings.\"\n\t\t}, {\n\t\t\tid: \"notrycatch\",\n\t\t\tlabel: \"No try-catch\",\n\t\t\ttooltip: \"Enabling this will run tests outside of a try-catch block. Makes debugging \" + \"exceptions in IE reasonable. Stored as query-strings.\"\n\t\t}],\n\n\t\t// Set of all modules.\n\t\tmodules: [],\n\n\t\t// Stack of nested modules\n\t\tmoduleStack: [],\n\n\t\t// The first unnamed module\n\t\tcurrentModule: {\n\t\t\tname: \"\",\n\t\t\ttests: []\n\t\t},\n\n\t\tcallbacks: {}\n\t};\n\n\tvar urlParams = defined.document ? getUrlParams() : {};\n\n\t// Push a loose unnamed module to the modules collection\n\tconfig.modules.push(config.currentModule);\n\n\tif (urlParams.filter === true) {\n\t\tdelete urlParams.filter;\n\t}\n\n\t// String search anywhere in moduleName+testName\n\tconfig.filter = urlParams.filter;\n\n\tconfig.testId = [];\n\tif (urlParams.testId) {\n\t\t// Ensure that urlParams.testId is an array\n\t\turlParams.testId = decodeURIComponent(urlParams.testId).split(\",\");\n\t\tfor (var i = 0; i < urlParams.testId.length; i++) {\n\t\t\tconfig.testId.push(urlParams.testId[i]);\n\t\t}\n\t}\n\n\tvar loggingCallbacks = {};\n\n\t// Register logging callbacks\n\tfunction registerLoggingCallbacks(obj) {\n\t\tvar i,\n\t\t    l,\n\t\t    key,\n\t\t    callbackNames = [\"begin\", \"done\", \"log\", \"testStart\", \"testDone\", \"moduleStart\", \"moduleDone\"];\n\n\t\tfunction registerLoggingCallback(key) {\n\t\t\tvar loggingCallback = function loggingCallback(callback) {\n\t\t\t\tif (objectType(callback) !== \"function\") {\n\t\t\t\t\tthrow new Error(\"QUnit logging methods require a callback function as their first parameters.\");\n\t\t\t\t}\n\n\t\t\t\tconfig.callbacks[key].push(callback);\n\t\t\t};\n\n\t\t\t// DEPRECATED: This will be removed on QUnit 2.0.0+\n\t\t\t// Stores the registered functions allowing restoring\n\t\t\t// at verifyLoggingCallbacks() if modified\n\t\t\tloggingCallbacks[key] = loggingCallback;\n\n\t\t\treturn loggingCallback;\n\t\t}\n\n\t\tfor (i = 0, l = callbackNames.length; i < l; i++) {\n\t\t\tkey = callbackNames[i];\n\n\t\t\t// Initialize key collection of logging callback\n\t\t\tif (objectType(config.callbacks[key]) === \"undefined\") {\n\t\t\t\tconfig.callbacks[key] = [];\n\t\t\t}\n\n\t\t\tobj[key] = registerLoggingCallback(key);\n\t\t}\n\t}\n\n\tfunction runLoggingCallbacks(key, args) {\n\t\tvar i, l, callbacks;\n\n\t\tcallbacks = config.callbacks[key];\n\t\tfor (i = 0, l = callbacks.length; i < l; i++) {\n\t\t\tcallbacks[i](args);\n\t\t}\n\t}\n\n\t// DEPRECATED: This will be removed on 2.0.0+\n\t// This function verifies if the loggingCallbacks were modified by the user\n\t// If so, it will restore it, assign the given callback and print a console warning\n\tfunction verifyLoggingCallbacks() {\n\t\tvar loggingCallback, userCallback;\n\n\t\tfor (loggingCallback in meteorBabelHelpers.sanitizeForInObject(loggingCallbacks)) {\n\t\t\tif (QUnit[loggingCallback] !== loggingCallbacks[loggingCallback]) {\n\n\t\t\t\tuserCallback = QUnit[loggingCallback];\n\n\t\t\t\t// Restore the callback function\n\t\t\t\tQUnit[loggingCallback] = loggingCallbacks[loggingCallback];\n\n\t\t\t\t// Assign the deprecated given callback\n\t\t\t\tQUnit[loggingCallback](userCallback);\n\n\t\t\t\tif (global.console && global.console.warn) {\n\t\t\t\t\tglobal.console.warn(\"QUnit.\" + loggingCallback + \" was replaced with a new value.\\n\" + \"Please, check out the documentation on how to apply logging callbacks.\\n\" + \"Reference: http://api.qunitjs.com/category/callbacks/\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t(function () {\n\t\tif (!defined.document) {\n\t\t\treturn;\n\t\t}\n\n\t\t// `onErrorFnPrev` initialized at top of scope\n\t\t// Preserve other handlers\n\t\tvar onErrorFnPrev = window.onerror;\n\n\t\t// Cover uncaught exceptions\n\t\t// Returning true will suppress the default browser handler,\n\t\t// returning false will let it run.\n\t\twindow.onerror = function (error, filePath, linerNr) {\n\t\t\tvar ret = false;\n\t\t\tif (onErrorFnPrev) {\n\t\t\t\tret = onErrorFnPrev(error, filePath, linerNr);\n\t\t\t}\n\n\t\t\t// Treat return value as window.onerror itself does,\n\t\t\t// Only do our handling if not suppressed.\n\t\t\tif (ret !== true) {\n\t\t\t\tif (QUnit.config.current) {\n\t\t\t\t\tif (QUnit.config.current.ignoreGlobalErrors) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tQUnit.pushFailure(error, filePath + \":\" + linerNr);\n\t\t\t\t} else {\n\t\t\t\t\tQUnit.test(\"global failure\", extend(function () {\n\t\t\t\t\t\tQUnit.pushFailure(error, filePath + \":\" + linerNr);\n\t\t\t\t\t}, { validTest: true }));\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t};\n\t})();\n\n\tQUnit.urlParams = urlParams;\n\n\t// Figure out if we're running the tests from a server or not\n\tQUnit.isLocal = !(defined.document && window.location.protocol !== \"file:\");\n\n\t// Expose the current QUnit version\n\tQUnit.version = \"1.20.0\";\n\n\textend(QUnit, {\n\n\t\t// call on start of module test to prepend name to all tests\n\t\tmodule: function () {\n\t\t\tfunction module(name, testEnvironment, executeNow) {\n\t\t\t\tvar module, moduleFns;\n\t\t\t\tvar currentModule = config.currentModule;\n\n\t\t\t\tif (arguments.length === 2) {\n\t\t\t\t\tif (testEnvironment instanceof Function) {\n\t\t\t\t\t\texecuteNow = testEnvironment;\n\t\t\t\t\t\ttestEnvironment = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// DEPRECATED: handles setup/teardown functions,\n\t\t\t\t// beforeEach and afterEach should be used instead\n\t\t\t\tif (testEnvironment && testEnvironment.setup) {\n\t\t\t\t\ttestEnvironment.beforeEach = testEnvironment.setup;\n\t\t\t\t\tdelete testEnvironment.setup;\n\t\t\t\t}\n\t\t\t\tif (testEnvironment && testEnvironment.teardown) {\n\t\t\t\t\ttestEnvironment.afterEach = testEnvironment.teardown;\n\t\t\t\t\tdelete testEnvironment.teardown;\n\t\t\t\t}\n\n\t\t\t\tmodule = createModule();\n\n\t\t\t\tmoduleFns = {\n\t\t\t\t\tbeforeEach: setHook(module, \"beforeEach\"),\n\t\t\t\t\tafterEach: setHook(module, \"afterEach\")\n\t\t\t\t};\n\n\t\t\t\tif (executeNow instanceof Function) {\n\t\t\t\t\tconfig.moduleStack.push(module);\n\t\t\t\t\tsetCurrentModule(module);\n\t\t\t\t\texecuteNow.call(module.testEnvironment, moduleFns);\n\t\t\t\t\tconfig.moduleStack.pop();\n\t\t\t\t\tmodule = module.parentModule || currentModule;\n\t\t\t\t}\n\n\t\t\t\tsetCurrentModule(module);\n\n\t\t\t\tfunction createModule() {\n\t\t\t\t\tvar parentModule = config.moduleStack.length ? config.moduleStack.slice(-1)[0] : null;\n\t\t\t\t\tvar moduleName = parentModule !== null ? [parentModule.name, name].join(\" > \") : name;\n\t\t\t\t\tvar module = {\n\t\t\t\t\t\tname: moduleName,\n\t\t\t\t\t\tparentModule: parentModule,\n\t\t\t\t\t\ttests: []\n\t\t\t\t\t};\n\n\t\t\t\t\tvar env = {};\n\t\t\t\t\tif (parentModule) {\n\t\t\t\t\t\textend(env, parentModule.testEnvironment);\n\t\t\t\t\t\tdelete env.beforeEach;\n\t\t\t\t\t\tdelete env.afterEach;\n\t\t\t\t\t}\n\t\t\t\t\textend(env, testEnvironment);\n\t\t\t\t\tmodule.testEnvironment = env;\n\n\t\t\t\t\tconfig.modules.push(module);\n\t\t\t\t\treturn module;\n\t\t\t\t}\n\n\t\t\t\tfunction setCurrentModule(module) {\n\t\t\t\t\tconfig.currentModule = module;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn module;\n\t\t}(),\n\n\t\t// DEPRECATED: QUnit.asyncTest() will be removed in QUnit 2.0.\n\t\tasyncTest: asyncTest,\n\n\t\ttest: test,\n\n\t\tskip: skip,\n\n\t\tonly: only,\n\n\t\t// DEPRECATED: The functionality of QUnit.start() will be altered in QUnit 2.0.\n\t\t// In QUnit 2.0, invoking it will ONLY affect the `QUnit.config.autostart` blocking behavior.\n\t\tstart: function () {\n\t\t\tfunction start(count) {\n\t\t\t\tvar globalStartAlreadyCalled = globalStartCalled;\n\n\t\t\t\tif (!config.current) {\n\t\t\t\t\tglobalStartCalled = true;\n\n\t\t\t\t\tif (runStarted) {\n\t\t\t\t\t\tthrow new Error(\"Called start() outside of a test context while already started\");\n\t\t\t\t\t} else if (globalStartAlreadyCalled || count > 1) {\n\t\t\t\t\t\tthrow new Error(\"Called start() outside of a test context too many times\");\n\t\t\t\t\t} else if (config.autostart) {\n\t\t\t\t\t\tthrow new Error(\"Called start() outside of a test context when \" + \"QUnit.config.autostart was true\");\n\t\t\t\t\t} else if (!config.pageLoaded) {\n\n\t\t\t\t\t\t// The page isn't completely loaded yet, so bail out and let `QUnit.load` handle it\n\t\t\t\t\t\tconfig.autostart = true;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\t// If a test is running, adjust its semaphore\n\t\t\t\t\tconfig.current.semaphore -= count || 1;\n\n\t\t\t\t\t// If semaphore is non-numeric, throw error\n\t\t\t\t\tif (isNaN(config.current.semaphore)) {\n\t\t\t\t\t\tconfig.current.semaphore = 0;\n\n\t\t\t\t\t\tQUnit.pushFailure(\"Called start() with a non-numeric decrement.\", sourceFromStacktrace(2));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Don't start until equal number of stop-calls\n\t\t\t\t\tif (config.current.semaphore > 0) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw an Error if start is called more often than stop\n\t\t\t\t\tif (config.current.semaphore < 0) {\n\t\t\t\t\t\tconfig.current.semaphore = 0;\n\n\t\t\t\t\t\tQUnit.pushFailure(\"Called start() while already started (test's semaphore was 0 already)\", sourceFromStacktrace(2));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresumeProcessing();\n\t\t\t}\n\n\t\t\treturn start;\n\t\t}(),\n\n\t\t// DEPRECATED: QUnit.stop() will be removed in QUnit 2.0.\n\t\tstop: function () {\n\t\t\tfunction stop(count) {\n\n\t\t\t\t// If there isn't a test running, don't allow QUnit.stop() to be called\n\t\t\t\tif (!config.current) {\n\t\t\t\t\tthrow new Error(\"Called stop() outside of a test context\");\n\t\t\t\t}\n\n\t\t\t\t// If a test is running, adjust its semaphore\n\t\t\t\tconfig.current.semaphore += count || 1;\n\n\t\t\t\tpauseProcessing();\n\t\t\t}\n\n\t\t\treturn stop;\n\t\t}(),\n\n\t\tconfig: config,\n\n\t\tis: is,\n\n\t\tobjectType: objectType,\n\n\t\textend: extend,\n\n\t\tload: function () {\n\t\t\tfunction load() {\n\t\t\t\tconfig.pageLoaded = true;\n\n\t\t\t\t// Initialize the configuration options\n\t\t\t\textend(config, {\n\t\t\t\t\tstats: { all: 0, bad: 0 },\n\t\t\t\t\tmoduleStats: { all: 0, bad: 0 },\n\t\t\t\t\tstarted: 0,\n\t\t\t\t\tupdateRate: 1000,\n\t\t\t\t\tautostart: true,\n\t\t\t\t\tfilter: \"\"\n\t\t\t\t}, true);\n\n\t\t\t\tconfig.blocking = false;\n\n\t\t\t\tif (config.autostart) {\n\t\t\t\t\tresumeProcessing();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn load;\n\t\t}(),\n\n\t\tstack: function () {\n\t\t\tfunction stack(offset) {\n\t\t\t\toffset = (offset || 0) + 2;\n\t\t\t\treturn sourceFromStacktrace(offset);\n\t\t\t}\n\n\t\t\treturn stack;\n\t\t}()\n\t});\n\n\tregisterLoggingCallbacks(QUnit);\n\n\tfunction begin() {\n\t\tvar i,\n\t\t    l,\n\t\t    modulesLog = [];\n\n\t\t// If the test run hasn't officially begun yet\n\t\tif (!config.started) {\n\n\t\t\t// Record the time of the test run's beginning\n\t\t\tconfig.started = now();\n\n\t\t\tverifyLoggingCallbacks();\n\n\t\t\t// Delete the loose unnamed module if unused.\n\t\t\tif (config.modules[0].name === \"\" && config.modules[0].tests.length === 0) {\n\t\t\t\tconfig.modules.shift();\n\t\t\t}\n\n\t\t\t// Avoid unnecessary information by not logging modules' test environments\n\t\t\tfor (i = 0, l = config.modules.length; i < l; i++) {\n\t\t\t\tmodulesLog.push({\n\t\t\t\t\tname: config.modules[i].name,\n\t\t\t\t\ttests: config.modules[i].tests\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// The test run is officially beginning now\n\t\t\trunLoggingCallbacks(\"begin\", {\n\t\t\t\ttotalTests: Test.count,\n\t\t\t\tmodules: modulesLog\n\t\t\t});\n\t\t}\n\n\t\tconfig.blocking = false;\n\t\tprocess(true);\n\t}\n\n\tfunction process(last) {\n\t\tfunction next() {\n\t\t\tprocess(last);\n\t\t}\n\t\tvar start = now();\n\t\tconfig.depth = (config.depth || 0) + 1;\n\n\t\twhile (config.queue.length && !config.blocking) {\n\t\t\tif (!defined.setTimeout || config.updateRate <= 0 || now() - start < config.updateRate) {\n\t\t\t\tif (config.current) {\n\n\t\t\t\t\t// Reset async tracking for each phase of the Test lifecycle\n\t\t\t\t\tconfig.current.usedAsync = false;\n\t\t\t\t}\n\t\t\t\tconfig.queue.shift()();\n\t\t\t} else {\n\t\t\t\tsetTimeout(next, 13);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconfig.depth--;\n\t\tif (last && !config.blocking && !config.queue.length && config.depth === 0) {\n\t\t\tdone();\n\t\t}\n\t}\n\n\tfunction pauseProcessing() {\n\t\tconfig.blocking = true;\n\n\t\tif (config.testTimeout && defined.setTimeout) {\n\t\t\tclearTimeout(config.timeout);\n\t\t\tconfig.timeout = setTimeout(function () {\n\t\t\t\tif (config.current) {\n\t\t\t\t\tconfig.current.semaphore = 0;\n\t\t\t\t\tQUnit.pushFailure(\"Test timed out\", sourceFromStacktrace(2));\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"Test timed out\");\n\t\t\t\t}\n\t\t\t\tresumeProcessing();\n\t\t\t}, config.testTimeout);\n\t\t}\n\t}\n\n\tfunction resumeProcessing() {\n\t\trunStarted = true;\n\n\t\t// A slight delay to allow this iteration of the event loop to finish (more assertions, etc.)\n\t\tif (defined.setTimeout) {\n\t\t\tsetTimeout(function () {\n\t\t\t\tif (config.current && config.current.semaphore > 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (config.timeout) {\n\t\t\t\t\tclearTimeout(config.timeout);\n\t\t\t\t}\n\n\t\t\t\tbegin();\n\t\t\t}, 13);\n\t\t} else {\n\t\t\tbegin();\n\t\t}\n\t}\n\n\tfunction done() {\n\t\tvar runtime, passed;\n\n\t\tconfig.autorun = true;\n\n\t\t// Log the last module results\n\t\tif (config.previousModule) {\n\t\t\trunLoggingCallbacks(\"moduleDone\", {\n\t\t\t\tname: config.previousModule.name,\n\t\t\t\ttests: config.previousModule.tests,\n\t\t\t\tfailed: config.moduleStats.bad,\n\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\t\ttotal: config.moduleStats.all,\n\t\t\t\truntime: now() - config.moduleStats.started\n\t\t\t});\n\t\t}\n\t\tdelete config.previousModule;\n\n\t\truntime = now() - config.started;\n\t\tpassed = config.stats.all - config.stats.bad;\n\n\t\trunLoggingCallbacks(\"done\", {\n\t\t\tfailed: config.stats.bad,\n\t\t\tpassed: passed,\n\t\t\ttotal: config.stats.all,\n\t\t\truntime: runtime\n\t\t});\n\t}\n\n\tfunction setHook(module, hookName) {\n\t\tif (module.testEnvironment === undefined) {\n\t\t\tmodule.testEnvironment = {};\n\t\t}\n\n\t\treturn function (callback) {\n\t\t\tmodule.testEnvironment[hookName] = callback;\n\t\t};\n\t}\n\n\tvar focused = false;\n\n\tfunction Test(settings) {\n\t\tvar i, l;\n\n\t\t++Test.count;\n\n\t\textend(this, settings);\n\t\tthis.assertions = [];\n\t\tthis.semaphore = 0;\n\t\tthis.usedAsync = false;\n\t\tthis.module = config.currentModule;\n\t\tthis.stack = sourceFromStacktrace(3);\n\n\t\t// Register unique strings\n\t\tfor (i = 0, l = this.module.tests; i < l.length; i++) {\n\t\t\tif (this.module.tests[i].name === this.testName) {\n\t\t\t\tthis.testName += \" \";\n\t\t\t}\n\t\t}\n\n\t\tthis.testId = generateHash(this.module.name, this.testName);\n\n\t\tthis.module.tests.push({\n\t\t\tname: this.testName,\n\t\t\ttestId: this.testId\n\t\t});\n\n\t\tif (settings.skip) {\n\n\t\t\t// Skipped tests will fully ignore any sent callback\n\t\t\tthis.callback = function () {};\n\t\t\tthis.async = false;\n\t\t\tthis.expected = 0;\n\t\t} else {\n\t\t\tthis.assert = new Assert(this);\n\t\t}\n\t}\n\n\tTest.count = 0;\n\n\tTest.prototype = {\n\t\tbefore: function () {\n\t\t\tfunction before() {\n\t\t\t\tif (\n\n\t\t\t\t// Emit moduleStart when we're switching from one module to another\n\t\t\t\tthis.module !== config.previousModule ||\n\n\t\t\t\t// They could be equal (both undefined) but if the previousModule property doesn't\n\t\t\t\t// yet exist it means this is the first test in a suite that isn't wrapped in a\n\t\t\t\t// module, in which case we'll just emit a moduleStart event for 'undefined'.\n\t\t\t\t// Without this, reporters can get testStart before moduleStart  which is a problem.\n\t\t\t\t!hasOwn.call(config, \"previousModule\")) {\n\t\t\t\t\tif (hasOwn.call(config, \"previousModule\")) {\n\t\t\t\t\t\trunLoggingCallbacks(\"moduleDone\", {\n\t\t\t\t\t\t\tname: config.previousModule.name,\n\t\t\t\t\t\t\ttests: config.previousModule.tests,\n\t\t\t\t\t\t\tfailed: config.moduleStats.bad,\n\t\t\t\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\t\t\t\t\ttotal: config.moduleStats.all,\n\t\t\t\t\t\t\truntime: now() - config.moduleStats.started\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tconfig.previousModule = this.module;\n\t\t\t\t\tconfig.moduleStats = { all: 0, bad: 0, started: now() };\n\t\t\t\t\trunLoggingCallbacks(\"moduleStart\", {\n\t\t\t\t\t\tname: this.module.name,\n\t\t\t\t\t\ttests: this.module.tests\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconfig.current = this;\n\n\t\t\t\tif (this.module.testEnvironment) {\n\t\t\t\t\tdelete this.module.testEnvironment.beforeEach;\n\t\t\t\t\tdelete this.module.testEnvironment.afterEach;\n\t\t\t\t}\n\t\t\t\tthis.testEnvironment = extend({}, this.module.testEnvironment);\n\n\t\t\t\tthis.started = now();\n\t\t\t\trunLoggingCallbacks(\"testStart\", {\n\t\t\t\t\tname: this.testName,\n\t\t\t\t\tmodule: this.module.name,\n\t\t\t\t\ttestId: this.testId\n\t\t\t\t});\n\n\t\t\t\tif (!config.pollution) {\n\t\t\t\t\tsaveGlobal();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn before;\n\t\t}(),\n\n\t\trun: function () {\n\t\t\tfunction run() {\n\t\t\t\tvar promise;\n\n\t\t\t\tconfig.current = this;\n\n\t\t\t\tif (this.async) {\n\t\t\t\t\tQUnit.stop();\n\t\t\t\t}\n\n\t\t\t\tthis.callbackStarted = now();\n\n\t\t\t\tif (config.notrycatch) {\n\t\t\t\t\trunTest(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\trunTest(this);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthis.pushFailure(\"Died on test #\" + (this.assertions.length + 1) + \" \" + this.stack + \": \" + (e.message || e), extractStacktrace(e, 0));\n\n\t\t\t\t\t// else next test will carry the responsibility\n\t\t\t\t\tsaveGlobal();\n\n\t\t\t\t\t// Restart the tests if they're blocking\n\t\t\t\t\tif (config.blocking) {\n\t\t\t\t\t\tQUnit.start();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction runTest(test) {\n\t\t\t\t\tpromise = test.callback.call(test.testEnvironment, test.assert);\n\t\t\t\t\ttest.resolvePromise(promise);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn run;\n\t\t}(),\n\n\t\tafter: function () {\n\t\t\tfunction after() {\n\t\t\t\tcheckPollution();\n\t\t\t}\n\n\t\t\treturn after;\n\t\t}(),\n\n\t\tqueueHook: function () {\n\t\t\tfunction queueHook(hook, hookName) {\n\t\t\t\tvar promise,\n\t\t\t\t    test = this;\n\t\t\t\treturn function () {\n\t\t\t\t\tfunction runHook() {\n\t\t\t\t\t\tconfig.current = test;\n\t\t\t\t\t\tif (config.notrycatch) {\n\t\t\t\t\t\t\tcallHook();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcallHook();\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\ttest.pushFailure(hookName + \" failed on \" + test.testName + \": \" + (error.message || error), extractStacktrace(error, 0));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfunction callHook() {\n\t\t\t\t\t\t\tpromise = hook.call(test.testEnvironment, test.assert);\n\t\t\t\t\t\t\ttest.resolvePromise(promise, hookName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn runHook;\n\t\t\t\t}();\n\t\t\t}\n\n\t\t\treturn queueHook;\n\t\t}(),\n\n\t\t// Currently only used for module level hooks, can be used to add global level ones\n\t\thooks: function () {\n\t\t\tfunction hooks(handler) {\n\t\t\t\tvar hooks = [];\n\n\t\t\t\tfunction processHooks(test, module) {\n\t\t\t\t\tif (module.parentModule) {\n\t\t\t\t\t\tprocessHooks(test, module.parentModule);\n\t\t\t\t\t}\n\t\t\t\t\tif (module.testEnvironment && QUnit.objectType(module.testEnvironment[handler]) === \"function\") {\n\t\t\t\t\t\thooks.push(test.queueHook(module.testEnvironment[handler], handler));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Hooks are ignored on skipped tests\n\t\t\t\tif (!this.skip) {\n\t\t\t\t\tprocessHooks(this, this.module);\n\t\t\t\t}\n\t\t\t\treturn hooks;\n\t\t\t}\n\n\t\t\treturn hooks;\n\t\t}(),\n\n\t\tfinish: function () {\n\t\t\tfunction finish() {\n\t\t\t\tconfig.current = this;\n\t\t\t\tif (config.requireExpects && this.expected === null) {\n\t\t\t\t\tthis.pushFailure(\"Expected number of assertions to be defined, but expect() was \" + \"not called.\", this.stack);\n\t\t\t\t} else if (this.expected !== null && this.expected !== this.assertions.length) {\n\t\t\t\t\tthis.pushFailure(\"Expected \" + this.expected + \" assertions, but \" + this.assertions.length + \" were run\", this.stack);\n\t\t\t\t} else if (this.expected === null && !this.assertions.length) {\n\t\t\t\t\tthis.pushFailure(\"Expected at least one assertion, but none were run - call \" + \"expect(0) to accept zero assertions.\", this.stack);\n\t\t\t\t}\n\n\t\t\t\tvar i,\n\t\t\t\t    bad = 0;\n\n\t\t\t\tthis.runtime = now() - this.started;\n\t\t\t\tconfig.stats.all += this.assertions.length;\n\t\t\t\tconfig.moduleStats.all += this.assertions.length;\n\n\t\t\t\tfor (i = 0; i < this.assertions.length; i++) {\n\t\t\t\t\tif (!this.assertions[i].result) {\n\t\t\t\t\t\tbad++;\n\t\t\t\t\t\tconfig.stats.bad++;\n\t\t\t\t\t\tconfig.moduleStats.bad++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trunLoggingCallbacks(\"testDone\", {\n\t\t\t\t\tname: this.testName,\n\t\t\t\t\tmodule: this.module.name,\n\t\t\t\t\tskipped: !!this.skip,\n\t\t\t\t\tfailed: bad,\n\t\t\t\t\tpassed: this.assertions.length - bad,\n\t\t\t\t\ttotal: this.assertions.length,\n\t\t\t\t\truntime: this.runtime,\n\n\t\t\t\t\t// HTML Reporter use\n\t\t\t\t\tassertions: this.assertions,\n\t\t\t\t\ttestId: this.testId,\n\n\t\t\t\t\t// Source of Test\n\t\t\t\t\tsource: this.stack,\n\n\t\t\t\t\t// DEPRECATED: this property will be removed in 2.0.0, use runtime instead\n\t\t\t\t\tduration: this.runtime\n\t\t\t\t});\n\n\t\t\t\t// QUnit.reset() is deprecated and will be replaced for a new\n\t\t\t\t// fixture reset function on QUnit 2.0/2.1.\n\t\t\t\t// It's still called here for backwards compatibility handling\n\t\t\t\tQUnit.reset();\n\n\t\t\t\tconfig.current = undefined;\n\t\t\t}\n\n\t\t\treturn finish;\n\t\t}(),\n\n\t\tqueue: function () {\n\t\t\tfunction queue() {\n\t\t\t\tvar priority,\n\t\t\t\t    test = this;\n\n\t\t\t\tif (!this.valid()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfunction run() {\n\n\t\t\t\t\t// each of these can by async\n\t\t\t\t\tsynchronize([function () {\n\t\t\t\t\t\ttest.before();\n\t\t\t\t\t}, test.hooks(\"beforeEach\"), function () {\n\t\t\t\t\t\ttest.run();\n\t\t\t\t\t}, test.hooks(\"afterEach\").reverse(), function () {\n\t\t\t\t\t\ttest.after();\n\t\t\t\t\t}, function () {\n\t\t\t\t\t\ttest.finish();\n\t\t\t\t\t}]);\n\t\t\t\t}\n\n\t\t\t\t// Prioritize previously failed tests, detected from sessionStorage\n\t\t\t\tpriority = QUnit.config.reorder && defined.sessionStorage && +sessionStorage.getItem(\"qunit-test-\" + this.module.name + \"-\" + this.testName);\n\n\t\t\t\treturn synchronize(run, priority);\n\t\t\t}\n\n\t\t\treturn queue;\n\t\t}(),\n\n\t\tpush: function () {\n\t\t\tfunction push(result, actual, expected, message, negative) {\n\t\t\t\tvar source,\n\t\t\t\t    details = {\n\t\t\t\t\tmodule: this.module.name,\n\t\t\t\t\tname: this.testName,\n\t\t\t\t\tresult: result,\n\t\t\t\t\tmessage: message,\n\t\t\t\t\tactual: actual,\n\t\t\t\t\texpected: expected,\n\t\t\t\t\ttestId: this.testId,\n\t\t\t\t\tnegative: negative || false,\n\t\t\t\t\truntime: now() - this.started\n\t\t\t\t};\n\n\t\t\t\tif (!result) {\n\t\t\t\t\tsource = sourceFromStacktrace();\n\n\t\t\t\t\tif (source) {\n\t\t\t\t\t\tdetails.source = source;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trunLoggingCallbacks(\"log\", details);\n\n\t\t\t\tthis.assertions.push({\n\t\t\t\t\tresult: !!result,\n\t\t\t\t\tmessage: message\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn push;\n\t\t}(),\n\n\t\tpushFailure: function () {\n\t\t\tfunction pushFailure(message, source, actual) {\n\t\t\t\tif (!(this instanceof Test)) {\n\t\t\t\t\tthrow new Error(\"pushFailure() assertion outside test context, was \" + sourceFromStacktrace(2));\n\t\t\t\t}\n\n\t\t\t\tvar details = {\n\t\t\t\t\tmodule: this.module.name,\n\t\t\t\t\tname: this.testName,\n\t\t\t\t\tresult: false,\n\t\t\t\t\tmessage: message || \"error\",\n\t\t\t\t\tactual: actual || null,\n\t\t\t\t\ttestId: this.testId,\n\t\t\t\t\truntime: now() - this.started\n\t\t\t\t};\n\n\t\t\t\tif (source) {\n\t\t\t\t\tdetails.source = source;\n\t\t\t\t}\n\n\t\t\t\trunLoggingCallbacks(\"log\", details);\n\n\t\t\t\tthis.assertions.push({\n\t\t\t\t\tresult: false,\n\t\t\t\t\tmessage: message\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn pushFailure;\n\t\t}(),\n\n\t\tresolvePromise: function () {\n\t\t\tfunction resolvePromise(promise, phase) {\n\t\t\t\tvar then,\n\t\t\t\t    message,\n\t\t\t\t    test = this;\n\t\t\t\tif (promise != null) {\n\t\t\t\t\tthen = promise.then;\n\t\t\t\t\tif (QUnit.objectType(then) === \"function\") {\n\t\t\t\t\t\tQUnit.stop();\n\t\t\t\t\t\tthen.call(promise, function () {\n\t\t\t\t\t\t\tQUnit.start();\n\t\t\t\t\t\t}, function (error) {\n\t\t\t\t\t\t\tmessage = \"Promise rejected \" + (!phase ? \"during\" : phase.replace(/Each$/, \"\")) + \" \" + test.testName + \": \" + (error.message || error);\n\t\t\t\t\t\t\ttest.pushFailure(message, extractStacktrace(error, 0));\n\n\t\t\t\t\t\t\t// else next test will carry the responsibility\n\t\t\t\t\t\t\tsaveGlobal();\n\n\t\t\t\t\t\t\t// Unblock\n\t\t\t\t\t\t\tQUnit.start();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn resolvePromise;\n\t\t}(),\n\n\t\tvalid: function () {\n\t\t\tfunction valid() {\n\t\t\t\tvar include,\n\t\t\t\t    filter = config.filter && config.filter.toLowerCase(),\n\t\t\t\t    module = QUnit.urlParams.module && QUnit.urlParams.module.toLowerCase(),\n\t\t\t\t    fullName = (this.module.name + \": \" + this.testName).toLowerCase();\n\n\t\t\t\tfunction testInModuleChain(testModule) {\n\t\t\t\t\tvar testModuleName = testModule.name ? testModule.name.toLowerCase() : null;\n\t\t\t\t\tif (testModuleName === module) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (testModule.parentModule) {\n\t\t\t\t\t\treturn testInModuleChain(testModule.parentModule);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Internally-generated tests are always valid\n\t\t\t\tif (this.callback && this.callback.validTest) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tif (config.testId.length > 0 && inArray(this.testId, config.testId) < 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (module && !testInModuleChain(this.module)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (!filter) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tinclude = filter.charAt(0) !== \"!\";\n\t\t\t\tif (!include) {\n\t\t\t\t\tfilter = filter.slice(1);\n\t\t\t\t}\n\n\t\t\t\t// If the filter matches, we need to honour include\n\t\t\t\tif (fullName.indexOf(filter) !== -1) {\n\t\t\t\t\treturn include;\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, do the opposite\n\t\t\t\treturn !include;\n\t\t\t}\n\n\t\t\treturn valid;\n\t\t}()\n\t};\n\n\t// Resets the test setup. Useful for tests that modify the DOM.\n\t/*\n DEPRECATED: Use multiple tests instead of resetting inside a test.\n Use testStart or testDone for custom cleanup.\n This method will throw an error in 2.0, and will be removed in 2.1\n */\n\tQUnit.reset = function () {\n\n\t\t// Return on non-browser environments\n\t\t// This is necessary to not break on node tests\n\t\tif (!defined.document) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar fixture = defined.document && document.getElementById && document.getElementById(\"qunit-fixture\");\n\n\t\tif (fixture) {\n\t\t\tfixture.innerHTML = config.fixture;\n\t\t}\n\t};\n\n\tQUnit.pushFailure = function () {\n\t\tif (!QUnit.config.current) {\n\t\t\tthrow new Error(\"pushFailure() assertion outside test context, in \" + sourceFromStacktrace(2));\n\t\t}\n\n\t\t// Gets current test obj\n\t\tvar currentTest = QUnit.config.current;\n\n\t\treturn currentTest.pushFailure.apply(currentTest, arguments);\n\t};\n\n\t// Based on Java's String.hashCode, a simple but not\n\t// rigorously collision resistant hashing function\n\tfunction generateHash(module, testName) {\n\t\tvar hex,\n\t\t    i = 0,\n\t\t    hash = 0,\n\t\t    str = module + \"\\x1C\" + testName,\n\t\t    len = str.length;\n\n\t\tfor (; i < len; i++) {\n\t\t\thash = (hash << 5) - hash + str.charCodeAt(i);\n\t\t\thash |= 0;\n\t\t}\n\n\t\t// Convert the possibly negative integer hash code into an 8 character hex string, which isn't\n\t\t// strictly necessary but increases user understanding that the id is a SHA-like hash\n\t\thex = (0x100000000 + hash).toString(16);\n\t\tif (hex.length < 8) {\n\t\t\thex = \"0000000\" + hex;\n\t\t}\n\n\t\treturn hex.slice(-8);\n\t}\n\n\tfunction synchronize(callback, priority) {\n\t\tvar last = !priority;\n\n\t\tif (QUnit.objectType(callback) === \"array\") {\n\t\t\twhile (callback.length) {\n\t\t\t\tsynchronize(callback.shift());\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (priority) {\n\t\t\tpriorityFill(callback);\n\t\t} else {\n\t\t\tconfig.queue.push(callback);\n\t\t}\n\n\t\tif (config.autorun && !config.blocking) {\n\t\t\tprocess(last);\n\t\t}\n\t}\n\n\t// Place previously failed tests on a queue priority line, respecting the order they get assigned.\n\tfunction priorityFill(callback) {\n\t\tvar queue, prioritizedQueue;\n\n\t\tqueue = config.queue.slice(priorityFill.pos);\n\t\tprioritizedQueue = config.queue.slice(0, -config.queue.length + priorityFill.pos);\n\n\t\tqueue.unshift(callback);\n\t\tqueue.unshift.apply(queue, prioritizedQueue);\n\n\t\tconfig.queue = queue;\n\n\t\tpriorityFill.pos += 1;\n\t}\n\tpriorityFill.pos = 0;\n\n\tfunction saveGlobal() {\n\t\tconfig.pollution = [];\n\n\t\tif (config.noglobals) {\n\t\t\tfor (var key in meteorBabelHelpers.sanitizeForInObject(global)) {\n\t\t\t\tif (hasOwn.call(global, key)) {\n\n\t\t\t\t\t// in Opera sometimes DOM element ids show up here, ignore them\n\t\t\t\t\tif (/^qunit-test-output/.test(key)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconfig.pollution.push(key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction checkPollution() {\n\t\tvar newGlobals,\n\t\t    deletedGlobals,\n\t\t    old = config.pollution;\n\n\t\tsaveGlobal();\n\n\t\tnewGlobals = diff(config.pollution, old);\n\t\tif (newGlobals.length > 0) {\n\t\t\tQUnit.pushFailure(\"Introduced global variable(s): \" + newGlobals.join(\", \"));\n\t\t}\n\n\t\tdeletedGlobals = diff(old, config.pollution);\n\t\tif (deletedGlobals.length > 0) {\n\t\t\tQUnit.pushFailure(\"Deleted global variable(s): \" + deletedGlobals.join(\", \"));\n\t\t}\n\t}\n\n\t// Will be exposed as QUnit.asyncTest\n\tfunction asyncTest(testName, expected, callback) {\n\t\tif (arguments.length === 2) {\n\t\t\tcallback = expected;\n\t\t\texpected = null;\n\t\t}\n\n\t\tQUnit.test(testName, expected, callback, true);\n\t}\n\n\t// Will be exposed as QUnit.test\n\tfunction test(testName, expected, callback, async) {\n\t\tif (focused) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar newTest;\n\n\t\tif (arguments.length === 2) {\n\t\t\tcallback = expected;\n\t\t\texpected = null;\n\t\t}\n\n\t\tnewTest = new Test({\n\t\t\ttestName: testName,\n\t\t\texpected: expected,\n\t\t\tasync: async,\n\t\t\tcallback: callback\n\t\t});\n\n\t\tnewTest.queue();\n\t}\n\n\t// Will be exposed as QUnit.skip\n\tfunction skip(testName) {\n\t\tif (focused) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar test = new Test({\n\t\t\ttestName: testName,\n\t\t\tskip: true\n\t\t});\n\n\t\ttest.queue();\n\t}\n\n\t// Will be exposed as QUnit.only\n\tfunction only(testName, expected, callback, async) {\n\t\tvar newTest;\n\n\t\tif (focused) {\n\t\t\treturn;\n\t\t}\n\n\t\tQUnit.config.queue.length = 0;\n\t\tfocused = true;\n\n\t\tif (arguments.length === 2) {\n\t\t\tcallback = expected;\n\t\t\texpected = null;\n\t\t}\n\n\t\tnewTest = new Test({\n\t\t\ttestName: testName,\n\t\t\texpected: expected,\n\t\t\tasync: async,\n\t\t\tcallback: callback\n\t\t});\n\n\t\tnewTest.queue();\n\t}\n\n\tfunction Assert(testContext) {\n\t\tthis.test = testContext;\n\t}\n\n\t// Assert helpers\n\tQUnit.assert = Assert.prototype = {\n\n\t\t// Specify the number of expected assertions to guarantee that failed test\n\t\t// (no assertions are run at all) don't slip through.\n\t\texpect: function () {\n\t\t\tfunction expect(asserts) {\n\t\t\t\tif (arguments.length === 1) {\n\t\t\t\t\tthis.test.expected = asserts;\n\t\t\t\t} else {\n\t\t\t\t\treturn this.test.expected;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn expect;\n\t\t}(),\n\n\t\t// Increment this Test's semaphore counter, then return a function that\n\t\t// decrements that counter a maximum of once.\n\t\tasync: function () {\n\t\t\tfunction async(count) {\n\t\t\t\tvar test = this.test,\n\t\t\t\t    popped = false,\n\t\t\t\t    acceptCallCount = count;\n\n\t\t\t\tif (typeof acceptCallCount === \"undefined\") {\n\t\t\t\t\tacceptCallCount = 1;\n\t\t\t\t}\n\n\t\t\t\ttest.semaphore += 1;\n\t\t\t\ttest.usedAsync = true;\n\t\t\t\tpauseProcessing();\n\n\t\t\t\treturn function () {\n\t\t\t\t\tfunction done() {\n\n\t\t\t\t\t\tif (popped) {\n\t\t\t\t\t\t\ttest.pushFailure(\"Too many calls to the `assert.async` callback\", sourceFromStacktrace(2));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tacceptCallCount -= 1;\n\t\t\t\t\t\tif (acceptCallCount > 0) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttest.semaphore -= 1;\n\t\t\t\t\t\tpopped = true;\n\t\t\t\t\t\tresumeProcessing();\n\t\t\t\t\t}\n\n\t\t\t\t\treturn done;\n\t\t\t\t}();\n\t\t\t}\n\n\t\t\treturn async;\n\t\t}(),\n\n\t\t// Exports test.push() to the user API\n\t\tpush: function () {\n\t\t\tfunction push() /* result, actual, expected, message, negative */{\n\t\t\t\tvar assert = this,\n\t\t\t\t    currentTest = assert instanceof Assert && assert.test || QUnit.config.current;\n\n\t\t\t\t// Backwards compatibility fix.\n\t\t\t\t// Allows the direct use of global exported assertions and QUnit.assert.*\n\t\t\t\t// Although, it's use is not recommended as it can leak assertions\n\t\t\t\t// to other tests from async tests, because we only get a reference to the current test,\n\t\t\t\t// not exactly the test where assertion were intended to be called.\n\t\t\t\tif (!currentTest) {\n\t\t\t\t\tthrow new Error(\"assertion outside test context, in \" + sourceFromStacktrace(2));\n\t\t\t\t}\n\n\t\t\t\tif (currentTest.usedAsync === true && currentTest.semaphore === 0) {\n\t\t\t\t\tcurrentTest.pushFailure(\"Assertion after the final `assert.async` was resolved\", sourceFromStacktrace(2));\n\n\t\t\t\t\t// Allow this assertion to continue running anyway...\n\t\t\t\t}\n\n\t\t\t\tif (!(assert instanceof Assert)) {\n\t\t\t\t\tassert = currentTest.assert;\n\t\t\t\t}\n\t\t\t\treturn assert.test.push.apply(assert.test, arguments);\n\t\t\t}\n\n\t\t\treturn push;\n\t\t}(),\n\n\t\tok: function () {\n\t\t\tfunction ok(result, message) {\n\t\t\t\tmessage = message || (result ? \"okay\" : \"failed, expected argument to be truthy, was: \" + QUnit.dump.parse(result));\n\t\t\t\tthis.push(!!result, result, true, message);\n\t\t\t}\n\n\t\t\treturn ok;\n\t\t}(),\n\n\t\tnotOk: function () {\n\t\t\tfunction notOk(result, message) {\n\t\t\t\tmessage = message || (!result ? \"okay\" : \"failed, expected argument to be falsy, was: \" + QUnit.dump.parse(result));\n\t\t\t\tthis.push(!result, result, false, message, true);\n\t\t\t}\n\n\t\t\treturn notOk;\n\t\t}(),\n\n\t\tequal: function () {\n\t\t\tfunction equal(actual, expected, message) {\n\t\t\t\t/*jshint eqeqeq:false */\n\t\t\t\tthis.push(expected == actual, actual, expected, message);\n\t\t\t}\n\n\t\t\treturn equal;\n\t\t}(),\n\n\t\tnotEqual: function () {\n\t\t\tfunction notEqual(actual, expected, message) {\n\t\t\t\t/*jshint eqeqeq:false */\n\t\t\t\tthis.push(expected != actual, actual, expected, message, true);\n\t\t\t}\n\n\t\t\treturn notEqual;\n\t\t}(),\n\n\t\tpropEqual: function () {\n\t\t\tfunction propEqual(actual, expected, message) {\n\t\t\t\tactual = objectValues(actual);\n\t\t\t\texpected = objectValues(expected);\n\t\t\t\tthis.push(QUnit.equiv(actual, expected), actual, expected, message);\n\t\t\t}\n\n\t\t\treturn propEqual;\n\t\t}(),\n\n\t\tnotPropEqual: function () {\n\t\t\tfunction notPropEqual(actual, expected, message) {\n\t\t\t\tactual = objectValues(actual);\n\t\t\t\texpected = objectValues(expected);\n\t\t\t\tthis.push(!QUnit.equiv(actual, expected), actual, expected, message, true);\n\t\t\t}\n\n\t\t\treturn notPropEqual;\n\t\t}(),\n\n\t\tdeepEqual: function () {\n\t\t\tfunction deepEqual(actual, expected, message) {\n\t\t\t\tthis.push(QUnit.equiv(actual, expected), actual, expected, message);\n\t\t\t}\n\n\t\t\treturn deepEqual;\n\t\t}(),\n\n\t\tnotDeepEqual: function () {\n\t\t\tfunction notDeepEqual(actual, expected, message) {\n\t\t\t\tthis.push(!QUnit.equiv(actual, expected), actual, expected, message, true);\n\t\t\t}\n\n\t\t\treturn notDeepEqual;\n\t\t}(),\n\n\t\tstrictEqual: function () {\n\t\t\tfunction strictEqual(actual, expected, message) {\n\t\t\t\tthis.push(expected === actual, actual, expected, message);\n\t\t\t}\n\n\t\t\treturn strictEqual;\n\t\t}(),\n\n\t\tnotStrictEqual: function () {\n\t\t\tfunction notStrictEqual(actual, expected, message) {\n\t\t\t\tthis.push(expected !== actual, actual, expected, message, true);\n\t\t\t}\n\n\t\t\treturn notStrictEqual;\n\t\t}(),\n\n\t\t\"throws\": function () {\n\t\t\tfunction throws(block, expected, message) {\n\t\t\t\tvar actual,\n\t\t\t\t    expectedType,\n\t\t\t\t    expectedOutput = expected,\n\t\t\t\t    ok = false,\n\t\t\t\t    currentTest = this instanceof Assert && this.test || QUnit.config.current;\n\n\t\t\t\t// 'expected' is optional unless doing string comparison\n\t\t\t\tif (message == null && typeof expected === \"string\") {\n\t\t\t\t\tmessage = expected;\n\t\t\t\t\texpected = null;\n\t\t\t\t}\n\n\t\t\t\tcurrentTest.ignoreGlobalErrors = true;\n\t\t\t\ttry {\n\t\t\t\t\tblock.call(currentTest.testEnvironment);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tactual = e;\n\t\t\t\t}\n\t\t\t\tcurrentTest.ignoreGlobalErrors = false;\n\n\t\t\t\tif (actual) {\n\t\t\t\t\texpectedType = QUnit.objectType(expected);\n\n\t\t\t\t\t// we don't want to validate thrown error\n\t\t\t\t\tif (!expected) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\texpectedOutput = null;\n\n\t\t\t\t\t\t// expected is a regexp\n\t\t\t\t\t} else if (expectedType === \"regexp\") {\n\t\t\t\t\t\t\tok = expected.test(errorString(actual));\n\n\t\t\t\t\t\t\t// expected is a string\n\t\t\t\t\t\t} else if (expectedType === \"string\") {\n\t\t\t\t\t\t\t\tok = expected === errorString(actual);\n\n\t\t\t\t\t\t\t\t// expected is a constructor, maybe an Error constructor\n\t\t\t\t\t\t\t} else if (expectedType === \"function\" && actual instanceof expected) {\n\t\t\t\t\t\t\t\t\tok = true;\n\n\t\t\t\t\t\t\t\t\t// expected is an Error object\n\t\t\t\t\t\t\t\t} else if (expectedType === \"object\") {\n\t\t\t\t\t\t\t\t\t\tok = actual instanceof expected.constructor && actual.name === expected.name && actual.message === expected.message;\n\n\t\t\t\t\t\t\t\t\t\t// expected is a validation function which returns true if validation passed\n\t\t\t\t\t\t\t\t\t} else if (expectedType === \"function\" && expected.call({}, actual) === true) {\n\t\t\t\t\t\t\t\t\t\t\texpectedOutput = null;\n\t\t\t\t\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcurrentTest.assert.push(ok, actual, expectedOutput, message);\n\t\t\t}\n\n\t\t\treturn throws;\n\t\t}()\n\t};\n\n\t// Provide an alternative to assert.throws(), for environments that consider throws a reserved word\n\t// Known to us are: Closure Compiler, Narwhal\n\t(function () {\n\t\t/*jshint sub:true */\n\t\tAssert.prototype.raises = Assert.prototype[\"throws\"];\n\t})();\n\n\tfunction errorString(error) {\n\t\tvar name,\n\t\t    message,\n\t\t    resultErrorString = error.toString();\n\t\tif (resultErrorString.substring(0, 7) === \"[object\") {\n\t\t\tname = error.name ? error.name.toString() : \"Error\";\n\t\t\tmessage = error.message ? error.message.toString() : \"\";\n\t\t\tif (name && message) {\n\t\t\t\treturn name + \": \" + message;\n\t\t\t} else if (name) {\n\t\t\t\treturn name;\n\t\t\t} else if (message) {\n\t\t\t\treturn message;\n\t\t\t} else {\n\t\t\t\treturn \"Error\";\n\t\t\t}\n\t\t} else {\n\t\t\treturn resultErrorString;\n\t\t}\n\t}\n\n\t// Test for equality any JavaScript type.\n\t// Author: Philippe Rath√© <prathe@gmail.com>\n\tQUnit.equiv = function () {\n\n\t\t// Stack to decide between skip/abort functions\n\t\tvar callers = [];\n\n\t\t// Stack to avoiding loops from circular referencing\n\t\tvar parents = [];\n\t\tvar parentsB = [];\n\n\t\tfunction useStrictEquality(b, a) {\n\n\t\t\t/*jshint eqeqeq:false */\n\t\t\tif (b instanceof a.constructor || a instanceof b.constructor) {\n\n\t\t\t\t// To catch short annotation VS 'new' annotation of a declaration. e.g.:\n\t\t\t\t// `var i = 1;`\n\t\t\t\t// `var j = new Number(1);`\n\t\t\t\treturn a == b;\n\t\t\t} else {\n\t\t\t\treturn a === b;\n\t\t\t}\n\t\t}\n\n\t\tfunction compareConstructors(a, b) {\n\t\t\tvar getProto = Object.getPrototypeOf || function (obj) {\n\n\t\t\t\t/*jshint proto: true */\n\t\t\t\treturn obj.__proto__;\n\t\t\t};\n\t\t\tvar protoA = getProto(a);\n\t\t\tvar protoB = getProto(b);\n\n\t\t\t// Comparing constructors is more strict than using `instanceof`\n\t\t\tif (a.constructor === b.constructor) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Ref #851\n\t\t\t// If the obj prototype descends from a null constructor, treat it\n\t\t\t// as a null prototype.\n\t\t\tif (protoA && protoA.constructor === null) {\n\t\t\t\tprotoA = null;\n\t\t\t}\n\t\t\tif (protoB && protoB.constructor === null) {\n\t\t\t\tprotoB = null;\n\t\t\t}\n\n\t\t\t// Allow objects with no prototype to be equivalent to\n\t\t\t// objects with Object as their constructor.\n\t\t\tif (protoA === null && protoB === Object.prototype || protoB === null && protoA === Object.prototype) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tvar callbacks = {\n\t\t\t\"string\": useStrictEquality,\n\t\t\t\"boolean\": useStrictEquality,\n\t\t\t\"number\": useStrictEquality,\n\t\t\t\"null\": useStrictEquality,\n\t\t\t\"undefined\": useStrictEquality,\n\t\t\t\"symbol\": useStrictEquality,\n\n\t\t\t\"nan\": function () {\n\t\t\t\tfunction nan(b) {\n\t\t\t\t\treturn isNaN(b);\n\t\t\t\t}\n\n\t\t\t\treturn nan;\n\t\t\t}(),\n\n\t\t\t\"date\": function () {\n\t\t\t\tfunction date(b, a) {\n\t\t\t\t\treturn QUnit.objectType(b) === \"date\" && a.valueOf() === b.valueOf();\n\t\t\t\t}\n\n\t\t\t\treturn date;\n\t\t\t}(),\n\n\t\t\t\"regexp\": function () {\n\t\t\t\tfunction regexp(b, a) {\n\t\t\t\t\treturn QUnit.objectType(b) === \"regexp\" &&\n\n\t\t\t\t\t// The regex itself\n\t\t\t\t\ta.source === b.source &&\n\n\t\t\t\t\t// And its modifiers\n\t\t\t\t\ta.global === b.global &&\n\n\t\t\t\t\t// (gmi) ...\n\t\t\t\t\ta.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky;\n\t\t\t\t}\n\n\t\t\t\treturn regexp;\n\t\t\t}(),\n\n\t\t\t// - skip when the property is a method of an instance (OOP)\n\t\t\t// - abort otherwise,\n\t\t\t// initial === would have catch identical references anyway\n\t\t\t\"function\": function () {\n\t\t\t\tfunction _function() {\n\t\t\t\t\tvar caller = callers[callers.length - 1];\n\t\t\t\t\treturn caller !== Object && typeof caller !== \"undefined\";\n\t\t\t\t}\n\n\t\t\t\treturn _function;\n\t\t\t}(),\n\n\t\t\t\"array\": function () {\n\t\t\t\tfunction array(b, a) {\n\t\t\t\t\tvar i, j, len, loop, aCircular, bCircular;\n\n\t\t\t\t\t// b could be an object literal here\n\t\t\t\t\tif (QUnit.objectType(b) !== \"array\") {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tlen = a.length;\n\t\t\t\t\tif (len !== b.length) {\n\t\t\t\t\t\t// safe and faster\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Track reference to avoid circular references\n\t\t\t\t\tparents.push(a);\n\t\t\t\t\tparentsB.push(b);\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tloop = false;\n\t\t\t\t\t\tfor (j = 0; j < parents.length; j++) {\n\t\t\t\t\t\t\taCircular = parents[j] === a[i];\n\t\t\t\t\t\t\tbCircular = parentsB[j] === b[i];\n\t\t\t\t\t\t\tif (aCircular || bCircular) {\n\t\t\t\t\t\t\t\tif (a[i] === b[i] || aCircular && bCircular) {\n\t\t\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!loop && !innerEquiv(a[i], b[i])) {\n\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tparents.pop();\n\t\t\t\t\tparentsB.pop();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\t\t\t}(),\n\n\t\t\t\"set\": function () {\n\t\t\t\tfunction set(b, a) {\n\t\t\t\t\tvar aArray, bArray;\n\n\t\t\t\t\t// `b` could be any object here\n\t\t\t\t\tif (QUnit.objectType(b) !== \"set\") {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\taArray = [];\n\t\t\t\t\ta.forEach(function (v) {\n\t\t\t\t\t\taArray.push(v);\n\t\t\t\t\t});\n\t\t\t\t\tbArray = [];\n\t\t\t\t\tb.forEach(function (v) {\n\t\t\t\t\t\tbArray.push(v);\n\t\t\t\t\t});\n\n\t\t\t\t\treturn innerEquiv(bArray, aArray);\n\t\t\t\t}\n\n\t\t\t\treturn set;\n\t\t\t}(),\n\n\t\t\t\"map\": function () {\n\t\t\t\tfunction map(b, a) {\n\t\t\t\t\tvar aArray, bArray;\n\n\t\t\t\t\t// `b` could be any object here\n\t\t\t\t\tif (QUnit.objectType(b) !== \"map\") {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\taArray = [];\n\t\t\t\t\ta.forEach(function (v, k) {\n\t\t\t\t\t\taArray.push([k, v]);\n\t\t\t\t\t});\n\t\t\t\t\tbArray = [];\n\t\t\t\t\tb.forEach(function (v, k) {\n\t\t\t\t\t\tbArray.push([k, v]);\n\t\t\t\t\t});\n\n\t\t\t\t\treturn innerEquiv(bArray, aArray);\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}(),\n\n\t\t\t\"object\": function () {\n\t\t\t\tfunction object(b, a) {\n\t\t\t\t\tvar i, j, loop, aCircular, bCircular;\n\n\t\t\t\t\t// Default to true\n\t\t\t\t\tvar eq = true;\n\t\t\t\t\tvar aProperties = [];\n\t\t\t\t\tvar bProperties = [];\n\n\t\t\t\t\tif (compareConstructors(a, b) === false) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Stack constructor before traversing properties\n\t\t\t\t\tcallers.push(a.constructor);\n\n\t\t\t\t\t// Track reference to avoid circular references\n\t\t\t\t\tparents.push(a);\n\t\t\t\t\tparentsB.push(b);\n\n\t\t\t\t\t// Be strict: don't ensure hasOwnProperty and go deep\n\t\t\t\t\tfor (i in meteorBabelHelpers.sanitizeForInObject(a)) {\n\t\t\t\t\t\tloop = false;\n\t\t\t\t\t\tfor (j = 0; j < parents.length; j++) {\n\t\t\t\t\t\t\taCircular = parents[j] === a[i];\n\t\t\t\t\t\t\tbCircular = parentsB[j] === b[i];\n\t\t\t\t\t\t\tif (aCircular || bCircular) {\n\t\t\t\t\t\t\t\tif (a[i] === b[i] || aCircular && bCircular) {\n\t\t\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\taProperties.push(i);\n\t\t\t\t\t\tif (!loop && !innerEquiv(a[i], b[i])) {\n\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tparents.pop();\n\t\t\t\t\tparentsB.pop();\n\n\t\t\t\t\t// Unstack, we are done\n\t\t\t\t\tcallers.pop();\n\n\t\t\t\t\tfor (i in meteorBabelHelpers.sanitizeForInObject(b)) {\n\n\t\t\t\t\t\t// Collect b's properties\n\t\t\t\t\t\tbProperties.push(i);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Ensures identical properties name\n\t\t\t\t\treturn eq && innerEquiv(aProperties.sort(), bProperties.sort());\n\t\t\t\t}\n\n\t\t\t\treturn object;\n\t\t\t}()\n\t\t};\n\n\t\tfunction typeEquiv(a, b) {\n\t\t\tvar prop = QUnit.objectType(a);\n\t\t\treturn callbacks[prop](b, a);\n\t\t}\n\n\t\t// The real equiv function\n\t\tfunction innerEquiv() {\n\t\t\tvar args = [].slice.apply(arguments);\n\t\t\tif (args.length < 2) {\n\n\t\t\t\t// End transition\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn function (a, b) {\n\t\t\t\tif (a === b) {\n\n\t\t\t\t\t// Catch the most you can\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (a === null || b === null || typeof a === \"undefined\" || typeof b === \"undefined\" || QUnit.objectType(a) !== QUnit.objectType(b)) {\n\n\t\t\t\t\t// Don't lose time with error prone cases\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\treturn typeEquiv(a, b);\n\t\t\t\t}\n\n\t\t\t\t// Apply transition with (1..n) arguments\n\t\t\t}(args[0], args[1]) && innerEquiv.apply(this, args.splice(1, args.length - 1));\n\t\t}\n\n\t\treturn innerEquiv;\n\t}();\n\n\t// Based on jsDump by Ariel Flesler\n\t// http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html\n\tQUnit.dump = function () {\n\t\tfunction quote(str) {\n\t\t\treturn \"\\\"\" + str.toString().replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, \"\\\\\\\"\") + \"\\\"\";\n\t\t}\n\t\tfunction literal(o) {\n\t\t\treturn o + \"\";\n\t\t}\n\t\tfunction join(pre, arr, post) {\n\t\t\tvar s = dump.separator(),\n\t\t\t    base = dump.indent(),\n\t\t\t    inner = dump.indent(1);\n\t\t\tif (arr.join) {\n\t\t\t\tarr = arr.join(\",\" + s + inner);\n\t\t\t}\n\t\t\tif (!arr) {\n\t\t\t\treturn pre + post;\n\t\t\t}\n\t\t\treturn [pre, inner + arr, base + post].join(s);\n\t\t}\n\t\tfunction array(arr, stack) {\n\t\t\tvar i = arr.length,\n\t\t\t    ret = new Array(i);\n\n\t\t\tif (dump.maxDepth && dump.depth > dump.maxDepth) {\n\t\t\t\treturn \"[object Array]\";\n\t\t\t}\n\n\t\t\tthis.up();\n\t\t\twhile (i--) {\n\t\t\t\tret[i] = this.parse(arr[i], undefined, stack);\n\t\t\t}\n\t\t\tthis.down();\n\t\t\treturn join(\"[\", ret, \"]\");\n\t\t}\n\n\t\tvar reName = /^function (\\w+)/,\n\t\t    dump = {\n\n\t\t\t// objType is used mostly internally, you can fix a (custom) type in advance\n\t\t\tparse: function () {\n\t\t\t\tfunction parse(obj, objType, stack) {\n\t\t\t\t\tstack = stack || [];\n\t\t\t\t\tvar res,\n\t\t\t\t\t    parser,\n\t\t\t\t\t    parserType,\n\t\t\t\t\t    inStack = inArray(obj, stack);\n\n\t\t\t\t\tif (inStack !== -1) {\n\t\t\t\t\t\treturn \"recursion(\" + (inStack - stack.length) + \")\";\n\t\t\t\t\t}\n\n\t\t\t\t\tobjType = objType || this.typeOf(obj);\n\t\t\t\t\tparser = this.parsers[objType];\n\t\t\t\t\tparserType = typeof parser === \"undefined\" ? \"undefined\" : _typeof(parser);\n\n\t\t\t\t\tif (parserType === \"function\") {\n\t\t\t\t\t\tstack.push(obj);\n\t\t\t\t\t\tres = parser.call(this, obj, stack);\n\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\treturn res;\n\t\t\t\t\t}\n\t\t\t\t\treturn parserType === \"string\" ? parser : this.parsers.error;\n\t\t\t\t}\n\n\t\t\t\treturn parse;\n\t\t\t}(),\n\t\t\ttypeOf: function () {\n\t\t\t\tfunction typeOf(obj) {\n\t\t\t\t\tvar type;\n\t\t\t\t\tif (obj === null) {\n\t\t\t\t\t\ttype = \"null\";\n\t\t\t\t\t} else if (typeof obj === \"undefined\") {\n\t\t\t\t\t\ttype = \"undefined\";\n\t\t\t\t\t} else if (QUnit.is(\"regexp\", obj)) {\n\t\t\t\t\t\ttype = \"regexp\";\n\t\t\t\t\t} else if (QUnit.is(\"date\", obj)) {\n\t\t\t\t\t\ttype = \"date\";\n\t\t\t\t\t} else if (QUnit.is(\"function\", obj)) {\n\t\t\t\t\t\ttype = \"function\";\n\t\t\t\t\t} else if (obj.setInterval !== undefined && obj.document !== undefined && obj.nodeType === undefined) {\n\t\t\t\t\t\ttype = \"window\";\n\t\t\t\t\t} else if (obj.nodeType === 9) {\n\t\t\t\t\t\ttype = \"document\";\n\t\t\t\t\t} else if (obj.nodeType) {\n\t\t\t\t\t\ttype = \"node\";\n\t\t\t\t\t} else if (\n\n\t\t\t\t\t// native arrays\n\t\t\t\t\ttoString.call(obj) === \"[object Array]\" ||\n\n\t\t\t\t\t// NodeList objects\n\t\t\t\t\ttypeof obj.length === \"number\" && obj.item !== undefined && (obj.length ? obj.item(0) === obj[0] : obj.item(0) === null && obj[0] === undefined)) {\n\t\t\t\t\t\ttype = \"array\";\n\t\t\t\t\t} else if (obj.constructor === Error.prototype.constructor) {\n\t\t\t\t\t\ttype = \"error\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttype = typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n\t\t\t\t\t}\n\t\t\t\t\treturn type;\n\t\t\t\t}\n\n\t\t\t\treturn typeOf;\n\t\t\t}(),\n\t\t\tseparator: function () {\n\t\t\t\tfunction separator() {\n\t\t\t\t\treturn this.multiline ? this.HTML ? \"<br />\" : \"\\n\" : this.HTML ? \"&#160;\" : \" \";\n\t\t\t\t}\n\n\t\t\t\treturn separator;\n\t\t\t}(),\n\t\t\t// extra can be a number, shortcut for increasing-calling-decreasing\n\t\t\tindent: function () {\n\t\t\t\tfunction indent(extra) {\n\t\t\t\t\tif (!this.multiline) {\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t}\n\t\t\t\t\tvar chr = this.indentChar;\n\t\t\t\t\tif (this.HTML) {\n\t\t\t\t\t\tchr = chr.replace(/\\t/g, \"   \").replace(/ /g, \"&#160;\");\n\t\t\t\t\t}\n\t\t\t\t\treturn new Array(this.depth + (extra || 0)).join(chr);\n\t\t\t\t}\n\n\t\t\t\treturn indent;\n\t\t\t}(),\n\t\t\tup: function () {\n\t\t\t\tfunction up(a) {\n\t\t\t\t\tthis.depth += a || 1;\n\t\t\t\t}\n\n\t\t\t\treturn up;\n\t\t\t}(),\n\t\t\tdown: function () {\n\t\t\t\tfunction down(a) {\n\t\t\t\t\tthis.depth -= a || 1;\n\t\t\t\t}\n\n\t\t\t\treturn down;\n\t\t\t}(),\n\t\t\tsetParser: function () {\n\t\t\t\tfunction setParser(name, parser) {\n\t\t\t\t\tthis.parsers[name] = parser;\n\t\t\t\t}\n\n\t\t\t\treturn setParser;\n\t\t\t}(),\n\t\t\t// The next 3 are exposed so you can use them\n\t\t\tquote: quote,\n\t\t\tliteral: literal,\n\t\t\tjoin: join,\n\t\t\t//\n\t\t\tdepth: 1,\n\t\t\tmaxDepth: QUnit.config.maxDepth,\n\n\t\t\t// This is the list of parsers, to modify them, use dump.setParser\n\t\t\tparsers: {\n\t\t\t\twindow: \"[Window]\",\n\t\t\t\tdocument: \"[Document]\",\n\t\t\t\terror: function () {\n\t\t\t\t\tfunction error(_error) {\n\t\t\t\t\t\treturn \"Error(\\\"\" + _error.message + \"\\\")\";\n\t\t\t\t\t}\n\n\t\t\t\t\treturn error;\n\t\t\t\t}(),\n\t\t\t\tunknown: \"[Unknown]\",\n\t\t\t\t\"null\": \"null\",\n\t\t\t\t\"undefined\": \"undefined\",\n\t\t\t\t\"function\": function () {\n\t\t\t\t\tfunction _function(fn) {\n\t\t\t\t\t\tvar ret = \"function\",\n\n\n\t\t\t\t\t\t// functions never have name in IE\n\t\t\t\t\t\tname = \"name\" in fn ? fn.name : (reName.exec(fn) || [])[1];\n\n\t\t\t\t\t\tif (name) {\n\t\t\t\t\t\t\tret += \" \" + name;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret += \"( \";\n\n\t\t\t\t\t\tret = [ret, dump.parse(fn, \"functionArgs\"), \"){\"].join(\"\");\n\t\t\t\t\t\treturn join(ret, dump.parse(fn, \"functionCode\"), \"}\");\n\t\t\t\t\t}\n\n\t\t\t\t\treturn _function;\n\t\t\t\t}(),\n\t\t\t\tarray: array,\n\t\t\t\tnodelist: array,\n\t\t\t\t\"arguments\": array,\n\t\t\t\tobject: function () {\n\t\t\t\t\tfunction object(map, stack) {\n\t\t\t\t\t\tvar keys,\n\t\t\t\t\t\t    key,\n\t\t\t\t\t\t    val,\n\t\t\t\t\t\t    i,\n\t\t\t\t\t\t    nonEnumerableProperties,\n\t\t\t\t\t\t    ret = [];\n\n\t\t\t\t\t\tif (dump.maxDepth && dump.depth > dump.maxDepth) {\n\t\t\t\t\t\t\treturn \"[object Object]\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdump.up();\n\t\t\t\t\t\tkeys = [];\n\t\t\t\t\t\tfor (key in meteorBabelHelpers.sanitizeForInObject(map)) {\n\t\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Some properties are not always enumerable on Error objects.\n\t\t\t\t\t\tnonEnumerableProperties = [\"message\", \"name\"];\n\t\t\t\t\t\tfor (i in meteorBabelHelpers.sanitizeForInObject(nonEnumerableProperties)) {\n\t\t\t\t\t\t\tkey = nonEnumerableProperties[i];\n\t\t\t\t\t\t\tif (key in map && inArray(key, keys) < 0) {\n\t\t\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tkeys.sort();\n\t\t\t\t\t\tfor (i = 0; i < keys.length; i++) {\n\t\t\t\t\t\t\tkey = keys[i];\n\t\t\t\t\t\t\tval = map[key];\n\t\t\t\t\t\t\tret.push(dump.parse(key, \"key\") + \": \" + dump.parse(val, undefined, stack));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdump.down();\n\t\t\t\t\t\treturn join(\"{\", ret, \"}\");\n\t\t\t\t\t}\n\n\t\t\t\t\treturn object;\n\t\t\t\t}(),\n\t\t\t\tnode: function () {\n\t\t\t\t\tfunction node(_node) {\n\t\t\t\t\t\tvar len,\n\t\t\t\t\t\t    i,\n\t\t\t\t\t\t    val,\n\t\t\t\t\t\t    open = dump.HTML ? \"&lt;\" : \"<\",\n\t\t\t\t\t\t    close = dump.HTML ? \"&gt;\" : \">\",\n\t\t\t\t\t\t    tag = _node.nodeName.toLowerCase(),\n\t\t\t\t\t\t    ret = open + tag,\n\t\t\t\t\t\t    attrs = _node.attributes;\n\n\t\t\t\t\t\tif (attrs) {\n\t\t\t\t\t\t\tfor (i = 0, len = attrs.length; i < len; i++) {\n\t\t\t\t\t\t\t\tval = attrs[i].nodeValue;\n\n\t\t\t\t\t\t\t\t// IE6 includes all attributes in .attributes, even ones not explicitly\n\t\t\t\t\t\t\t\t// set. Those have values like undefined, null, 0, false, \"\" or\n\t\t\t\t\t\t\t\t// \"inherit\".\n\t\t\t\t\t\t\t\tif (val && val !== \"inherit\") {\n\t\t\t\t\t\t\t\t\tret += \" \" + attrs[i].nodeName + \"=\" + dump.parse(val, \"attribute\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret += close;\n\n\t\t\t\t\t\t// Show content of TextNode or CDATASection\n\t\t\t\t\t\tif (_node.nodeType === 3 || _node.nodeType === 4) {\n\t\t\t\t\t\t\tret += _node.nodeValue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn ret + open + \"/\" + tag + close;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn node;\n\t\t\t\t}(),\n\n\t\t\t\t// function calls it internally, it's the arguments part of the function\n\t\t\t\tfunctionArgs: function () {\n\t\t\t\t\tfunction functionArgs(fn) {\n\t\t\t\t\t\tvar args,\n\t\t\t\t\t\t    l = fn.length;\n\n\t\t\t\t\t\tif (!l) {\n\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\targs = new Array(l);\n\t\t\t\t\t\twhile (l--) {\n\n\t\t\t\t\t\t\t// 97 is 'a'\n\t\t\t\t\t\t\targs[l] = String.fromCharCode(97 + l);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn \" \" + args.join(\", \") + \" \";\n\t\t\t\t\t}\n\n\t\t\t\t\treturn functionArgs;\n\t\t\t\t}(),\n\t\t\t\t// object calls it internally, the key part of an item in a map\n\t\t\t\tkey: quote,\n\t\t\t\t// function calls it internally, it's the content of the function\n\t\t\t\tfunctionCode: \"[code]\",\n\t\t\t\t// node calls it internally, it's an html attribute value\n\t\t\t\tattribute: quote,\n\t\t\t\tstring: quote,\n\t\t\t\tdate: quote,\n\t\t\t\tregexp: literal,\n\t\t\t\tnumber: literal,\n\t\t\t\t\"boolean\": literal\n\t\t\t},\n\t\t\t// if true, entities are escaped ( <, >, \\t, space and \\n )\n\t\t\tHTML: false,\n\t\t\t// indentation unit\n\t\t\tindentChar: \"  \",\n\t\t\t// if true, items in a collection, are separated by a \\n, else just a space.\n\t\t\tmultiline: true\n\t\t};\n\n\t\treturn dump;\n\t}();\n\n\t// back compat\n\tQUnit.jsDump = QUnit.dump;\n\n\t// For browser, export only select globals\n\tif (defined.document) {\n\n\t\t// Deprecated\n\t\t// Extend assert methods to QUnit and Global scope through Backwards compatibility\n\t\t(function () {\n\t\t\tvar i,\n\t\t\t    assertions = Assert.prototype;\n\n\t\t\tfunction applyCurrent(current) {\n\t\t\t\treturn function () {\n\t\t\t\t\tvar assert = new Assert(QUnit.config.current);\n\t\t\t\t\tcurrent.apply(assert, arguments);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tfor (i in meteorBabelHelpers.sanitizeForInObject(assertions)) {\n\t\t\t\tQUnit[i] = applyCurrent(assertions[i]);\n\t\t\t}\n\t\t})();\n\n\t\t(function () {\n\t\t\tvar i,\n\t\t\t    l,\n\t\t\t    keys = [\"test\", \"module\", \"expect\", \"asyncTest\", \"start\", \"stop\", \"ok\", \"notOk\", \"equal\", \"notEqual\", \"propEqual\", \"notPropEqual\", \"deepEqual\", \"notDeepEqual\", \"strictEqual\", \"notStrictEqual\", \"throws\", \"raises\"];\n\n\t\t\tfor (i = 0, l = keys.length; i < l; i++) {\n\t\t\t\twindow[keys[i]] = QUnit[keys[i]];\n\t\t\t}\n\t\t})();\n\n\t\twindow.QUnit = QUnit;\n\t}\n\n\t// For nodejs\n\tif (typeof module !== \"undefined\" && module && module.exports) {\n\t\tmodule.exports = QUnit;\n\n\t\t// For consistency with CommonJS environments' exports\n\t\tmodule.exports.QUnit = QUnit;\n\t}\n\n\t// For CommonJS with exports, but without module.exports, like Rhino\n\tif (typeof exports !== \"undefined\" && exports) {\n\t\texports.QUnit = QUnit;\n\t}\n\n\tif (typeof define === \"function\" && define.amd) {\n\t\tdefine(function () {\n\t\t\treturn QUnit;\n\t\t});\n\t\tQUnit.config.autostart = false;\n\t}\n\n\t/*\n  * This file is a modified version of google-diff-match-patch's JavaScript implementation\n  * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),\n  * modifications are licensed as more fully set forth in LICENSE.txt.\n  *\n  * The original source of google-diff-match-patch is attributable and licensed as follows:\n  *\n  * Copyright 2006 Google Inc.\n  * http://code.google.com/p/google-diff-match-patch/\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n  *\n  * http://www.apache.org/licenses/LICENSE-2.0\n  *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  *\n  * More Info:\n  *  https://code.google.com/p/google-diff-match-patch/\n  *\n  * Usage: QUnit.diff(expected, actual)\n  *\n  */\n\tQUnit.diff = function () {\n\t\tfunction DiffMatchPatch() {}\n\n\t\t//  DIFF FUNCTIONS\n\n\t\t/**\n   * The data structure representing a diff is an array of tuples:\n   * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n   * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n   */\n\t\tvar DIFF_DELETE = -1,\n\t\t    DIFF_INSERT = 1,\n\t\t    DIFF_EQUAL = 0;\n\n\t\t/**\n   * Find the differences between two texts.  Simplifies the problem by stripping\n   * any common prefix or suffix off the texts before diffing.\n   * @param {string} text1 Old string to be diffed.\n   * @param {string} text2 New string to be diffed.\n   * @param {boolean=} optChecklines Optional speedup flag. If present and false,\n   *     then don't run a line-level diff first to identify the changed areas.\n   *     Defaults to true, which does a faster, slightly less optimal diff.\n   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n   */\n\t\tDiffMatchPatch.prototype.DiffMain = function (text1, text2, optChecklines) {\n\t\t\tvar deadline, checklines, commonlength, commonprefix, commonsuffix, diffs;\n\n\t\t\t// The diff must be complete in up to 1 second.\n\t\t\tdeadline = new Date().getTime() + 1000;\n\n\t\t\t// Check for null inputs.\n\t\t\tif (text1 === null || text2 === null) {\n\t\t\t\tthrow new Error(\"Null input. (DiffMain)\");\n\t\t\t}\n\n\t\t\t// Check for equality (speedup).\n\t\t\tif (text1 === text2) {\n\t\t\t\tif (text1) {\n\t\t\t\t\treturn [[DIFF_EQUAL, text1]];\n\t\t\t\t}\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tif (typeof optChecklines === \"undefined\") {\n\t\t\t\toptChecklines = true;\n\t\t\t}\n\n\t\t\tchecklines = optChecklines;\n\n\t\t\t// Trim off common prefix (speedup).\n\t\t\tcommonlength = this.diffCommonPrefix(text1, text2);\n\t\t\tcommonprefix = text1.substring(0, commonlength);\n\t\t\ttext1 = text1.substring(commonlength);\n\t\t\ttext2 = text2.substring(commonlength);\n\n\t\t\t// Trim off common suffix (speedup).\n\t\t\tcommonlength = this.diffCommonSuffix(text1, text2);\n\t\t\tcommonsuffix = text1.substring(text1.length - commonlength);\n\t\t\ttext1 = text1.substring(0, text1.length - commonlength);\n\t\t\ttext2 = text2.substring(0, text2.length - commonlength);\n\n\t\t\t// Compute the diff on the middle block.\n\t\t\tdiffs = this.diffCompute(text1, text2, checklines, deadline);\n\n\t\t\t// Restore the prefix and suffix.\n\t\t\tif (commonprefix) {\n\t\t\t\tdiffs.unshift([DIFF_EQUAL, commonprefix]);\n\t\t\t}\n\t\t\tif (commonsuffix) {\n\t\t\t\tdiffs.push([DIFF_EQUAL, commonsuffix]);\n\t\t\t}\n\t\t\tthis.diffCleanupMerge(diffs);\n\t\t\treturn diffs;\n\t\t};\n\n\t\t/**\n   * Reduce the number of edits by eliminating operationally trivial equalities.\n   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n   */\n\t\tDiffMatchPatch.prototype.diffCleanupEfficiency = function (diffs) {\n\t\t\tvar changes, equalities, equalitiesLength, lastequality, pointer, preIns, preDel, postIns, postDel;\n\t\t\tchanges = false;\n\t\t\tequalities = []; // Stack of indices where equalities are found.\n\t\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t\t/** @type {?string} */\n\t\t\tlastequality = null;\n\t\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\t\tpointer = 0; // Index of current position.\n\t\t\t// Is there an insertion operation before the last equality.\n\t\t\tpreIns = false;\n\t\t\t// Is there a deletion operation before the last equality.\n\t\t\tpreDel = false;\n\t\t\t// Is there an insertion operation after the last equality.\n\t\t\tpostIns = false;\n\t\t\t// Is there a deletion operation after the last equality.\n\t\t\tpostDel = false;\n\t\t\twhile (pointer < diffs.length) {\n\n\t\t\t\t// Equality found.\n\t\t\t\tif (diffs[pointer][0] === DIFF_EQUAL) {\n\t\t\t\t\tif (diffs[pointer][1].length < 4 && (postIns || postDel)) {\n\n\t\t\t\t\t\t// Candidate found.\n\t\t\t\t\t\tequalities[equalitiesLength++] = pointer;\n\t\t\t\t\t\tpreIns = postIns;\n\t\t\t\t\t\tpreDel = postDel;\n\t\t\t\t\t\tlastequality = diffs[pointer][1];\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Not a candidate, and can never become one.\n\t\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\t\tlastequality = null;\n\t\t\t\t\t}\n\t\t\t\t\tpostIns = postDel = false;\n\n\t\t\t\t\t// An insertion or deletion.\n\t\t\t\t} else {\n\n\t\t\t\t\t\tif (diffs[pointer][0] === DIFF_DELETE) {\n\t\t\t\t\t\t\tpostDel = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpostIns = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/*\n       * Five types to be split:\n       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n       * <ins>A</ins>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<ins>C</ins>\n       * <ins>A</del>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<del>C</del>\n       */\n\t\t\t\t\t\tif (lastequality && (preIns && preDel && postIns && postDel || lastequality.length < 2 && preIns + preDel + postIns + postDel === 3)) {\n\n\t\t\t\t\t\t\t// Duplicate record.\n\t\t\t\t\t\t\tdiffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastequality]);\n\n\t\t\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\t\t\tdiffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n\t\t\t\t\t\t\tequalitiesLength--; // Throw away the equality we just deleted;\n\t\t\t\t\t\t\tlastequality = null;\n\t\t\t\t\t\t\tif (preIns && preDel) {\n\t\t\t\t\t\t\t\t// No changes made which could affect previous entry, keep going.\n\t\t\t\t\t\t\t\tpostIns = postDel = true;\n\t\t\t\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tequalitiesLength--; // Throw away the previous equality.\n\t\t\t\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n\t\t\t\t\t\t\t\tpostIns = postDel = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchanges = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\n\t\t\tif (changes) {\n\t\t\t\tthis.diffCleanupMerge(diffs);\n\t\t\t}\n\t\t};\n\n\t\t/**\n   * Convert a diff array into a pretty HTML report.\n   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n   * @param {integer} string to be beautified.\n   * @return {string} HTML representation.\n   */\n\t\tDiffMatchPatch.prototype.diffPrettyHtml = function (diffs) {\n\t\t\tvar op,\n\t\t\t    data,\n\t\t\t    x,\n\t\t\t    html = [];\n\t\t\tfor (x = 0; x < diffs.length; x++) {\n\t\t\t\top = diffs[x][0]; // Operation (insert, delete, equal)\n\t\t\t\tdata = diffs[x][1]; // Text of change.\n\t\t\t\tswitch (op) {\n\t\t\t\t\tcase DIFF_INSERT:\n\t\t\t\t\t\thtml[x] = \"<ins>\" + data + \"</ins>\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DIFF_DELETE:\n\t\t\t\t\t\thtml[x] = \"<del>\" + data + \"</del>\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DIFF_EQUAL:\n\t\t\t\t\t\thtml[x] = \"<span>\" + data + \"</span>\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn html.join(\"\");\n\t\t};\n\n\t\t/**\n   * Determine the common prefix of two strings.\n   * @param {string} text1 First string.\n   * @param {string} text2 Second string.\n   * @return {number} The number of characters common to the start of each\n   *     string.\n   */\n\t\tDiffMatchPatch.prototype.diffCommonPrefix = function (text1, text2) {\n\t\t\tvar pointermid, pointermax, pointermin, pointerstart;\n\t\t\t// Quick check for common null cases.\n\t\t\tif (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t// Binary search.\n\t\t\t// Performance analysis: http://neil.fraser.name/news/2007/10/09/\n\t\t\tpointermin = 0;\n\t\t\tpointermax = Math.min(text1.length, text2.length);\n\t\t\tpointermid = pointermax;\n\t\t\tpointerstart = 0;\n\t\t\twhile (pointermin < pointermid) {\n\t\t\t\tif (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {\n\t\t\t\t\tpointermin = pointermid;\n\t\t\t\t\tpointerstart = pointermin;\n\t\t\t\t} else {\n\t\t\t\t\tpointermax = pointermid;\n\t\t\t\t}\n\t\t\t\tpointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n\t\t\t}\n\t\t\treturn pointermid;\n\t\t};\n\n\t\t/**\n   * Determine the common suffix of two strings.\n   * @param {string} text1 First string.\n   * @param {string} text2 Second string.\n   * @return {number} The number of characters common to the end of each string.\n   */\n\t\tDiffMatchPatch.prototype.diffCommonSuffix = function (text1, text2) {\n\t\t\tvar pointermid, pointermax, pointermin, pointerend;\n\t\t\t// Quick check for common null cases.\n\t\t\tif (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t// Binary search.\n\t\t\t// Performance analysis: http://neil.fraser.name/news/2007/10/09/\n\t\t\tpointermin = 0;\n\t\t\tpointermax = Math.min(text1.length, text2.length);\n\t\t\tpointermid = pointermax;\n\t\t\tpointerend = 0;\n\t\t\twhile (pointermin < pointermid) {\n\t\t\t\tif (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n\t\t\t\t\tpointermin = pointermid;\n\t\t\t\t\tpointerend = pointermin;\n\t\t\t\t} else {\n\t\t\t\t\tpointermax = pointermid;\n\t\t\t\t}\n\t\t\t\tpointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n\t\t\t}\n\t\t\treturn pointermid;\n\t\t};\n\n\t\t/**\n   * Find the differences between two texts.  Assumes that the texts do not\n   * have any common prefix or suffix.\n   * @param {string} text1 Old string to be diffed.\n   * @param {string} text2 New string to be diffed.\n   * @param {boolean} checklines Speedup flag.  If false, then don't run a\n   *     line-level diff first to identify the changed areas.\n   *     If true, then run a faster, slightly less optimal diff.\n   * @param {number} deadline Time when the diff should be complete by.\n   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n   * @private\n   */\n\t\tDiffMatchPatch.prototype.diffCompute = function (text1, text2, checklines, deadline) {\n\t\t\tvar diffs, longtext, shorttext, i, hm, text1A, text2A, text1B, text2B, midCommon, diffsA, diffsB;\n\n\t\t\tif (!text1) {\n\t\t\t\t// Just add some text (speedup).\n\t\t\t\treturn [[DIFF_INSERT, text2]];\n\t\t\t}\n\n\t\t\tif (!text2) {\n\t\t\t\t// Just delete some text (speedup).\n\t\t\t\treturn [[DIFF_DELETE, text1]];\n\t\t\t}\n\n\t\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\t\ti = longtext.indexOf(shorttext);\n\t\t\tif (i !== -1) {\n\t\t\t\t// Shorter text is inside the longer text (speedup).\n\t\t\t\tdiffs = [[DIFF_INSERT, longtext.substring(0, i)], [DIFF_EQUAL, shorttext], [DIFF_INSERT, longtext.substring(i + shorttext.length)]];\n\t\t\t\t// Swap insertions for deletions if diff is reversed.\n\t\t\t\tif (text1.length > text2.length) {\n\t\t\t\t\tdiffs[0][0] = diffs[2][0] = DIFF_DELETE;\n\t\t\t\t}\n\t\t\t\treturn diffs;\n\t\t\t}\n\n\t\t\tif (shorttext.length === 1) {\n\t\t\t\t// Single character string.\n\t\t\t\t// After the previous speedup, the character can't be an equality.\n\t\t\t\treturn [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n\t\t\t}\n\n\t\t\t// Check to see if the problem can be split in two.\n\t\t\thm = this.diffHalfMatch(text1, text2);\n\t\t\tif (hm) {\n\t\t\t\t// A half-match was found, sort out the return data.\n\t\t\t\ttext1A = hm[0];\n\t\t\t\ttext1B = hm[1];\n\t\t\t\ttext2A = hm[2];\n\t\t\t\ttext2B = hm[3];\n\t\t\t\tmidCommon = hm[4];\n\t\t\t\t// Send both pairs off for separate processing.\n\t\t\t\tdiffsA = this.DiffMain(text1A, text2A, checklines, deadline);\n\t\t\t\tdiffsB = this.DiffMain(text1B, text2B, checklines, deadline);\n\t\t\t\t// Merge the results.\n\t\t\t\treturn diffsA.concat([[DIFF_EQUAL, midCommon]], diffsB);\n\t\t\t}\n\n\t\t\tif (checklines && text1.length > 100 && text2.length > 100) {\n\t\t\t\treturn this.diffLineMode(text1, text2, deadline);\n\t\t\t}\n\n\t\t\treturn this.diffBisect(text1, text2, deadline);\n\t\t};\n\n\t\t/**\n   * Do the two texts share a substring which is at least half the length of the\n   * longer text?\n   * This speedup can produce non-minimal diffs.\n   * @param {string} text1 First string.\n   * @param {string} text2 Second string.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     text1, the suffix of text1, the prefix of text2, the suffix of\n   *     text2 and the common middle.  Or null if there was no match.\n   * @private\n   */\n\t\tDiffMatchPatch.prototype.diffHalfMatch = function (text1, text2) {\n\t\t\tvar longtext, shorttext, dmp, text1A, text2B, text2A, text1B, midCommon, hm1, hm2, hm;\n\n\t\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\t\tif (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n\t\t\t\treturn null; // Pointless.\n\t\t\t}\n\t\t\tdmp = this; // 'this' becomes 'window' in a closure.\n\n\t\t\t/**\n    * Does a substring of shorttext exist within longtext such that the substring\n    * is at least half the length of longtext?\n    * Closure, but does not reference any external variables.\n    * @param {string} longtext Longer string.\n    * @param {string} shorttext Shorter string.\n    * @param {number} i Start index of quarter length substring within longtext.\n    * @return {Array.<string>} Five element Array, containing the prefix of\n    *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n    *     of shorttext and the common middle.  Or null if there was no match.\n    * @private\n    */\n\t\t\tfunction diffHalfMatchI(longtext, shorttext, i) {\n\t\t\t\tvar seed, j, bestCommon, prefixLength, suffixLength, bestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;\n\t\t\t\t// Start with a 1/4 length substring at position i as a seed.\n\t\t\t\tseed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n\t\t\t\tj = -1;\n\t\t\t\tbestCommon = \"\";\n\t\t\t\twhile ((j = shorttext.indexOf(seed, j + 1)) !== -1) {\n\t\t\t\t\tprefixLength = dmp.diffCommonPrefix(longtext.substring(i), shorttext.substring(j));\n\t\t\t\t\tsuffixLength = dmp.diffCommonSuffix(longtext.substring(0, i), shorttext.substring(0, j));\n\t\t\t\t\tif (bestCommon.length < suffixLength + prefixLength) {\n\t\t\t\t\t\tbestCommon = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);\n\t\t\t\t\t\tbestLongtextA = longtext.substring(0, i - suffixLength);\n\t\t\t\t\t\tbestLongtextB = longtext.substring(i + prefixLength);\n\t\t\t\t\t\tbestShorttextA = shorttext.substring(0, j - suffixLength);\n\t\t\t\t\t\tbestShorttextB = shorttext.substring(j + prefixLength);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (bestCommon.length * 2 >= longtext.length) {\n\t\t\t\t\treturn [bestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB, bestCommon];\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// First check if the second quarter is the seed for a half-match.\n\t\t\thm1 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 4));\n\t\t\t// Check again based on the third quarter.\n\t\t\thm2 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 2));\n\t\t\tif (!hm1 && !hm2) {\n\t\t\t\treturn null;\n\t\t\t} else if (!hm2) {\n\t\t\t\thm = hm1;\n\t\t\t} else if (!hm1) {\n\t\t\t\thm = hm2;\n\t\t\t} else {\n\t\t\t\t// Both matched.  Select the longest.\n\t\t\t\thm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n\t\t\t}\n\n\t\t\t// A half-match was found, sort out the return data.\n\t\t\ttext1A, text1B, text2A, text2B;\n\t\t\tif (text1.length > text2.length) {\n\t\t\t\ttext1A = hm[0];\n\t\t\t\ttext1B = hm[1];\n\t\t\t\ttext2A = hm[2];\n\t\t\t\ttext2B = hm[3];\n\t\t\t} else {\n\t\t\t\ttext2A = hm[0];\n\t\t\t\ttext2B = hm[1];\n\t\t\t\ttext1A = hm[2];\n\t\t\t\ttext1B = hm[3];\n\t\t\t}\n\t\t\tmidCommon = hm[4];\n\t\t\treturn [text1A, text1B, text2A, text2B, midCommon];\n\t\t};\n\n\t\t/**\n   * Do a quick line-level diff on both strings, then rediff the parts for\n   * greater accuracy.\n   * This speedup can produce non-minimal diffs.\n   * @param {string} text1 Old string to be diffed.\n   * @param {string} text2 New string to be diffed.\n   * @param {number} deadline Time when the diff should be complete by.\n   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n   * @private\n   */\n\t\tDiffMatchPatch.prototype.diffLineMode = function (text1, text2, deadline) {\n\t\t\tvar a, diffs, linearray, pointer, countInsert, countDelete, textInsert, textDelete, j;\n\t\t\t// Scan the text on a line-by-line basis first.\n\t\t\ta = this.diffLinesToChars(text1, text2);\n\t\t\ttext1 = a.chars1;\n\t\t\ttext2 = a.chars2;\n\t\t\tlinearray = a.lineArray;\n\n\t\t\tdiffs = this.DiffMain(text1, text2, false, deadline);\n\n\t\t\t// Convert the diff back to original text.\n\t\t\tthis.diffCharsToLines(diffs, linearray);\n\t\t\t// Eliminate freak matches (e.g. blank lines)\n\t\t\tthis.diffCleanupSemantic(diffs);\n\n\t\t\t// Rediff any replacement blocks, this time character-by-character.\n\t\t\t// Add a dummy entry at the end.\n\t\t\tdiffs.push([DIFF_EQUAL, \"\"]);\n\t\t\tpointer = 0;\n\t\t\tcountDelete = 0;\n\t\t\tcountInsert = 0;\n\t\t\ttextDelete = \"\";\n\t\t\ttextInsert = \"\";\n\t\t\twhile (pointer < diffs.length) {\n\t\t\t\tswitch (diffs[pointer][0]) {\n\t\t\t\t\tcase DIFF_INSERT:\n\t\t\t\t\t\tcountInsert++;\n\t\t\t\t\t\ttextInsert += diffs[pointer][1];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DIFF_DELETE:\n\t\t\t\t\t\tcountDelete++;\n\t\t\t\t\t\ttextDelete += diffs[pointer][1];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DIFF_EQUAL:\n\t\t\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\t\t\tif (countDelete >= 1 && countInsert >= 1) {\n\t\t\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\t\t\tdiffs.splice(pointer - countDelete - countInsert, countDelete + countInsert);\n\t\t\t\t\t\t\tpointer = pointer - countDelete - countInsert;\n\t\t\t\t\t\t\ta = this.DiffMain(textDelete, textInsert, false, deadline);\n\t\t\t\t\t\t\tfor (j = a.length - 1; j >= 0; j--) {\n\t\t\t\t\t\t\t\tdiffs.splice(pointer, 0, a[j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpointer = pointer + a.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcountInsert = 0;\n\t\t\t\t\t\tcountDelete = 0;\n\t\t\t\t\t\ttextDelete = \"\";\n\t\t\t\t\t\ttextInsert = \"\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\t\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\n\t\t\treturn diffs;\n\t\t};\n\n\t\t/**\n   * Find the 'middle snake' of a diff, split the problem in two\n   * and return the recursively constructed diff.\n   * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n   * @param {string} text1 Old string to be diffed.\n   * @param {string} text2 New string to be diffed.\n   * @param {number} deadline Time at which to bail if not yet complete.\n   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n   * @private\n   */\n\t\tDiffMatchPatch.prototype.diffBisect = function (text1, text2, deadline) {\n\t\t\tvar text1Length, text2Length, maxD, vOffset, vLength, v1, v2, x, delta, front, k1start, k1end, k2start, k2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;\n\t\t\t// Cache the text lengths to prevent multiple calls.\n\t\t\ttext1Length = text1.length;\n\t\t\ttext2Length = text2.length;\n\t\t\tmaxD = Math.ceil((text1Length + text2Length) / 2);\n\t\t\tvOffset = maxD;\n\t\t\tvLength = 2 * maxD;\n\t\t\tv1 = new Array(vLength);\n\t\t\tv2 = new Array(vLength);\n\t\t\t// Setting all elements to -1 is faster in Chrome & Firefox than mixing\n\t\t\t// integers and undefined.\n\t\t\tfor (x = 0; x < vLength; x++) {\n\t\t\t\tv1[x] = -1;\n\t\t\t\tv2[x] = -1;\n\t\t\t}\n\t\t\tv1[vOffset + 1] = 0;\n\t\t\tv2[vOffset + 1] = 0;\n\t\t\tdelta = text1Length - text2Length;\n\t\t\t// If the total number of characters is odd, then the front path will collide\n\t\t\t// with the reverse path.\n\t\t\tfront = delta % 2 !== 0;\n\t\t\t// Offsets for start and end of k loop.\n\t\t\t// Prevents mapping of space beyond the grid.\n\t\t\tk1start = 0;\n\t\t\tk1end = 0;\n\t\t\tk2start = 0;\n\t\t\tk2end = 0;\n\t\t\tfor (d = 0; d < maxD; d++) {\n\t\t\t\t// Bail out if deadline is reached.\n\t\t\t\tif (new Date().getTime() > deadline) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Walk the front path one step.\n\t\t\t\tfor (k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n\t\t\t\t\tk1Offset = vOffset + k1;\n\t\t\t\t\tif (k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1]) {\n\t\t\t\t\t\tx1 = v1[k1Offset + 1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx1 = v1[k1Offset - 1] + 1;\n\t\t\t\t\t}\n\t\t\t\t\ty1 = x1 - k1;\n\t\t\t\t\twhile (x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1)) {\n\t\t\t\t\t\tx1++;\n\t\t\t\t\t\ty1++;\n\t\t\t\t\t}\n\t\t\t\t\tv1[k1Offset] = x1;\n\t\t\t\t\tif (x1 > text1Length) {\n\t\t\t\t\t\t// Ran off the right of the graph.\n\t\t\t\t\t\tk1end += 2;\n\t\t\t\t\t} else if (y1 > text2Length) {\n\t\t\t\t\t\t// Ran off the bottom of the graph.\n\t\t\t\t\t\tk1start += 2;\n\t\t\t\t\t} else if (front) {\n\t\t\t\t\t\tk2Offset = vOffset + delta - k1;\n\t\t\t\t\t\tif (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {\n\t\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\t\tx2 = text1Length - v2[k2Offset];\n\t\t\t\t\t\t\tif (x1 >= x2) {\n\t\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\t\treturn this.diffBisectSplit(text1, text2, x1, y1, deadline);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Walk the reverse path one step.\n\t\t\t\tfor (k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n\t\t\t\t\tk2Offset = vOffset + k2;\n\t\t\t\t\tif (k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1]) {\n\t\t\t\t\t\tx2 = v2[k2Offset + 1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx2 = v2[k2Offset - 1] + 1;\n\t\t\t\t\t}\n\t\t\t\t\ty2 = x2 - k2;\n\t\t\t\t\twhile (x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1)) {\n\t\t\t\t\t\tx2++;\n\t\t\t\t\t\ty2++;\n\t\t\t\t\t}\n\t\t\t\t\tv2[k2Offset] = x2;\n\t\t\t\t\tif (x2 > text1Length) {\n\t\t\t\t\t\t// Ran off the left of the graph.\n\t\t\t\t\t\tk2end += 2;\n\t\t\t\t\t} else if (y2 > text2Length) {\n\t\t\t\t\t\t// Ran off the top of the graph.\n\t\t\t\t\t\tk2start += 2;\n\t\t\t\t\t} else if (!front) {\n\t\t\t\t\t\tk1Offset = vOffset + delta - k2;\n\t\t\t\t\t\tif (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {\n\t\t\t\t\t\t\tx1 = v1[k1Offset];\n\t\t\t\t\t\t\ty1 = vOffset + x1 - k1Offset;\n\t\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\t\tx2 = text1Length - x2;\n\t\t\t\t\t\t\tif (x1 >= x2) {\n\t\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\t\treturn this.diffBisectSplit(text1, text2, x1, y1, deadline);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Diff took too long and hit the deadline or\n\t\t\t// number of diffs equals number of characters, no commonality at all.\n\t\t\treturn [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n\t\t};\n\n\t\t/**\n   * Given the location of the 'middle snake', split the diff in two parts\n   * and recurse.\n   * @param {string} text1 Old string to be diffed.\n   * @param {string} text2 New string to be diffed.\n   * @param {number} x Index of split point in text1.\n   * @param {number} y Index of split point in text2.\n   * @param {number} deadline Time at which to bail if not yet complete.\n   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n   * @private\n   */\n\t\tDiffMatchPatch.prototype.diffBisectSplit = function (text1, text2, x, y, deadline) {\n\t\t\tvar text1a, text1b, text2a, text2b, diffs, diffsb;\n\t\t\ttext1a = text1.substring(0, x);\n\t\t\ttext2a = text2.substring(0, y);\n\t\t\ttext1b = text1.substring(x);\n\t\t\ttext2b = text2.substring(y);\n\n\t\t\t// Compute both diffs serially.\n\t\t\tdiffs = this.DiffMain(text1a, text2a, false, deadline);\n\t\t\tdiffsb = this.DiffMain(text1b, text2b, false, deadline);\n\n\t\t\treturn diffs.concat(diffsb);\n\t\t};\n\n\t\t/**\n   * Reduce the number of edits by eliminating semantically trivial equalities.\n   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n   */\n\t\tDiffMatchPatch.prototype.diffCleanupSemantic = function (diffs) {\n\t\t\tvar changes, equalities, equalitiesLength, lastequality, pointer, lengthInsertions2, lengthDeletions2, lengthInsertions1, lengthDeletions1, deletion, insertion, overlapLength1, overlapLength2;\n\t\t\tchanges = false;\n\t\t\tequalities = []; // Stack of indices where equalities are found.\n\t\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t\t/** @type {?string} */\n\t\t\tlastequality = null;\n\t\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\t\tpointer = 0; // Index of current position.\n\t\t\t// Number of characters that changed prior to the equality.\n\t\t\tlengthInsertions1 = 0;\n\t\t\tlengthDeletions1 = 0;\n\t\t\t// Number of characters that changed after the equality.\n\t\t\tlengthInsertions2 = 0;\n\t\t\tlengthDeletions2 = 0;\n\t\t\twhile (pointer < diffs.length) {\n\t\t\t\tif (diffs[pointer][0] === DIFF_EQUAL) {\n\t\t\t\t\t// Equality found.\n\t\t\t\t\tequalities[equalitiesLength++] = pointer;\n\t\t\t\t\tlengthInsertions1 = lengthInsertions2;\n\t\t\t\t\tlengthDeletions1 = lengthDeletions2;\n\t\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\t\tlastequality = diffs[pointer][1];\n\t\t\t\t} else {\n\t\t\t\t\t// An insertion or deletion.\n\t\t\t\t\tif (diffs[pointer][0] === DIFF_INSERT) {\n\t\t\t\t\t\tlengthInsertions2 += diffs[pointer][1].length;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlengthDeletions2 += diffs[pointer][1].length;\n\t\t\t\t\t}\n\t\t\t\t\t// Eliminate an equality that is smaller or equal to the edits on both\n\t\t\t\t\t// sides of it.\n\t\t\t\t\tif (lastequality && lastequality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastequality.length <= Math.max(lengthInsertions2, lengthDeletions2)) {\n\n\t\t\t\t\t\t// Duplicate record.\n\t\t\t\t\t\tdiffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastequality]);\n\n\t\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\t\tdiffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n\n\t\t\t\t\t\t// Throw away the equality we just deleted.\n\t\t\t\t\t\tequalitiesLength--;\n\n\t\t\t\t\t\t// Throw away the previous equality (it needs to be reevaluated).\n\t\t\t\t\t\tequalitiesLength--;\n\t\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n\n\t\t\t\t\t\t// Reset the counters.\n\t\t\t\t\t\tlengthInsertions1 = 0;\n\t\t\t\t\t\tlengthDeletions1 = 0;\n\t\t\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\t\t\tlastequality = null;\n\t\t\t\t\t\tchanges = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\n\t\t\t// Normalize the diff.\n\t\t\tif (changes) {\n\t\t\t\tthis.diffCleanupMerge(diffs);\n\t\t\t}\n\n\t\t\t// Find any overlaps between deletions and insertions.\n\t\t\t// e.g: <del>abcxxx</del><ins>xxxdef</ins>\n\t\t\t//   -> <del>abc</del>xxx<ins>def</ins>\n\t\t\t// e.g: <del>xxxabc</del><ins>defxxx</ins>\n\t\t\t//   -> <ins>def</ins>xxx<del>abc</del>\n\t\t\t// Only extract an overlap if it is as big as the edit ahead or behind it.\n\t\t\tpointer = 1;\n\t\t\twhile (pointer < diffs.length) {\n\t\t\t\tif (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {\n\t\t\t\t\tdeletion = diffs[pointer - 1][1];\n\t\t\t\t\tinsertion = diffs[pointer][1];\n\t\t\t\t\toverlapLength1 = this.diffCommonOverlap(deletion, insertion);\n\t\t\t\t\toverlapLength2 = this.diffCommonOverlap(insertion, deletion);\n\t\t\t\t\tif (overlapLength1 >= overlapLength2) {\n\t\t\t\t\t\tif (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) {\n\t\t\t\t\t\t\t// Overlap found.  Insert an equality and trim the surrounding edits.\n\t\t\t\t\t\t\tdiffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlapLength1)]);\n\t\t\t\t\t\t\tdiffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1);\n\t\t\t\t\t\t\tdiffs[pointer + 1][1] = insertion.substring(overlapLength1);\n\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) {\n\n\t\t\t\t\t\t\t// Reverse overlap found.\n\t\t\t\t\t\t\t// Insert an equality and swap and trim the surrounding edits.\n\t\t\t\t\t\t\tdiffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlapLength2)]);\n\n\t\t\t\t\t\t\tdiffs[pointer - 1][0] = DIFF_INSERT;\n\t\t\t\t\t\t\tdiffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2);\n\t\t\t\t\t\t\tdiffs[pointer + 1][0] = DIFF_DELETE;\n\t\t\t\t\t\t\tdiffs[pointer + 1][1] = deletion.substring(overlapLength2);\n\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpointer++;\n\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\t\t};\n\n\t\t/**\n   * Determine if the suffix of one string is the prefix of another.\n   * @param {string} text1 First string.\n   * @param {string} text2 Second string.\n   * @return {number} The number of characters common to the end of the first\n   *     string and the start of the second string.\n   * @private\n   */\n\t\tDiffMatchPatch.prototype.diffCommonOverlap = function (text1, text2) {\n\t\t\tvar text1Length, text2Length, textLength, best, length, pattern, found;\n\t\t\t// Cache the text lengths to prevent multiple calls.\n\t\t\ttext1Length = text1.length;\n\t\t\ttext2Length = text2.length;\n\t\t\t// Eliminate the null case.\n\t\t\tif (text1Length === 0 || text2Length === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t// Truncate the longer string.\n\t\t\tif (text1Length > text2Length) {\n\t\t\t\ttext1 = text1.substring(text1Length - text2Length);\n\t\t\t} else if (text1Length < text2Length) {\n\t\t\t\ttext2 = text2.substring(0, text1Length);\n\t\t\t}\n\t\t\ttextLength = Math.min(text1Length, text2Length);\n\t\t\t// Quick check for the worst case.\n\t\t\tif (text1 === text2) {\n\t\t\t\treturn textLength;\n\t\t\t}\n\n\t\t\t// Start by looking for a single character match\n\t\t\t// and increase length until no match is found.\n\t\t\t// Performance analysis: http://neil.fraser.name/news/2010/11/04/\n\t\t\tbest = 0;\n\t\t\tlength = 1;\n\t\t\twhile (true) {\n\t\t\t\tpattern = text1.substring(textLength - length);\n\t\t\t\tfound = text2.indexOf(pattern);\n\t\t\t\tif (found === -1) {\n\t\t\t\t\treturn best;\n\t\t\t\t}\n\t\t\t\tlength += found;\n\t\t\t\tif (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) {\n\t\t\t\t\tbest = length;\n\t\t\t\t\tlength++;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n   * Split two texts into an array of strings.  Reduce the texts to a string of\n   * hashes where each Unicode character represents one line.\n   * @param {string} text1 First string.\n   * @param {string} text2 Second string.\n   * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n   *     An object containing the encoded text1, the encoded text2 and\n   *     the array of unique strings.\n   *     The zeroth element of the array of unique strings is intentionally blank.\n   * @private\n   */\n\t\tDiffMatchPatch.prototype.diffLinesToChars = function (text1, text2) {\n\t\t\tvar lineArray, lineHash, chars1, chars2;\n\t\t\tlineArray = []; // e.g. lineArray[4] === 'Hello\\n'\n\t\t\tlineHash = {}; // e.g. lineHash['Hello\\n'] === 4\n\n\t\t\t// '\\x00' is a valid character, but various debuggers don't like it.\n\t\t\t// So we'll insert a junk entry to avoid generating a null character.\n\t\t\tlineArray[0] = \"\";\n\n\t\t\t/**\n    * Split a text into an array of strings.  Reduce the texts to a string of\n    * hashes where each Unicode character represents one line.\n    * Modifies linearray and linehash through being a closure.\n    * @param {string} text String to encode.\n    * @return {string} Encoded string.\n    * @private\n    */\n\t\t\tfunction diffLinesToCharsMunge(text) {\n\t\t\t\tvar chars, lineStart, lineEnd, lineArrayLength, line;\n\t\t\t\tchars = \"\";\n\t\t\t\t// Walk the text, pulling out a substring for each line.\n\t\t\t\t// text.split('\\n') would would temporarily double our memory footprint.\n\t\t\t\t// Modifying text would create many large strings to garbage collect.\n\t\t\t\tlineStart = 0;\n\t\t\t\tlineEnd = -1;\n\t\t\t\t// Keeping our own length variable is faster than looking it up.\n\t\t\t\tlineArrayLength = lineArray.length;\n\t\t\t\twhile (lineEnd < text.length - 1) {\n\t\t\t\t\tlineEnd = text.indexOf(\"\\n\", lineStart);\n\t\t\t\t\tif (lineEnd === -1) {\n\t\t\t\t\t\tlineEnd = text.length - 1;\n\t\t\t\t\t}\n\t\t\t\t\tline = text.substring(lineStart, lineEnd + 1);\n\t\t\t\t\tlineStart = lineEnd + 1;\n\n\t\t\t\t\tif (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== undefined) {\n\t\t\t\t\t\tchars += String.fromCharCode(lineHash[line]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchars += String.fromCharCode(lineArrayLength);\n\t\t\t\t\t\tlineHash[line] = lineArrayLength;\n\t\t\t\t\t\tlineArray[lineArrayLength++] = line;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn chars;\n\t\t\t}\n\n\t\t\tchars1 = diffLinesToCharsMunge(text1);\n\t\t\tchars2 = diffLinesToCharsMunge(text2);\n\t\t\treturn {\n\t\t\t\tchars1: chars1,\n\t\t\t\tchars2: chars2,\n\t\t\t\tlineArray: lineArray\n\t\t\t};\n\t\t};\n\n\t\t/**\n   * Rehydrate the text in a diff from a string of line hashes to real lines of\n   * text.\n   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n   * @param {!Array.<string>} lineArray Array of unique strings.\n   * @private\n   */\n\t\tDiffMatchPatch.prototype.diffCharsToLines = function (diffs, lineArray) {\n\t\t\tvar x, chars, text, y;\n\t\t\tfor (x = 0; x < diffs.length; x++) {\n\t\t\t\tchars = diffs[x][1];\n\t\t\t\ttext = [];\n\t\t\t\tfor (y = 0; y < chars.length; y++) {\n\t\t\t\t\ttext[y] = lineArray[chars.charCodeAt(y)];\n\t\t\t\t}\n\t\t\t\tdiffs[x][1] = text.join(\"\");\n\t\t\t}\n\t\t};\n\n\t\t/**\n   * Reorder and merge like edit sections.  Merge equalities.\n   * Any edit section can move as long as it doesn't cross an equality.\n   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n   */\n\t\tDiffMatchPatch.prototype.diffCleanupMerge = function (diffs) {\n\t\t\tvar pointer, countDelete, countInsert, textInsert, textDelete, commonlength, changes, diffPointer, position;\n\t\t\tdiffs.push([DIFF_EQUAL, \"\"]); // Add a dummy entry at the end.\n\t\t\tpointer = 0;\n\t\t\tcountDelete = 0;\n\t\t\tcountInsert = 0;\n\t\t\ttextDelete = \"\";\n\t\t\ttextInsert = \"\";\n\t\t\tcommonlength;\n\t\t\twhile (pointer < diffs.length) {\n\t\t\t\tswitch (diffs[pointer][0]) {\n\t\t\t\t\tcase DIFF_INSERT:\n\t\t\t\t\t\tcountInsert++;\n\t\t\t\t\t\ttextInsert += diffs[pointer][1];\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DIFF_DELETE:\n\t\t\t\t\t\tcountDelete++;\n\t\t\t\t\t\ttextDelete += diffs[pointer][1];\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DIFF_EQUAL:\n\t\t\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\t\t\tif (countDelete + countInsert > 1) {\n\t\t\t\t\t\t\tif (countDelete !== 0 && countInsert !== 0) {\n\t\t\t\t\t\t\t\t// Factor out any common prefixies.\n\t\t\t\t\t\t\t\tcommonlength = this.diffCommonPrefix(textInsert, textDelete);\n\t\t\t\t\t\t\t\tif (commonlength !== 0) {\n\t\t\t\t\t\t\t\t\tif (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL) {\n\t\t\t\t\t\t\t\t\t\tdiffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tdiffs.splice(0, 0, [DIFF_EQUAL, textInsert.substring(0, commonlength)]);\n\t\t\t\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\ttextInsert = textInsert.substring(commonlength);\n\t\t\t\t\t\t\t\t\ttextDelete = textDelete.substring(commonlength);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Factor out any common suffixies.\n\t\t\t\t\t\t\t\tcommonlength = this.diffCommonSuffix(textInsert, textDelete);\n\t\t\t\t\t\t\t\tif (commonlength !== 0) {\n\t\t\t\t\t\t\t\t\tdiffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1];\n\t\t\t\t\t\t\t\t\ttextInsert = textInsert.substring(0, textInsert.length - commonlength);\n\t\t\t\t\t\t\t\t\ttextDelete = textDelete.substring(0, textDelete.length - commonlength);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\t\t\tif (countDelete === 0) {\n\t\t\t\t\t\t\t\tdiffs.splice(pointer - countInsert, countDelete + countInsert, [DIFF_INSERT, textInsert]);\n\t\t\t\t\t\t\t} else if (countInsert === 0) {\n\t\t\t\t\t\t\t\tdiffs.splice(pointer - countDelete, countDelete + countInsert, [DIFF_DELETE, textDelete]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdiffs.splice(pointer - countDelete - countInsert, countDelete + countInsert, [DIFF_DELETE, textDelete], [DIFF_INSERT, textInsert]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpointer = pointer - countDelete - countInsert + (countDelete ? 1 : 0) + (countInsert ? 1 : 0) + 1;\n\t\t\t\t\t\t} else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {\n\n\t\t\t\t\t\t\t// Merge this equality with the previous one.\n\t\t\t\t\t\t\tdiffs[pointer - 1][1] += diffs[pointer][1];\n\t\t\t\t\t\t\tdiffs.splice(pointer, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcountInsert = 0;\n\t\t\t\t\t\tcountDelete = 0;\n\t\t\t\t\t\ttextDelete = \"\";\n\t\t\t\t\t\ttextInsert = \"\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (diffs[diffs.length - 1][1] === \"\") {\n\t\t\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\t\t\t}\n\n\t\t\t// Second pass: look for single edits surrounded on both sides by equalities\n\t\t\t// which can be shifted sideways to eliminate an equality.\n\t\t\t// e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n\t\t\tchanges = false;\n\t\t\tpointer = 1;\n\n\t\t\t// Intentionally ignore the first and last element (don't need checking).\n\t\t\twhile (pointer < diffs.length - 1) {\n\t\t\t\tif (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n\n\t\t\t\t\tdiffPointer = diffs[pointer][1];\n\t\t\t\t\tposition = diffPointer.substring(diffPointer.length - diffs[pointer - 1][1].length);\n\n\t\t\t\t\t// This is a single edit surrounded by equalities.\n\t\t\t\t\tif (position === diffs[pointer - 1][1]) {\n\n\t\t\t\t\t\t// Shift the edit over the previous equality.\n\t\t\t\t\t\tdiffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);\n\t\t\t\t\t\tdiffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n\t\t\t\t\t\tdiffs.splice(pointer - 1, 1);\n\t\t\t\t\t\tchanges = true;\n\t\t\t\t\t} else if (diffPointer.substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {\n\n\t\t\t\t\t\t// Shift the edit over the next equality.\n\t\t\t\t\t\tdiffs[pointer - 1][1] += diffs[pointer + 1][1];\n\t\t\t\t\t\tdiffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];\n\t\t\t\t\t\tdiffs.splice(pointer + 1, 1);\n\t\t\t\t\t\tchanges = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\t\t\t// If shifts were made, the diff needs reordering and another shift sweep.\n\t\t\tif (changes) {\n\t\t\t\tthis.diffCleanupMerge(diffs);\n\t\t\t}\n\t\t};\n\n\t\treturn function (o, n) {\n\t\t\tvar diff, output, text;\n\t\t\tdiff = new DiffMatchPatch();\n\t\t\toutput = diff.DiffMain(o, n);\n\t\t\tdiff.diffCleanupEfficiency(output);\n\t\t\ttext = diff.diffPrettyHtml(output);\n\n\t\t\treturn text;\n\t\t};\n\t}();\n\n\t// Get a reference to the global object, like window in browsers\n})(function () {\n\treturn this;\n}());\n\n(function () {\n\n\t// Don't load the HTML Reporter on non-Browser environments\n\tif (typeof window === \"undefined\" || !window.document) {\n\t\treturn;\n\t}\n\n\t// Deprecated QUnit.init - Ref #530\n\t// Re-initialize the configuration options\n\tQUnit.init = function () {\n\t\tvar tests,\n\t\t    banner,\n\t\t    result,\n\t\t    qunit,\n\t\t    config = QUnit.config;\n\n\t\tconfig.stats = { all: 0, bad: 0 };\n\t\tconfig.moduleStats = { all: 0, bad: 0 };\n\t\tconfig.started = 0;\n\t\tconfig.updateRate = 1000;\n\t\tconfig.blocking = false;\n\t\tconfig.autostart = true;\n\t\tconfig.autorun = false;\n\t\tconfig.filter = \"\";\n\t\tconfig.queue = [];\n\n\t\t// Return on non-browser environments\n\t\t// This is necessary to not break on node tests\n\t\tif (typeof window === \"undefined\") {\n\t\t\treturn;\n\t\t}\n\n\t\tqunit = id(\"qunit\");\n\t\tif (qunit) {\n\t\t\tqunit.innerHTML = \"<h1 id='qunit-header'>\" + escapeText(document.title) + \"</h1>\" + \"<h2 id='qunit-banner'></h2>\" + \"<div id='qunit-testrunner-toolbar'></div>\" + \"<h2 id='qunit-userAgent'></h2>\" + \"<ol id='qunit-tests'></ol>\";\n\t\t}\n\n\t\ttests = id(\"qunit-tests\");\n\t\tbanner = id(\"qunit-banner\");\n\t\tresult = id(\"qunit-testresult\");\n\n\t\tif (tests) {\n\t\t\ttests.innerHTML = \"\";\n\t\t}\n\n\t\tif (banner) {\n\t\t\tbanner.className = \"\";\n\t\t}\n\n\t\tif (result) {\n\t\t\tresult.parentNode.removeChild(result);\n\t\t}\n\n\t\tif (tests) {\n\t\t\tresult = document.createElement(\"p\");\n\t\t\tresult.id = \"qunit-testresult\";\n\t\t\tresult.className = \"result\";\n\t\t\ttests.parentNode.insertBefore(result, tests);\n\t\t\tresult.innerHTML = \"Running...<br />&#160;\";\n\t\t}\n\t};\n\n\tvar config = QUnit.config,\n\t    collapseNext = false,\n\t    hasOwn = Object.prototype.hasOwnProperty,\n\t    defined = {\n\t\tdocument: window.document !== undefined,\n\t\tsessionStorage: function () {\n\t\t\tvar x = \"qunit-test-string\";\n\t\t\ttry {\n\t\t\t\tsessionStorage.setItem(x, x);\n\t\t\t\tsessionStorage.removeItem(x);\n\t\t\t\treturn true;\n\t\t\t} catch (e) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}()\n\t},\n\t    modulesList = [];\n\n\t/**\n * Escape text for attribute or text content.\n */\n\tfunction escapeText(s) {\n\t\tif (!s) {\n\t\t\treturn \"\";\n\t\t}\n\t\ts = s + \"\";\n\n\t\t// Both single quotes and double quotes (for attributes)\n\t\treturn s.replace(/['\"<>&]/g, function (s) {\n\t\t\tswitch (s) {\n\t\t\t\tcase \"'\":\n\t\t\t\t\treturn \"&#039;\";\n\t\t\t\tcase \"\\\"\":\n\t\t\t\t\treturn \"&quot;\";\n\t\t\t\tcase \"<\":\n\t\t\t\t\treturn \"&lt;\";\n\t\t\t\tcase \">\":\n\t\t\t\t\treturn \"&gt;\";\n\t\t\t\tcase \"&\":\n\t\t\t\t\treturn \"&amp;\";\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n  * @param {HTMLElement} elem\n  * @param {string} type\n  * @param {Function} fn\n  */\n\tfunction addEvent(elem, type, fn) {\n\t\tif (elem.addEventListener) {\n\n\t\t\t// Standards-based browsers\n\t\t\telem.addEventListener(type, fn, false);\n\t\t} else if (elem.attachEvent) {\n\n\t\t\t// support: IE <9\n\t\t\telem.attachEvent(\"on\" + type, function () {\n\t\t\t\tvar event = window.event;\n\t\t\t\tif (!event.target) {\n\t\t\t\t\tevent.target = event.srcElement || document;\n\t\t\t\t}\n\n\t\t\t\tfn.call(elem, event);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n  * @param {Array|NodeList} elems\n  * @param {string} type\n  * @param {Function} fn\n  */\n\tfunction addEvents(elems, type, fn) {\n\t\tvar i = elems.length;\n\t\twhile (i--) {\n\t\t\taddEvent(elems[i], type, fn);\n\t\t}\n\t}\n\n\tfunction hasClass(elem, name) {\n\t\treturn (\" \" + elem.className + \" \").indexOf(\" \" + name + \" \") >= 0;\n\t}\n\n\tfunction addClass(elem, name) {\n\t\tif (!hasClass(elem, name)) {\n\t\t\telem.className += (elem.className ? \" \" : \"\") + name;\n\t\t}\n\t}\n\n\tfunction toggleClass(elem, name) {\n\t\tif (hasClass(elem, name)) {\n\t\t\tremoveClass(elem, name);\n\t\t} else {\n\t\t\taddClass(elem, name);\n\t\t}\n\t}\n\n\tfunction removeClass(elem, name) {\n\t\tvar set = \" \" + elem.className + \" \";\n\n\t\t// Class name may appear multiple times\n\t\twhile (set.indexOf(\" \" + name + \" \") >= 0) {\n\t\t\tset = set.replace(\" \" + name + \" \", \" \");\n\t\t}\n\n\t\t// trim for prettiness\n\t\telem.className = typeof set.trim === \"function\" ? set.trim() : set.replace(/^\\s+|\\s+$/g, \"\");\n\t}\n\n\tfunction id(name) {\n\t\treturn defined.document && document.getElementById && document.getElementById(name);\n\t}\n\n\tfunction getUrlConfigHtml() {\n\t\tvar i,\n\t\t    j,\n\t\t    val,\n\t\t    escaped,\n\t\t    escapedTooltip,\n\t\t    selection = false,\n\t\t    len = config.urlConfig.length,\n\t\t    urlConfigHtml = \"\";\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tval = config.urlConfig[i];\n\t\t\tif (typeof val === \"string\") {\n\t\t\t\tval = {\n\t\t\t\t\tid: val,\n\t\t\t\t\tlabel: val\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tescaped = escapeText(val.id);\n\t\t\tescapedTooltip = escapeText(val.tooltip);\n\n\t\t\tif (config[val.id] === undefined) {\n\t\t\t\tconfig[val.id] = QUnit.urlParams[val.id];\n\t\t\t}\n\n\t\t\tif (!val.value || typeof val.value === \"string\") {\n\t\t\t\turlConfigHtml += \"<input id='qunit-urlconfig-\" + escaped + \"' name='\" + escaped + \"' type='checkbox'\" + (val.value ? \" value='\" + escapeText(val.value) + \"'\" : \"\") + (config[val.id] ? \" checked='checked'\" : \"\") + \" title='\" + escapedTooltip + \"' /><label for='qunit-urlconfig-\" + escaped + \"' title='\" + escapedTooltip + \"'>\" + val.label + \"</label>\";\n\t\t\t} else {\n\t\t\t\turlConfigHtml += \"<label for='qunit-urlconfig-\" + escaped + \"' title='\" + escapedTooltip + \"'>\" + val.label + \": </label><select id='qunit-urlconfig-\" + escaped + \"' name='\" + escaped + \"' title='\" + escapedTooltip + \"'><option></option>\";\n\n\t\t\t\tif (QUnit.is(\"array\", val.value)) {\n\t\t\t\t\tfor (j = 0; j < val.value.length; j++) {\n\t\t\t\t\t\tescaped = escapeText(val.value[j]);\n\t\t\t\t\t\turlConfigHtml += \"<option value='\" + escaped + \"'\" + (config[val.id] === val.value[j] ? (selection = true) && \" selected='selected'\" : \"\") + \">\" + escaped + \"</option>\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (j in meteorBabelHelpers.sanitizeForInObject(val.value)) {\n\t\t\t\t\t\tif (hasOwn.call(val.value, j)) {\n\t\t\t\t\t\t\turlConfigHtml += \"<option value='\" + escapeText(j) + \"'\" + (config[val.id] === j ? (selection = true) && \" selected='selected'\" : \"\") + \">\" + escapeText(val.value[j]) + \"</option>\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (config[val.id] && !selection) {\n\t\t\t\t\tescaped = escapeText(config[val.id]);\n\t\t\t\t\turlConfigHtml += \"<option value='\" + escaped + \"' selected='selected' disabled='disabled'>\" + escaped + \"</option>\";\n\t\t\t\t}\n\t\t\t\turlConfigHtml += \"</select>\";\n\t\t\t}\n\t\t}\n\n\t\treturn urlConfigHtml;\n\t}\n\n\t// Handle \"click\" events on toolbar checkboxes and \"change\" for select menus.\n\t// Updates the URL with the new state of `config.urlConfig` values.\n\tfunction toolbarChanged() {\n\t\tvar updatedUrl,\n\t\t    value,\n\t\t    field = this,\n\t\t    params = {};\n\n\t\t// Detect if field is a select menu or a checkbox\n\t\tif (\"selectedIndex\" in field) {\n\t\t\tvalue = field.options[field.selectedIndex].value || undefined;\n\t\t} else {\n\t\t\tvalue = field.checked ? field.defaultValue || true : undefined;\n\t\t}\n\n\t\tparams[field.name] = value;\n\t\tupdatedUrl = setUrl(params);\n\n\t\tif (\"hidepassed\" === field.name && \"replaceState\" in window.history) {\n\t\t\tconfig[field.name] = value || false;\n\t\t\tif (value) {\n\t\t\t\taddClass(id(\"qunit-tests\"), \"hidepass\");\n\t\t\t} else {\n\t\t\t\tremoveClass(id(\"qunit-tests\"), \"hidepass\");\n\t\t\t}\n\n\t\t\t// It is not necessary to refresh the whole page\n\t\t\twindow.history.replaceState(null, \"\", updatedUrl);\n\t\t} else {\n\t\t\twindow.location = updatedUrl;\n\t\t}\n\t}\n\n\tfunction setUrl(params) {\n\t\tvar key,\n\t\t    querystring = \"?\";\n\n\t\tparams = QUnit.extend(QUnit.extend({}, QUnit.urlParams), params);\n\n\t\tfor (key in meteorBabelHelpers.sanitizeForInObject(params)) {\n\t\t\tif (hasOwn.call(params, key)) {\n\t\t\t\tif (params[key] === undefined) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tquerystring += encodeURIComponent(key);\n\t\t\t\tif (params[key] !== true) {\n\t\t\t\t\tquerystring += \"=\" + encodeURIComponent(params[key]);\n\t\t\t\t}\n\t\t\t\tquerystring += \"&\";\n\t\t\t}\n\t\t}\n\t\treturn location.protocol + \"//\" + location.host + location.pathname + querystring.slice(0, -1);\n\t}\n\n\tfunction applyUrlParams() {\n\t\tvar selectedModule,\n\t\t    modulesList = id(\"qunit-modulefilter\"),\n\t\t    filter = id(\"qunit-filter-input\").value;\n\n\t\tselectedModule = modulesList ? decodeURIComponent(modulesList.options[modulesList.selectedIndex].value) : undefined;\n\n\t\twindow.location = setUrl({\n\t\t\tmodule: selectedModule === \"\" ? undefined : selectedModule,\n\t\t\tfilter: filter === \"\" ? undefined : filter,\n\n\t\t\t// Remove testId filter\n\t\t\ttestId: undefined\n\t\t});\n\t}\n\n\tfunction toolbarUrlConfigContainer() {\n\t\tvar urlConfigContainer = document.createElement(\"span\");\n\n\t\turlConfigContainer.innerHTML = getUrlConfigHtml();\n\t\taddClass(urlConfigContainer, \"qunit-url-config\");\n\n\t\t// For oldIE support:\n\t\t// * Add handlers to the individual elements instead of the container\n\t\t// * Use \"click\" instead of \"change\" for checkboxes\n\t\taddEvents(urlConfigContainer.getElementsByTagName(\"input\"), \"click\", toolbarChanged);\n\t\taddEvents(urlConfigContainer.getElementsByTagName(\"select\"), \"change\", toolbarChanged);\n\n\t\treturn urlConfigContainer;\n\t}\n\n\tfunction toolbarLooseFilter() {\n\t\tvar filter = document.createElement(\"form\"),\n\t\t    label = document.createElement(\"label\"),\n\t\t    input = document.createElement(\"input\"),\n\t\t    button = document.createElement(\"button\");\n\n\t\taddClass(filter, \"qunit-filter\");\n\n\t\tlabel.innerHTML = \"Filter: \";\n\n\t\tinput.type = \"text\";\n\t\tinput.value = config.filter || \"\";\n\t\tinput.name = \"filter\";\n\t\tinput.id = \"qunit-filter-input\";\n\n\t\tbutton.innerHTML = \"Go\";\n\n\t\tlabel.appendChild(input);\n\n\t\tfilter.appendChild(label);\n\t\tfilter.appendChild(button);\n\t\taddEvent(filter, \"submit\", function (ev) {\n\t\t\tapplyUrlParams();\n\n\t\t\tif (ev && ev.preventDefault) {\n\t\t\t\tev.preventDefault();\n\t\t\t}\n\n\t\t\treturn false;\n\t\t});\n\n\t\treturn filter;\n\t}\n\n\tfunction toolbarModuleFilterHtml() {\n\t\tvar i,\n\t\t    moduleFilterHtml = \"\";\n\n\t\tif (!modulesList.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tmodulesList.sort(function (a, b) {\n\t\t\treturn a.localeCompare(b);\n\t\t});\n\n\t\tmoduleFilterHtml += \"<label for='qunit-modulefilter'>Module: </label>\" + \"<select id='qunit-modulefilter' name='modulefilter'><option value='' \" + (QUnit.urlParams.module === undefined ? \"selected='selected'\" : \"\") + \">< All Modules ></option>\";\n\n\t\tfor (i = 0; i < modulesList.length; i++) {\n\t\t\tmoduleFilterHtml += \"<option value='\" + escapeText(encodeURIComponent(modulesList[i])) + \"' \" + (QUnit.urlParams.module === modulesList[i] ? \"selected='selected'\" : \"\") + \">\" + escapeText(modulesList[i]) + \"</option>\";\n\t\t}\n\t\tmoduleFilterHtml += \"</select>\";\n\n\t\treturn moduleFilterHtml;\n\t}\n\n\tfunction toolbarModuleFilter() {\n\t\tvar toolbar = id(\"qunit-testrunner-toolbar\"),\n\t\t    moduleFilter = document.createElement(\"span\"),\n\t\t    moduleFilterHtml = toolbarModuleFilterHtml();\n\n\t\tif (!toolbar || !moduleFilterHtml) {\n\t\t\treturn false;\n\t\t}\n\n\t\tmoduleFilter.setAttribute(\"id\", \"qunit-modulefilter-container\");\n\t\tmoduleFilter.innerHTML = moduleFilterHtml;\n\n\t\taddEvent(moduleFilter.lastChild, \"change\", applyUrlParams);\n\n\t\ttoolbar.appendChild(moduleFilter);\n\t}\n\n\tfunction appendToolbar() {\n\t\tvar toolbar = id(\"qunit-testrunner-toolbar\");\n\n\t\tif (toolbar) {\n\t\t\ttoolbar.appendChild(toolbarUrlConfigContainer());\n\t\t\ttoolbar.appendChild(toolbarLooseFilter());\n\t\t}\n\t}\n\n\tfunction appendHeader() {\n\t\tvar header = id(\"qunit-header\");\n\n\t\tif (header) {\n\t\t\theader.innerHTML = \"<a href='\" + setUrl({ filter: undefined, module: undefined, testId: undefined }) + \"'>\" + header.innerHTML + \"</a> \";\n\t\t}\n\t}\n\n\tfunction appendBanner() {\n\t\tvar banner = id(\"qunit-banner\");\n\n\t\tif (banner) {\n\t\t\tbanner.className = \"\";\n\t\t}\n\t}\n\n\tfunction appendTestResults() {\n\t\tvar tests = id(\"qunit-tests\"),\n\t\t    result = id(\"qunit-testresult\");\n\n\t\tif (result) {\n\t\t\tresult.parentNode.removeChild(result);\n\t\t}\n\n\t\tif (tests) {\n\t\t\ttests.innerHTML = \"\";\n\t\t\tresult = document.createElement(\"p\");\n\t\t\tresult.id = \"qunit-testresult\";\n\t\t\tresult.className = \"result\";\n\t\t\ttests.parentNode.insertBefore(result, tests);\n\t\t\tresult.innerHTML = \"Running...<br />&#160;\";\n\t\t}\n\t}\n\n\tfunction storeFixture() {\n\t\tvar fixture = id(\"qunit-fixture\");\n\t\tif (fixture) {\n\t\t\tconfig.fixture = fixture.innerHTML;\n\t\t}\n\t}\n\n\tfunction appendFilteredTest() {\n\t\tvar testId = QUnit.config.testId;\n\t\tif (!testId || testId.length <= 0) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn \"<div id='qunit-filteredTest'>Rerunning selected tests: \" + testId.join(\", \") + \" <a id='qunit-clearFilter' href='\" + setUrl({ filter: undefined, module: undefined, testId: undefined }) + \"'>\" + \"Run all tests\" + \"</a></div>\";\n\t}\n\n\tfunction appendUserAgent() {\n\t\tvar userAgent = id(\"qunit-userAgent\");\n\n\t\tif (userAgent) {\n\t\t\tuserAgent.innerHTML = \"\";\n\t\t\tuserAgent.appendChild(document.createTextNode(\"QUnit \" + QUnit.version + \"; \" + navigator.userAgent));\n\t\t}\n\t}\n\n\tfunction appendTestsList(modules) {\n\t\tvar i, l, x, z, test, moduleObj;\n\n\t\tfor (i = 0, l = modules.length; i < l; i++) {\n\t\t\tmoduleObj = modules[i];\n\n\t\t\tif (moduleObj.name) {\n\t\t\t\tmodulesList.push(moduleObj.name);\n\t\t\t}\n\n\t\t\tfor (x = 0, z = moduleObj.tests.length; x < z; x++) {\n\t\t\t\ttest = moduleObj.tests[x];\n\n\t\t\t\tappendTest(test.name, test.testId, moduleObj.name);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction appendTest(name, testId, moduleName) {\n\t\tvar title,\n\t\t    rerunTrigger,\n\t\t    testBlock,\n\t\t    assertList,\n\t\t    tests = id(\"qunit-tests\");\n\n\t\tif (!tests) {\n\t\t\treturn;\n\t\t}\n\n\t\ttitle = document.createElement(\"strong\");\n\t\ttitle.innerHTML = getNameHtml(name, moduleName);\n\n\t\trerunTrigger = document.createElement(\"a\");\n\t\trerunTrigger.innerHTML = \"Rerun\";\n\t\trerunTrigger.href = setUrl({ testId: testId });\n\n\t\ttestBlock = document.createElement(\"li\");\n\t\ttestBlock.appendChild(title);\n\t\ttestBlock.appendChild(rerunTrigger);\n\t\ttestBlock.id = \"qunit-test-output-\" + testId;\n\n\t\tassertList = document.createElement(\"ol\");\n\t\tassertList.className = \"qunit-assert-list\";\n\n\t\ttestBlock.appendChild(assertList);\n\n\t\ttests.appendChild(testBlock);\n\t}\n\n\t// HTML Reporter initialization and load\n\tQUnit.begin(function (details) {\n\t\tvar qunit = id(\"qunit\");\n\n\t\t// Fixture is the only one necessary to run without the #qunit element\n\t\tstoreFixture();\n\n\t\tif (qunit) {\n\t\t\tqunit.innerHTML = \"<h1 id='qunit-header'>\" + escapeText(document.title) + \"</h1>\" + \"<h2 id='qunit-banner'></h2>\" + \"<div id='qunit-testrunner-toolbar'></div>\" + appendFilteredTest() + \"<h2 id='qunit-userAgent'></h2>\" + \"<ol id='qunit-tests'></ol>\";\n\t\t}\n\n\t\tappendHeader();\n\t\tappendBanner();\n\t\tappendTestResults();\n\t\tappendUserAgent();\n\t\tappendToolbar();\n\t\tappendTestsList(details.modules);\n\t\ttoolbarModuleFilter();\n\n\t\tif (qunit && config.hidepassed) {\n\t\t\taddClass(qunit.lastChild, \"hidepass\");\n\t\t}\n\t});\n\n\tQUnit.done(function (details) {\n\t\tvar i,\n\t\t    key,\n\t\t    banner = id(\"qunit-banner\"),\n\t\t    tests = id(\"qunit-tests\"),\n\t\t    html = [\"Tests completed in \", details.runtime, \" milliseconds.<br />\", \"<span class='passed'>\", details.passed, \"</span> assertions of <span class='total'>\", details.total, \"</span> passed, <span class='failed'>\", details.failed, \"</span> failed.\"].join(\"\");\n\n\t\tif (banner) {\n\t\t\tbanner.className = details.failed ? \"qunit-fail\" : \"qunit-pass\";\n\t\t}\n\n\t\tif (tests) {\n\t\t\tid(\"qunit-testresult\").innerHTML = html;\n\t\t}\n\n\t\tif (config.altertitle && defined.document && document.title) {\n\n\t\t\t// show ‚úñ for good, ‚úî for bad suite result in title\n\t\t\t// use escape sequences in case file gets loaded with non-utf-8-charset\n\t\t\tdocument.title = [details.failed ? \"‚úñ\" : \"‚úî\", document.title.replace(/^[\\u2714\\u2716] /i, \"\")].join(\" \");\n\t\t}\n\n\t\t// clear own sessionStorage items if all tests passed\n\t\tif (config.reorder && defined.sessionStorage && details.failed === 0) {\n\t\t\tfor (i = 0; i < sessionStorage.length; i++) {\n\t\t\t\tkey = sessionStorage.key(i++);\n\t\t\t\tif (key.indexOf(\"qunit-test-\") === 0) {\n\t\t\t\t\tsessionStorage.removeItem(key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// scroll back to top to show results\n\t\tif (config.scrolltop && window.scrollTo) {\n\t\t\twindow.scrollTo(0, 0);\n\t\t}\n\t});\n\n\tfunction getNameHtml(name, module) {\n\t\tvar nameHtml = \"\";\n\n\t\tif (module) {\n\t\t\tnameHtml = \"<span class='module-name'>\" + escapeText(module) + \"</span>: \";\n\t\t}\n\n\t\tnameHtml += \"<span class='test-name'>\" + escapeText(name) + \"</span>\";\n\n\t\treturn nameHtml;\n\t}\n\n\tQUnit.testStart(function (details) {\n\t\tvar running, testBlock, bad;\n\n\t\ttestBlock = id(\"qunit-test-output-\" + details.testId);\n\t\tif (testBlock) {\n\t\t\ttestBlock.className = \"running\";\n\t\t} else {\n\n\t\t\t// Report later registered tests\n\t\t\tappendTest(details.name, details.testId, details.module);\n\t\t}\n\n\t\trunning = id(\"qunit-testresult\");\n\t\tif (running) {\n\t\t\tbad = QUnit.config.reorder && defined.sessionStorage && +sessionStorage.getItem(\"qunit-test-\" + details.module + \"-\" + details.name);\n\n\t\t\trunning.innerHTML = (bad ? \"Rerunning previously failed test: <br />\" : \"Running: <br />\") + getNameHtml(details.name, details.module);\n\t\t}\n\t});\n\n\tfunction stripHtml(string) {\n\t\t// strip tags, html entity and whitespaces\n\t\treturn string.replace(/<\\/?[^>]+(>|$)/g, \"\").replace(/\\&quot;/g, \"\").replace(/\\s+/g, \"\");\n\t}\n\n\tQUnit.log(function (details) {\n\t\tvar assertList,\n\t\t    assertLi,\n\t\t    message,\n\t\t    expected,\n\t\t    actual,\n\t\t    diff,\n\t\t    showDiff = false,\n\t\t    testItem = id(\"qunit-test-output-\" + details.testId);\n\n\t\tif (!testItem) {\n\t\t\treturn;\n\t\t}\n\n\t\tmessage = escapeText(details.message) || (details.result ? \"okay\" : \"failed\");\n\t\tmessage = \"<span class='test-message'>\" + message + \"</span>\";\n\t\tmessage += \"<span class='runtime'>@ \" + details.runtime + \" ms</span>\";\n\n\t\t// pushFailure doesn't provide details.expected\n\t\t// when it calls, it's implicit to also not show expected and diff stuff\n\t\t// Also, we need to check details.expected existence, as it can exist and be undefined\n\t\tif (!details.result && hasOwn.call(details, \"expected\")) {\n\t\t\tif (details.negative) {\n\t\t\t\texpected = escapeText(\"NOT \" + QUnit.dump.parse(details.expected));\n\t\t\t} else {\n\t\t\t\texpected = escapeText(QUnit.dump.parse(details.expected));\n\t\t\t}\n\n\t\t\tactual = escapeText(QUnit.dump.parse(details.actual));\n\t\t\tmessage += \"<table><tr class='test-expected'><th>Expected: </th><td><pre>\" + expected + \"</pre></td></tr>\";\n\n\t\t\tif (actual !== expected) {\n\n\t\t\t\tmessage += \"<tr class='test-actual'><th>Result: </th><td><pre>\" + actual + \"</pre></td></tr>\";\n\n\t\t\t\t// Don't show diff if actual or expected are booleans\n\t\t\t\tif (!/^(true|false)$/.test(actual) && !/^(true|false)$/.test(expected)) {\n\t\t\t\t\tdiff = QUnit.diff(expected, actual);\n\t\t\t\t\tshowDiff = stripHtml(diff).length !== stripHtml(expected).length + stripHtml(actual).length;\n\t\t\t\t}\n\n\t\t\t\t// Don't show diff if expected and actual are totally different\n\t\t\t\tif (showDiff) {\n\t\t\t\t\tmessage += \"<tr class='test-diff'><th>Diff: </th><td><pre>\" + diff + \"</pre></td></tr>\";\n\t\t\t\t}\n\t\t\t} else if (expected.indexOf(\"[object Array]\") !== -1 || expected.indexOf(\"[object Object]\") !== -1) {\n\t\t\t\tmessage += \"<tr class='test-message'><th>Message: </th><td>\" + \"Diff suppressed as the depth of object is more than current max depth (\" + QUnit.config.maxDepth + \").<p>Hint: Use <code>QUnit.dump.maxDepth</code> to \" + \" run with a higher max depth or <a href='\" + setUrl({ maxDepth: -1 }) + \"'>\" + \"Rerun</a> without max depth.</p></td></tr>\";\n\t\t\t}\n\n\t\t\tif (details.source) {\n\t\t\t\tmessage += \"<tr class='test-source'><th>Source: </th><td><pre>\" + escapeText(details.source) + \"</pre></td></tr>\";\n\t\t\t}\n\n\t\t\tmessage += \"</table>\";\n\n\t\t\t// this occours when pushFailure is set and we have an extracted stack trace\n\t\t} else if (!details.result && details.source) {\n\t\t\t\tmessage += \"<table>\" + \"<tr class='test-source'><th>Source: </th><td><pre>\" + escapeText(details.source) + \"</pre></td></tr>\" + \"</table>\";\n\t\t\t}\n\n\t\tassertList = testItem.getElementsByTagName(\"ol\")[0];\n\n\t\tassertLi = document.createElement(\"li\");\n\t\tassertLi.className = details.result ? \"pass\" : \"fail\";\n\t\tassertLi.innerHTML = message;\n\t\tassertList.appendChild(assertLi);\n\t});\n\n\tQUnit.testDone(function (details) {\n\t\tvar testTitle,\n\t\t    time,\n\t\t    testItem,\n\t\t    assertList,\n\t\t    good,\n\t\t    bad,\n\t\t    testCounts,\n\t\t    skipped,\n\t\t    sourceName,\n\t\t    tests = id(\"qunit-tests\");\n\n\t\tif (!tests) {\n\t\t\treturn;\n\t\t}\n\n\t\ttestItem = id(\"qunit-test-output-\" + details.testId);\n\n\t\tassertList = testItem.getElementsByTagName(\"ol\")[0];\n\n\t\tgood = details.passed;\n\t\tbad = details.failed;\n\n\t\t// store result when possible\n\t\tif (config.reorder && defined.sessionStorage) {\n\t\t\tif (bad) {\n\t\t\t\tsessionStorage.setItem(\"qunit-test-\" + details.module + \"-\" + details.name, bad);\n\t\t\t} else {\n\t\t\t\tsessionStorage.removeItem(\"qunit-test-\" + details.module + \"-\" + details.name);\n\t\t\t}\n\t\t}\n\n\t\tif (bad === 0) {\n\n\t\t\t// Collapse the passing tests\n\t\t\taddClass(assertList, \"qunit-collapsed\");\n\t\t} else if (bad && config.collapse && !collapseNext) {\n\n\t\t\t// Skip collapsing the first failing test\n\t\t\tcollapseNext = true;\n\t\t} else {\n\n\t\t\t// Collapse remaining tests\n\t\t\taddClass(assertList, \"qunit-collapsed\");\n\t\t}\n\n\t\t// testItem.firstChild is the test name\n\t\ttestTitle = testItem.firstChild;\n\n\t\ttestCounts = bad ? \"<b class='failed'>\" + bad + \"</b>, \" + \"<b class='passed'>\" + good + \"</b>, \" : \"\";\n\n\t\ttestTitle.innerHTML += \" <b class='counts'>(\" + testCounts + details.assertions.length + \")</b>\";\n\n\t\tif (details.skipped) {\n\t\t\ttestItem.className = \"skipped\";\n\t\t\tskipped = document.createElement(\"em\");\n\t\t\tskipped.className = \"qunit-skipped-label\";\n\t\t\tskipped.innerHTML = \"skipped\";\n\t\t\ttestItem.insertBefore(skipped, testTitle);\n\t\t} else {\n\t\t\taddEvent(testTitle, \"click\", function () {\n\t\t\t\ttoggleClass(assertList, \"qunit-collapsed\");\n\t\t\t});\n\n\t\t\ttestItem.className = bad ? \"fail\" : \"pass\";\n\n\t\t\ttime = document.createElement(\"span\");\n\t\t\ttime.className = \"runtime\";\n\t\t\ttime.innerHTML = details.runtime + \" ms\";\n\t\t\ttestItem.insertBefore(time, assertList);\n\t\t}\n\n\t\t// Show the source of the test when showing assertions\n\t\tif (details.source) {\n\t\t\tsourceName = document.createElement(\"p\");\n\t\t\tsourceName.innerHTML = \"<strong>Source: </strong>\" + details.source;\n\t\t\taddClass(sourceName, \"qunit-source\");\n\t\t\tif (bad === 0) {\n\t\t\t\taddClass(sourceName, \"qunit-collapsed\");\n\t\t\t}\n\t\t\taddEvent(testTitle, \"click\", function () {\n\t\t\t\ttoggleClass(sourceName, \"qunit-collapsed\");\n\t\t\t});\n\t\t\ttestItem.appendChild(sourceName);\n\t\t}\n\t});\n\n\tif (defined.document) {\n\n\t\t// Avoid readyState issue with phantomjs\n\t\t// Ref: #818\n\t\tvar notPhantom = function (p) {\n\t\t\treturn !(p && p.version && p.version.major > 0);\n\t\t}(window.phantom);\n\n\t\tif (notPhantom && document.readyState === \"complete\") {\n\t\t\tQUnit.load();\n\t\t} else {\n\t\t\taddEvent(window, \"load\", QUnit.load);\n\t\t}\n\t} else {\n\t\tconfig.pageLoaded = true;\n\t\tconfig.autorun = true;\n\t}\n})();","ast":null,"map":{"version":3,"sources":["/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/qunit/qunit.js"],"names":[],"mappings":"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","file":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/qunit/qunit.js.map","sourcesContent":["/*!\n * QUnit 1.20.0\n * http://qunitjs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2015-10-27T17:53Z\n */\n\n(function( global ) {\n\nvar QUnit = {};\n\nvar Date = global.Date;\nvar now = Date.now || function() {\n\treturn new Date().getTime();\n};\n\nvar setTimeout = global.setTimeout;\nvar clearTimeout = global.clearTimeout;\n\n// Store a local window from the global to allow direct references.\nvar window = global.window;\n\nvar defined = {\n\tdocument: window && window.document !== undefined,\n\tsetTimeout: setTimeout !== undefined,\n\tsessionStorage: (function() {\n\t\tvar x = \"qunit-test-string\";\n\t\ttry {\n\t\t\tsessionStorage.setItem( x, x );\n\t\t\tsessionStorage.removeItem( x );\n\t\t\treturn true;\n\t\t} catch ( e ) {\n\t\t\treturn false;\n\t\t}\n\t}() )\n};\n\nvar fileName = ( sourceFromStacktrace( 0 ) || \"\" ).replace( /(:\\d+)+\\)?/, \"\" ).replace( /.+\\//, \"\" );\nvar globalStartCalled = false;\nvar runStarted = false;\n\nvar toString = Object.prototype.toString,\n\thasOwn = Object.prototype.hasOwnProperty;\n\n// returns a new Array with the elements that are in a but not in b\nfunction diff( a, b ) {\n\tvar i, j,\n\t\tresult = a.slice();\n\n\tfor ( i = 0; i < result.length; i++ ) {\n\t\tfor ( j = 0; j < b.length; j++ ) {\n\t\t\tif ( result[ i ] === b[ j ] ) {\n\t\t\t\tresult.splice( i, 1 );\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\n// from jquery.js\nfunction inArray( elem, array ) {\n\tif ( array.indexOf ) {\n\t\treturn array.indexOf( elem );\n\t}\n\n\tfor ( var i = 0, length = array.length; i < length; i++ ) {\n\t\tif ( array[ i ] === elem ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * Makes a clone of an object using only Array or Object as base,\n * and copies over the own enumerable properties.\n *\n * @param {Object} obj\n * @return {Object} New object with only the own properties (recursively).\n */\nfunction objectValues ( obj ) {\n\tvar key, val,\n\t\tvals = QUnit.is( \"array\", obj ) ? [] : {};\n\tfor ( key in obj ) {\n\t\tif ( hasOwn.call( obj, key ) ) {\n\t\t\tval = obj[ key ];\n\t\t\tvals[ key ] = val === Object( val ) ? objectValues( val ) : val;\n\t\t}\n\t}\n\treturn vals;\n}\n\nfunction extend( a, b, undefOnly ) {\n\tfor ( var prop in b ) {\n\t\tif ( hasOwn.call( b, prop ) ) {\n\n\t\t\t// Avoid \"Member not found\" error in IE8 caused by messing with window.constructor\n\t\t\t// This block runs on every environment, so `global` is being used instead of `window`\n\t\t\t// to avoid errors on node.\n\t\t\tif ( prop !== \"constructor\" || a !== global ) {\n\t\t\t\tif ( b[ prop ] === undefined ) {\n\t\t\t\t\tdelete a[ prop ];\n\t\t\t\t} else if ( !( undefOnly && typeof a[ prop ] !== \"undefined\" ) ) {\n\t\t\t\t\ta[ prop ] = b[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a;\n}\n\nfunction objectType( obj ) {\n\tif ( typeof obj === \"undefined\" ) {\n\t\treturn \"undefined\";\n\t}\n\n\t// Consider: typeof null === object\n\tif ( obj === null ) {\n\t\treturn \"null\";\n\t}\n\n\tvar match = toString.call( obj ).match( /^\\[object\\s(.*)\\]$/ ),\n\t\ttype = match && match[ 1 ];\n\n\tswitch ( type ) {\n\t\tcase \"Number\":\n\t\t\tif ( isNaN( obj ) ) {\n\t\t\t\treturn \"nan\";\n\t\t\t}\n\t\t\treturn \"number\";\n\t\tcase \"String\":\n\t\tcase \"Boolean\":\n\t\tcase \"Array\":\n\t\tcase \"Set\":\n\t\tcase \"Map\":\n\t\tcase \"Date\":\n\t\tcase \"RegExp\":\n\t\tcase \"Function\":\n\t\tcase \"Symbol\":\n\t\t\treturn type.toLowerCase();\n\t}\n\tif ( typeof obj === \"object\" ) {\n\t\treturn \"object\";\n\t}\n}\n\n// Safe object type checking\nfunction is( type, obj ) {\n\treturn QUnit.objectType( obj ) === type;\n}\n\nvar getUrlParams = function() {\n\tvar i, current;\n\tvar urlParams = {};\n\tvar location = window.location;\n\tvar params = location.search.slice( 1 ).split( \"&\" );\n\tvar length = params.length;\n\n\tif ( params[ 0 ] ) {\n\t\tfor ( i = 0; i < length; i++ ) {\n\t\t\tcurrent = params[ i ].split( \"=\" );\n\t\t\tcurrent[ 0 ] = decodeURIComponent( current[ 0 ] );\n\n\t\t\t// allow just a key to turn on a flag, e.g., test.html?noglobals\n\t\t\tcurrent[ 1 ] = current[ 1 ] ? decodeURIComponent( current[ 1 ] ) : true;\n\t\t\tif ( urlParams[ current[ 0 ] ] ) {\n\t\t\t\turlParams[ current[ 0 ] ] = [].concat( urlParams[ current[ 0 ] ], current[ 1 ] );\n\t\t\t} else {\n\t\t\t\turlParams[ current[ 0 ] ] = current[ 1 ];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn urlParams;\n};\n\n// Doesn't support IE6 to IE9, it will return undefined on these browsers\n// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\nfunction extractStacktrace( e, offset ) {\n\toffset = offset === undefined ? 4 : offset;\n\n\tvar stack, include, i;\n\n\tif ( e.stack ) {\n\t\tstack = e.stack.split( \"\\n\" );\n\t\tif ( /^error$/i.test( stack[ 0 ] ) ) {\n\t\t\tstack.shift();\n\t\t}\n\t\tif ( fileName ) {\n\t\t\tinclude = [];\n\t\t\tfor ( i = offset; i < stack.length; i++ ) {\n\t\t\t\tif ( stack[ i ].indexOf( fileName ) !== -1 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinclude.push( stack[ i ] );\n\t\t\t}\n\t\t\tif ( include.length ) {\n\t\t\t\treturn include.join( \"\\n\" );\n\t\t\t}\n\t\t}\n\t\treturn stack[ offset ];\n\n\t// Support: Safari <=6 only\n\t} else if ( e.sourceURL ) {\n\n\t\t// exclude useless self-reference for generated Error objects\n\t\tif ( /qunit.js$/.test( e.sourceURL ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// for actual exceptions, this is useful\n\t\treturn e.sourceURL + \":\" + e.line;\n\t}\n}\n\nfunction sourceFromStacktrace( offset ) {\n\tvar error = new Error();\n\n\t// Support: Safari <=7 only, IE <=10 - 11 only\n\t// Not all browsers generate the `stack` property for `new Error()`, see also #636\n\tif ( !error.stack ) {\n\t\ttry {\n\t\t\tthrow error;\n\t\t} catch ( err ) {\n\t\t\terror = err;\n\t\t}\n\t}\n\n\treturn extractStacktrace( error, offset );\n}\n\n/**\n * Config object: Maintain internal state\n * Later exposed as QUnit.config\n * `config` initialized at top of scope\n */\nvar config = {\n\t// The queue of tests to run\n\tqueue: [],\n\n\t// block until document ready\n\tblocking: true,\n\n\t// by default, run previously failed tests first\n\t// very useful in combination with \"Hide passed tests\" checked\n\treorder: true,\n\n\t// by default, modify document.title when suite is done\n\taltertitle: true,\n\n\t// HTML Reporter: collapse every test except the first failing test\n\t// If false, all failing tests will be expanded\n\tcollapse: true,\n\n\t// by default, scroll to top of the page when suite is done\n\tscrolltop: true,\n\n\t// depth up-to which object will be dumped\n\tmaxDepth: 5,\n\n\t// when enabled, all tests must call expect()\n\trequireExpects: false,\n\n\t// add checkboxes that are persisted in the query-string\n\t// when enabled, the id is set to `true` as a `QUnit.config` property\n\turlConfig: [\n\t\t{\n\t\t\tid: \"hidepassed\",\n\t\t\tlabel: \"Hide passed tests\",\n\t\t\ttooltip: \"Only show tests and assertions that fail. Stored as query-strings.\"\n\t\t},\n\t\t{\n\t\t\tid: \"noglobals\",\n\t\t\tlabel: \"Check for Globals\",\n\t\t\ttooltip: \"Enabling this will test if any test introduces new properties on the \" +\n\t\t\t\t\"global object (`window` in Browsers). Stored as query-strings.\"\n\t\t},\n\t\t{\n\t\t\tid: \"notrycatch\",\n\t\t\tlabel: \"No try-catch\",\n\t\t\ttooltip: \"Enabling this will run tests outside of a try-catch block. Makes debugging \" +\n\t\t\t\t\"exceptions in IE reasonable. Stored as query-strings.\"\n\t\t}\n\t],\n\n\t// Set of all modules.\n\tmodules: [],\n\n\t// Stack of nested modules\n\tmoduleStack: [],\n\n\t// The first unnamed module\n\tcurrentModule: {\n\t\tname: \"\",\n\t\ttests: []\n\t},\n\n\tcallbacks: {}\n};\n\nvar urlParams = defined.document ? getUrlParams() : {};\n\n// Push a loose unnamed module to the modules collection\nconfig.modules.push( config.currentModule );\n\nif ( urlParams.filter === true ) {\n\tdelete urlParams.filter;\n}\n\n// String search anywhere in moduleName+testName\nconfig.filter = urlParams.filter;\n\nconfig.testId = [];\nif ( urlParams.testId ) {\n\t// Ensure that urlParams.testId is an array\n\turlParams.testId = decodeURIComponent( urlParams.testId ).split( \",\" );\n\tfor (var i = 0; i < urlParams.testId.length; i++ ) {\n\t\tconfig.testId.push( urlParams.testId[ i ] );\n\t}\n}\n\nvar loggingCallbacks = {};\n\n// Register logging callbacks\nfunction registerLoggingCallbacks( obj ) {\n\tvar i, l, key,\n\t\tcallbackNames = [ \"begin\", \"done\", \"log\", \"testStart\", \"testDone\",\n\t\t\t\"moduleStart\", \"moduleDone\" ];\n\n\tfunction registerLoggingCallback( key ) {\n\t\tvar loggingCallback = function( callback ) {\n\t\t\tif ( objectType( callback ) !== \"function\" ) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"QUnit logging methods require a callback function as their first parameters.\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconfig.callbacks[ key ].push( callback );\n\t\t};\n\n\t\t// DEPRECATED: This will be removed on QUnit 2.0.0+\n\t\t// Stores the registered functions allowing restoring\n\t\t// at verifyLoggingCallbacks() if modified\n\t\tloggingCallbacks[ key ] = loggingCallback;\n\n\t\treturn loggingCallback;\n\t}\n\n\tfor ( i = 0, l = callbackNames.length; i < l; i++ ) {\n\t\tkey = callbackNames[ i ];\n\n\t\t// Initialize key collection of logging callback\n\t\tif ( objectType( config.callbacks[ key ] ) === \"undefined\" ) {\n\t\t\tconfig.callbacks[ key ] = [];\n\t\t}\n\n\t\tobj[ key ] = registerLoggingCallback( key );\n\t}\n}\n\nfunction runLoggingCallbacks( key, args ) {\n\tvar i, l, callbacks;\n\n\tcallbacks = config.callbacks[ key ];\n\tfor ( i = 0, l = callbacks.length; i < l; i++ ) {\n\t\tcallbacks[ i ]( args );\n\t}\n}\n\n// DEPRECATED: This will be removed on 2.0.0+\n// This function verifies if the loggingCallbacks were modified by the user\n// If so, it will restore it, assign the given callback and print a console warning\nfunction verifyLoggingCallbacks() {\n\tvar loggingCallback, userCallback;\n\n\tfor ( loggingCallback in loggingCallbacks ) {\n\t\tif ( QUnit[ loggingCallback ] !== loggingCallbacks[ loggingCallback ] ) {\n\n\t\t\tuserCallback = QUnit[ loggingCallback ];\n\n\t\t\t// Restore the callback function\n\t\t\tQUnit[ loggingCallback ] = loggingCallbacks[ loggingCallback ];\n\n\t\t\t// Assign the deprecated given callback\n\t\t\tQUnit[ loggingCallback ]( userCallback );\n\n\t\t\tif ( global.console && global.console.warn ) {\n\t\t\t\tglobal.console.warn(\n\t\t\t\t\t\"QUnit.\" + loggingCallback + \" was replaced with a new value.\\n\" +\n\t\t\t\t\t\"Please, check out the documentation on how to apply logging callbacks.\\n\" +\n\t\t\t\t\t\"Reference: http://api.qunitjs.com/category/callbacks/\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\n( function() {\n\tif ( !defined.document ) {\n\t\treturn;\n\t}\n\n\t// `onErrorFnPrev` initialized at top of scope\n\t// Preserve other handlers\n\tvar onErrorFnPrev = window.onerror;\n\n\t// Cover uncaught exceptions\n\t// Returning true will suppress the default browser handler,\n\t// returning false will let it run.\n\twindow.onerror = function( error, filePath, linerNr ) {\n\t\tvar ret = false;\n\t\tif ( onErrorFnPrev ) {\n\t\t\tret = onErrorFnPrev( error, filePath, linerNr );\n\t\t}\n\n\t\t// Treat return value as window.onerror itself does,\n\t\t// Only do our handling if not suppressed.\n\t\tif ( ret !== true ) {\n\t\t\tif ( QUnit.config.current ) {\n\t\t\t\tif ( QUnit.config.current.ignoreGlobalErrors ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\n\t\t\t} else {\n\t\t\t\tQUnit.test( \"global failure\", extend(function() {\n\t\t\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\n\t\t\t\t}, { validTest: true } ) );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\treturn ret;\n\t};\n} )();\n\nQUnit.urlParams = urlParams;\n\n// Figure out if we're running the tests from a server or not\nQUnit.isLocal = !( defined.document && window.location.protocol !== \"file:\" );\n\n// Expose the current QUnit version\nQUnit.version = \"1.20.0\";\n\nextend( QUnit, {\n\n\t// call on start of module test to prepend name to all tests\n\tmodule: function( name, testEnvironment, executeNow ) {\n\t\tvar module, moduleFns;\n\t\tvar currentModule = config.currentModule;\n\n\t\tif ( arguments.length === 2 ) {\n\t\t\tif ( testEnvironment instanceof Function ) {\n\t\t\t\texecuteNow = testEnvironment;\n\t\t\t\ttestEnvironment = undefined;\n\t\t\t}\n\t\t}\n\n\t\t// DEPRECATED: handles setup/teardown functions,\n\t\t// beforeEach and afterEach should be used instead\n\t\tif ( testEnvironment && testEnvironment.setup ) {\n\t\t\ttestEnvironment.beforeEach = testEnvironment.setup;\n\t\t\tdelete testEnvironment.setup;\n\t\t}\n\t\tif ( testEnvironment && testEnvironment.teardown ) {\n\t\t\ttestEnvironment.afterEach = testEnvironment.teardown;\n\t\t\tdelete testEnvironment.teardown;\n\t\t}\n\n\t\tmodule = createModule();\n\n\t\tmoduleFns = {\n\t\t\tbeforeEach: setHook( module, \"beforeEach\" ),\n\t\t\tafterEach: setHook( module, \"afterEach\" )\n\t\t};\n\n\t\tif ( executeNow instanceof Function ) {\n\t\t\tconfig.moduleStack.push( module );\n\t\t\tsetCurrentModule( module );\n\t\t\texecuteNow.call( module.testEnvironment, moduleFns );\n\t\t\tconfig.moduleStack.pop();\n\t\t\tmodule = module.parentModule || currentModule;\n\t\t}\n\n\t\tsetCurrentModule( module );\n\n\t\tfunction createModule() {\n\t\t\tvar parentModule = config.moduleStack.length ?\n\t\t\t\tconfig.moduleStack.slice( -1 )[ 0 ] : null;\n\t\t\tvar moduleName = parentModule !== null ?\n\t\t\t\t[ parentModule.name, name ].join( \" > \" ) : name;\n\t\t\tvar module = {\n\t\t\t\tname: moduleName,\n\t\t\t\tparentModule: parentModule,\n\t\t\t\ttests: []\n\t\t\t};\n\n\t\t\tvar env = {};\n\t\t\tif ( parentModule ) {\n\t\t\t\textend( env, parentModule.testEnvironment );\n\t\t\t\tdelete env.beforeEach;\n\t\t\t\tdelete env.afterEach;\n\t\t\t}\n\t\t\textend( env, testEnvironment );\n\t\t\tmodule.testEnvironment = env;\n\n\t\t\tconfig.modules.push( module );\n\t\t\treturn module;\n\t\t}\n\n\t\tfunction setCurrentModule( module ) {\n\t\t\tconfig.currentModule = module;\n\t\t}\n\n\t},\n\n\t// DEPRECATED: QUnit.asyncTest() will be removed in QUnit 2.0.\n\tasyncTest: asyncTest,\n\n\ttest: test,\n\n\tskip: skip,\n\n\tonly: only,\n\n\t// DEPRECATED: The functionality of QUnit.start() will be altered in QUnit 2.0.\n\t// In QUnit 2.0, invoking it will ONLY affect the `QUnit.config.autostart` blocking behavior.\n\tstart: function( count ) {\n\t\tvar globalStartAlreadyCalled = globalStartCalled;\n\n\t\tif ( !config.current ) {\n\t\t\tglobalStartCalled = true;\n\n\t\t\tif ( runStarted ) {\n\t\t\t\tthrow new Error( \"Called start() outside of a test context while already started\" );\n\t\t\t} else if ( globalStartAlreadyCalled || count > 1 ) {\n\t\t\t\tthrow new Error( \"Called start() outside of a test context too many times\" );\n\t\t\t} else if ( config.autostart ) {\n\t\t\t\tthrow new Error( \"Called start() outside of a test context when \" +\n\t\t\t\t\t\"QUnit.config.autostart was true\" );\n\t\t\t} else if ( !config.pageLoaded ) {\n\n\t\t\t\t// The page isn't completely loaded yet, so bail out and let `QUnit.load` handle it\n\t\t\t\tconfig.autostart = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\n\t\t\t// If a test is running, adjust its semaphore\n\t\t\tconfig.current.semaphore -= count || 1;\n\n\t\t\t// If semaphore is non-numeric, throw error\n\t\t\tif ( isNaN( config.current.semaphore ) ) {\n\t\t\t\tconfig.current.semaphore = 0;\n\n\t\t\t\tQUnit.pushFailure(\n\t\t\t\t\t\"Called start() with a non-numeric decrement.\",\n\t\t\t\t\tsourceFromStacktrace( 2 )\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Don't start until equal number of stop-calls\n\t\t\tif ( config.current.semaphore > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// throw an Error if start is called more often than stop\n\t\t\tif ( config.current.semaphore < 0 ) {\n\t\t\t\tconfig.current.semaphore = 0;\n\n\t\t\t\tQUnit.pushFailure(\n\t\t\t\t\t\"Called start() while already started (test's semaphore was 0 already)\",\n\t\t\t\t\tsourceFromStacktrace( 2 )\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tresumeProcessing();\n\t},\n\n\t// DEPRECATED: QUnit.stop() will be removed in QUnit 2.0.\n\tstop: function( count ) {\n\n\t\t// If there isn't a test running, don't allow QUnit.stop() to be called\n\t\tif ( !config.current ) {\n\t\t\tthrow new Error( \"Called stop() outside of a test context\" );\n\t\t}\n\n\t\t// If a test is running, adjust its semaphore\n\t\tconfig.current.semaphore += count || 1;\n\n\t\tpauseProcessing();\n\t},\n\n\tconfig: config,\n\n\tis: is,\n\n\tobjectType: objectType,\n\n\textend: extend,\n\n\tload: function() {\n\t\tconfig.pageLoaded = true;\n\n\t\t// Initialize the configuration options\n\t\textend( config, {\n\t\t\tstats: { all: 0, bad: 0 },\n\t\t\tmoduleStats: { all: 0, bad: 0 },\n\t\t\tstarted: 0,\n\t\t\tupdateRate: 1000,\n\t\t\tautostart: true,\n\t\t\tfilter: \"\"\n\t\t}, true );\n\n\t\tconfig.blocking = false;\n\n\t\tif ( config.autostart ) {\n\t\t\tresumeProcessing();\n\t\t}\n\t},\n\n\tstack: function( offset ) {\n\t\toffset = ( offset || 0 ) + 2;\n\t\treturn sourceFromStacktrace( offset );\n\t}\n});\n\nregisterLoggingCallbacks( QUnit );\n\nfunction begin() {\n\tvar i, l,\n\t\tmodulesLog = [];\n\n\t// If the test run hasn't officially begun yet\n\tif ( !config.started ) {\n\n\t\t// Record the time of the test run's beginning\n\t\tconfig.started = now();\n\n\t\tverifyLoggingCallbacks();\n\n\t\t// Delete the loose unnamed module if unused.\n\t\tif ( config.modules[ 0 ].name === \"\" && config.modules[ 0 ].tests.length === 0 ) {\n\t\t\tconfig.modules.shift();\n\t\t}\n\n\t\t// Avoid unnecessary information by not logging modules' test environments\n\t\tfor ( i = 0, l = config.modules.length; i < l; i++ ) {\n\t\t\tmodulesLog.push({\n\t\t\t\tname: config.modules[ i ].name,\n\t\t\t\ttests: config.modules[ i ].tests\n\t\t\t});\n\t\t}\n\n\t\t// The test run is officially beginning now\n\t\trunLoggingCallbacks( \"begin\", {\n\t\t\ttotalTests: Test.count,\n\t\t\tmodules: modulesLog\n\t\t});\n\t}\n\n\tconfig.blocking = false;\n\tprocess( true );\n}\n\nfunction process( last ) {\n\tfunction next() {\n\t\tprocess( last );\n\t}\n\tvar start = now();\n\tconfig.depth = ( config.depth || 0 ) + 1;\n\n\twhile ( config.queue.length && !config.blocking ) {\n\t\tif ( !defined.setTimeout || config.updateRate <= 0 ||\n\t\t\t\t( ( now() - start ) < config.updateRate ) ) {\n\t\t\tif ( config.current ) {\n\n\t\t\t\t// Reset async tracking for each phase of the Test lifecycle\n\t\t\t\tconfig.current.usedAsync = false;\n\t\t\t}\n\t\t\tconfig.queue.shift()();\n\t\t} else {\n\t\t\tsetTimeout( next, 13 );\n\t\t\tbreak;\n\t\t}\n\t}\n\tconfig.depth--;\n\tif ( last && !config.blocking && !config.queue.length && config.depth === 0 ) {\n\t\tdone();\n\t}\n}\n\nfunction pauseProcessing() {\n\tconfig.blocking = true;\n\n\tif ( config.testTimeout && defined.setTimeout ) {\n\t\tclearTimeout( config.timeout );\n\t\tconfig.timeout = setTimeout(function() {\n\t\t\tif ( config.current ) {\n\t\t\t\tconfig.current.semaphore = 0;\n\t\t\t\tQUnit.pushFailure( \"Test timed out\", sourceFromStacktrace( 2 ) );\n\t\t\t} else {\n\t\t\t\tthrow new Error( \"Test timed out\" );\n\t\t\t}\n\t\t\tresumeProcessing();\n\t\t}, config.testTimeout );\n\t}\n}\n\nfunction resumeProcessing() {\n\trunStarted = true;\n\n\t// A slight delay to allow this iteration of the event loop to finish (more assertions, etc.)\n\tif ( defined.setTimeout ) {\n\t\tsetTimeout(function() {\n\t\t\tif ( config.current && config.current.semaphore > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( config.timeout ) {\n\t\t\t\tclearTimeout( config.timeout );\n\t\t\t}\n\n\t\t\tbegin();\n\t\t}, 13 );\n\t} else {\n\t\tbegin();\n\t}\n}\n\nfunction done() {\n\tvar runtime, passed;\n\n\tconfig.autorun = true;\n\n\t// Log the last module results\n\tif ( config.previousModule ) {\n\t\trunLoggingCallbacks( \"moduleDone\", {\n\t\t\tname: config.previousModule.name,\n\t\t\ttests: config.previousModule.tests,\n\t\t\tfailed: config.moduleStats.bad,\n\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\ttotal: config.moduleStats.all,\n\t\t\truntime: now() - config.moduleStats.started\n\t\t});\n\t}\n\tdelete config.previousModule;\n\n\truntime = now() - config.started;\n\tpassed = config.stats.all - config.stats.bad;\n\n\trunLoggingCallbacks( \"done\", {\n\t\tfailed: config.stats.bad,\n\t\tpassed: passed,\n\t\ttotal: config.stats.all,\n\t\truntime: runtime\n\t});\n}\n\nfunction setHook( module, hookName ) {\n\tif ( module.testEnvironment === undefined ) {\n\t\tmodule.testEnvironment = {};\n\t}\n\n\treturn function( callback ) {\n\t\tmodule.testEnvironment[ hookName ] = callback;\n\t};\n}\n\nvar focused = false;\n\nfunction Test( settings ) {\n\tvar i, l;\n\n\t++Test.count;\n\n\textend( this, settings );\n\tthis.assertions = [];\n\tthis.semaphore = 0;\n\tthis.usedAsync = false;\n\tthis.module = config.currentModule;\n\tthis.stack = sourceFromStacktrace( 3 );\n\n\t// Register unique strings\n\tfor ( i = 0, l = this.module.tests; i < l.length; i++ ) {\n\t\tif ( this.module.tests[ i ].name === this.testName ) {\n\t\t\tthis.testName += \" \";\n\t\t}\n\t}\n\n\tthis.testId = generateHash( this.module.name, this.testName );\n\n\tthis.module.tests.push({\n\t\tname: this.testName,\n\t\ttestId: this.testId\n\t});\n\n\tif ( settings.skip ) {\n\n\t\t// Skipped tests will fully ignore any sent callback\n\t\tthis.callback = function() {};\n\t\tthis.async = false;\n\t\tthis.expected = 0;\n\t} else {\n\t\tthis.assert = new Assert( this );\n\t}\n}\n\nTest.count = 0;\n\nTest.prototype = {\n\tbefore: function() {\n\t\tif (\n\n\t\t\t// Emit moduleStart when we're switching from one module to another\n\t\t\tthis.module !== config.previousModule ||\n\n\t\t\t\t// They could be equal (both undefined) but if the previousModule property doesn't\n\t\t\t\t// yet exist it means this is the first test in a suite that isn't wrapped in a\n\t\t\t\t// module, in which case we'll just emit a moduleStart event for 'undefined'.\n\t\t\t\t// Without this, reporters can get testStart before moduleStart  which is a problem.\n\t\t\t\t!hasOwn.call( config, \"previousModule\" )\n\t\t) {\n\t\t\tif ( hasOwn.call( config, \"previousModule\" ) ) {\n\t\t\t\trunLoggingCallbacks( \"moduleDone\", {\n\t\t\t\t\tname: config.previousModule.name,\n\t\t\t\t\ttests: config.previousModule.tests,\n\t\t\t\t\tfailed: config.moduleStats.bad,\n\t\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\t\t\ttotal: config.moduleStats.all,\n\t\t\t\t\truntime: now() - config.moduleStats.started\n\t\t\t\t});\n\t\t\t}\n\t\t\tconfig.previousModule = this.module;\n\t\t\tconfig.moduleStats = { all: 0, bad: 0, started: now() };\n\t\t\trunLoggingCallbacks( \"moduleStart\", {\n\t\t\t\tname: this.module.name,\n\t\t\t\ttests: this.module.tests\n\t\t\t});\n\t\t}\n\n\t\tconfig.current = this;\n\n\t\tif ( this.module.testEnvironment ) {\n\t\t\tdelete this.module.testEnvironment.beforeEach;\n\t\t\tdelete this.module.testEnvironment.afterEach;\n\t\t}\n\t\tthis.testEnvironment = extend( {}, this.module.testEnvironment );\n\n\t\tthis.started = now();\n\t\trunLoggingCallbacks( \"testStart\", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module.name,\n\t\t\ttestId: this.testId\n\t\t});\n\n\t\tif ( !config.pollution ) {\n\t\t\tsaveGlobal();\n\t\t}\n\t},\n\n\trun: function() {\n\t\tvar promise;\n\n\t\tconfig.current = this;\n\n\t\tif ( this.async ) {\n\t\t\tQUnit.stop();\n\t\t}\n\n\t\tthis.callbackStarted = now();\n\n\t\tif ( config.notrycatch ) {\n\t\t\trunTest( this );\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\trunTest( this );\n\t\t} catch ( e ) {\n\t\t\tthis.pushFailure( \"Died on test #\" + ( this.assertions.length + 1 ) + \" \" +\n\t\t\t\tthis.stack + \": \" + ( e.message || e ), extractStacktrace( e, 0 ) );\n\n\t\t\t// else next test will carry the responsibility\n\t\t\tsaveGlobal();\n\n\t\t\t// Restart the tests if they're blocking\n\t\t\tif ( config.blocking ) {\n\t\t\t\tQUnit.start();\n\t\t\t}\n\t\t}\n\n\t\tfunction runTest( test ) {\n\t\t\tpromise = test.callback.call( test.testEnvironment, test.assert );\n\t\t\ttest.resolvePromise( promise );\n\t\t}\n\t},\n\n\tafter: function() {\n\t\tcheckPollution();\n\t},\n\n\tqueueHook: function( hook, hookName ) {\n\t\tvar promise,\n\t\t\ttest = this;\n\t\treturn function runHook() {\n\t\t\tconfig.current = test;\n\t\t\tif ( config.notrycatch ) {\n\t\t\t\tcallHook();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tcallHook();\n\t\t\t} catch ( error ) {\n\t\t\t\ttest.pushFailure( hookName + \" failed on \" + test.testName + \": \" +\n\t\t\t\t( error.message || error ), extractStacktrace( error, 0 ) );\n\t\t\t}\n\n\t\t\tfunction callHook() {\n\t\t\t\tpromise = hook.call( test.testEnvironment, test.assert );\n\t\t\t\ttest.resolvePromise( promise, hookName );\n\t\t\t}\n\t\t};\n\t},\n\n\t// Currently only used for module level hooks, can be used to add global level ones\n\thooks: function( handler ) {\n\t\tvar hooks = [];\n\n\t\tfunction processHooks( test, module ) {\n\t\t\tif ( module.parentModule ) {\n\t\t\t\tprocessHooks( test, module.parentModule );\n\t\t\t}\n\t\t\tif ( module.testEnvironment &&\n\t\t\t\tQUnit.objectType( module.testEnvironment[ handler ] ) === \"function\" ) {\n\t\t\t\thooks.push( test.queueHook( module.testEnvironment[ handler ], handler ) );\n\t\t\t}\n\t\t}\n\n\t\t// Hooks are ignored on skipped tests\n\t\tif ( !this.skip ) {\n\t\t\tprocessHooks( this, this.module );\n\t\t}\n\t\treturn hooks;\n\t},\n\n\tfinish: function() {\n\t\tconfig.current = this;\n\t\tif ( config.requireExpects && this.expected === null ) {\n\t\t\tthis.pushFailure( \"Expected number of assertions to be defined, but expect() was \" +\n\t\t\t\t\"not called.\", this.stack );\n\t\t} else if ( this.expected !== null && this.expected !== this.assertions.length ) {\n\t\t\tthis.pushFailure( \"Expected \" + this.expected + \" assertions, but \" +\n\t\t\t\tthis.assertions.length + \" were run\", this.stack );\n\t\t} else if ( this.expected === null && !this.assertions.length ) {\n\t\t\tthis.pushFailure( \"Expected at least one assertion, but none were run - call \" +\n\t\t\t\t\"expect(0) to accept zero assertions.\", this.stack );\n\t\t}\n\n\t\tvar i,\n\t\t\tbad = 0;\n\n\t\tthis.runtime = now() - this.started;\n\t\tconfig.stats.all += this.assertions.length;\n\t\tconfig.moduleStats.all += this.assertions.length;\n\n\t\tfor ( i = 0; i < this.assertions.length; i++ ) {\n\t\t\tif ( !this.assertions[ i ].result ) {\n\t\t\t\tbad++;\n\t\t\t\tconfig.stats.bad++;\n\t\t\t\tconfig.moduleStats.bad++;\n\t\t\t}\n\t\t}\n\n\t\trunLoggingCallbacks( \"testDone\", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module.name,\n\t\t\tskipped: !!this.skip,\n\t\t\tfailed: bad,\n\t\t\tpassed: this.assertions.length - bad,\n\t\t\ttotal: this.assertions.length,\n\t\t\truntime: this.runtime,\n\n\t\t\t// HTML Reporter use\n\t\t\tassertions: this.assertions,\n\t\t\ttestId: this.testId,\n\n\t\t\t// Source of Test\n\t\t\tsource: this.stack,\n\n\t\t\t// DEPRECATED: this property will be removed in 2.0.0, use runtime instead\n\t\t\tduration: this.runtime\n\t\t});\n\n\t\t// QUnit.reset() is deprecated and will be replaced for a new\n\t\t// fixture reset function on QUnit 2.0/2.1.\n\t\t// It's still called here for backwards compatibility handling\n\t\tQUnit.reset();\n\n\t\tconfig.current = undefined;\n\t},\n\n\tqueue: function() {\n\t\tvar priority,\n\t\t\ttest = this;\n\n\t\tif ( !this.valid() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfunction run() {\n\n\t\t\t// each of these can by async\n\t\t\tsynchronize([\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.before();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( \"beforeEach\" ),\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.run();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( \"afterEach\" ).reverse(),\n\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.after();\n\t\t\t\t},\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.finish();\n\t\t\t\t}\n\t\t\t]);\n\t\t}\n\n\t\t// Prioritize previously failed tests, detected from sessionStorage\n\t\tpriority = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t\t+sessionStorage.getItem( \"qunit-test-\" + this.module.name + \"-\" + this.testName );\n\n\t\treturn synchronize( run, priority );\n\t},\n\n\tpush: function( result, actual, expected, message, negative ) {\n\t\tvar source,\n\t\t\tdetails = {\n\t\t\t\tmodule: this.module.name,\n\t\t\t\tname: this.testName,\n\t\t\t\tresult: result,\n\t\t\t\tmessage: message,\n\t\t\t\tactual: actual,\n\t\t\t\texpected: expected,\n\t\t\t\ttestId: this.testId,\n\t\t\t\tnegative: negative || false,\n\t\t\t\truntime: now() - this.started\n\t\t\t};\n\n\t\tif ( !result ) {\n\t\t\tsource = sourceFromStacktrace();\n\n\t\t\tif ( source ) {\n\t\t\t\tdetails.source = source;\n\t\t\t}\n\t\t}\n\n\t\trunLoggingCallbacks( \"log\", details );\n\n\t\tthis.assertions.push({\n\t\t\tresult: !!result,\n\t\t\tmessage: message\n\t\t});\n\t},\n\n\tpushFailure: function( message, source, actual ) {\n\t\tif ( !( this instanceof Test ) ) {\n\t\t\tthrow new Error( \"pushFailure() assertion outside test context, was \" +\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t}\n\n\t\tvar details = {\n\t\t\t\tmodule: this.module.name,\n\t\t\t\tname: this.testName,\n\t\t\t\tresult: false,\n\t\t\t\tmessage: message || \"error\",\n\t\t\t\tactual: actual || null,\n\t\t\t\ttestId: this.testId,\n\t\t\t\truntime: now() - this.started\n\t\t\t};\n\n\t\tif ( source ) {\n\t\t\tdetails.source = source;\n\t\t}\n\n\t\trunLoggingCallbacks( \"log\", details );\n\n\t\tthis.assertions.push({\n\t\t\tresult: false,\n\t\t\tmessage: message\n\t\t});\n\t},\n\n\tresolvePromise: function( promise, phase ) {\n\t\tvar then, message,\n\t\t\ttest = this;\n\t\tif ( promise != null ) {\n\t\t\tthen = promise.then;\n\t\t\tif ( QUnit.objectType( then ) === \"function\" ) {\n\t\t\t\tQUnit.stop();\n\t\t\t\tthen.call(\n\t\t\t\t\tpromise,\n\t\t\t\t\tfunction() { QUnit.start(); },\n\t\t\t\t\tfunction( error ) {\n\t\t\t\t\t\tmessage = \"Promise rejected \" +\n\t\t\t\t\t\t\t( !phase ? \"during\" : phase.replace( /Each$/, \"\" ) ) +\n\t\t\t\t\t\t\t\" \" + test.testName + \": \" + ( error.message || error );\n\t\t\t\t\t\ttest.pushFailure( message, extractStacktrace( error, 0 ) );\n\n\t\t\t\t\t\t// else next test will carry the responsibility\n\t\t\t\t\t\tsaveGlobal();\n\n\t\t\t\t\t\t// Unblock\n\t\t\t\t\t\tQUnit.start();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t},\n\n\tvalid: function() {\n\t\tvar include,\n\t\t\tfilter = config.filter && config.filter.toLowerCase(),\n\t\t\tmodule = QUnit.urlParams.module && QUnit.urlParams.module.toLowerCase(),\n\t\t\tfullName = ( this.module.name + \": \" + this.testName ).toLowerCase();\n\n\t\tfunction testInModuleChain( testModule ) {\n\t\t\tvar testModuleName = testModule.name ? testModule.name.toLowerCase() : null;\n\t\t\tif ( testModuleName === module ) {\n\t\t\t\treturn true;\n\t\t\t} else if ( testModule.parentModule ) {\n\t\t\t\treturn testInModuleChain( testModule.parentModule );\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Internally-generated tests are always valid\n\t\tif ( this.callback && this.callback.validTest ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( config.testId.length > 0 && inArray( this.testId, config.testId ) < 0 ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( module && !testInModuleChain( this.module ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( !filter ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tinclude = filter.charAt( 0 ) !== \"!\";\n\t\tif ( !include ) {\n\t\t\tfilter = filter.slice( 1 );\n\t\t}\n\n\t\t// If the filter matches, we need to honour include\n\t\tif ( fullName.indexOf( filter ) !== -1 ) {\n\t\t\treturn include;\n\t\t}\n\n\t\t// Otherwise, do the opposite\n\t\treturn !include;\n\t}\n};\n\n// Resets the test setup. Useful for tests that modify the DOM.\n/*\nDEPRECATED: Use multiple tests instead of resetting inside a test.\nUse testStart or testDone for custom cleanup.\nThis method will throw an error in 2.0, and will be removed in 2.1\n*/\nQUnit.reset = function() {\n\n\t// Return on non-browser environments\n\t// This is necessary to not break on node tests\n\tif ( !defined.document ) {\n\t\treturn;\n\t}\n\n\tvar fixture = defined.document && document.getElementById &&\n\t\t\tdocument.getElementById( \"qunit-fixture\" );\n\n\tif ( fixture ) {\n\t\tfixture.innerHTML = config.fixture;\n\t}\n};\n\nQUnit.pushFailure = function() {\n\tif ( !QUnit.config.current ) {\n\t\tthrow new Error( \"pushFailure() assertion outside test context, in \" +\n\t\t\tsourceFromStacktrace( 2 ) );\n\t}\n\n\t// Gets current test obj\n\tvar currentTest = QUnit.config.current;\n\n\treturn currentTest.pushFailure.apply( currentTest, arguments );\n};\n\n// Based on Java's String.hashCode, a simple but not\n// rigorously collision resistant hashing function\nfunction generateHash( module, testName ) {\n\tvar hex,\n\t\ti = 0,\n\t\thash = 0,\n\t\tstr = module + \"\\x1C\" + testName,\n\t\tlen = str.length;\n\n\tfor ( ; i < len; i++ ) {\n\t\thash  = ( ( hash << 5 ) - hash ) + str.charCodeAt( i );\n\t\thash |= 0;\n\t}\n\n\t// Convert the possibly negative integer hash code into an 8 character hex string, which isn't\n\t// strictly necessary but increases user understanding that the id is a SHA-like hash\n\thex = ( 0x100000000 + hash ).toString( 16 );\n\tif ( hex.length < 8 ) {\n\t\thex = \"0000000\" + hex;\n\t}\n\n\treturn hex.slice( -8 );\n}\n\nfunction synchronize( callback, priority ) {\n\tvar last = !priority;\n\n\tif ( QUnit.objectType( callback ) === \"array\" ) {\n\t\twhile ( callback.length ) {\n\t\t\tsynchronize( callback.shift() );\n\t\t}\n\t\treturn;\n\t}\n\n\tif ( priority ) {\n\t\tpriorityFill( callback );\n\t} else {\n\t\tconfig.queue.push( callback );\n\t}\n\n\tif ( config.autorun && !config.blocking ) {\n\t\tprocess( last );\n\t}\n}\n\n// Place previously failed tests on a queue priority line, respecting the order they get assigned.\nfunction priorityFill( callback ) {\n\tvar queue, prioritizedQueue;\n\n\tqueue = config.queue.slice( priorityFill.pos );\n\tprioritizedQueue = config.queue.slice( 0, -config.queue.length + priorityFill.pos );\n\n\tqueue.unshift( callback );\n\tqueue.unshift.apply( queue, prioritizedQueue );\n\n\tconfig.queue = queue;\n\n\tpriorityFill.pos += 1;\n}\npriorityFill.pos = 0;\n\nfunction saveGlobal() {\n\tconfig.pollution = [];\n\n\tif ( config.noglobals ) {\n\t\tfor ( var key in global ) {\n\t\t\tif ( hasOwn.call( global, key ) ) {\n\n\t\t\t\t// in Opera sometimes DOM element ids show up here, ignore them\n\t\t\t\tif ( /^qunit-test-output/.test( key ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconfig.pollution.push( key );\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction checkPollution() {\n\tvar newGlobals,\n\t\tdeletedGlobals,\n\t\told = config.pollution;\n\n\tsaveGlobal();\n\n\tnewGlobals = diff( config.pollution, old );\n\tif ( newGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( \"Introduced global variable(s): \" + newGlobals.join( \", \" ) );\n\t}\n\n\tdeletedGlobals = diff( old, config.pollution );\n\tif ( deletedGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( \"Deleted global variable(s): \" + deletedGlobals.join( \", \" ) );\n\t}\n}\n\n// Will be exposed as QUnit.asyncTest\nfunction asyncTest( testName, expected, callback ) {\n\tif ( arguments.length === 2 ) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tQUnit.test( testName, expected, callback, true );\n}\n\n// Will be exposed as QUnit.test\nfunction test( testName, expected, callback, async ) {\n\tif ( focused )  { return; }\n\n\tvar newTest;\n\n\tif ( arguments.length === 2 ) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tnewTest = new Test({\n\t\ttestName: testName,\n\t\texpected: expected,\n\t\tasync: async,\n\t\tcallback: callback\n\t});\n\n\tnewTest.queue();\n}\n\n// Will be exposed as QUnit.skip\nfunction skip( testName ) {\n\tif ( focused )  { return; }\n\n\tvar test = new Test({\n\t\ttestName: testName,\n\t\tskip: true\n\t});\n\n\ttest.queue();\n}\n\n// Will be exposed as QUnit.only\nfunction only( testName, expected, callback, async ) {\n\tvar newTest;\n\n\tif ( focused )  { return; }\n\n\tQUnit.config.queue.length = 0;\n\tfocused = true;\n\n\tif ( arguments.length === 2 ) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tnewTest = new Test({\n\t\ttestName: testName,\n\t\texpected: expected,\n\t\tasync: async,\n\t\tcallback: callback\n\t});\n\n\tnewTest.queue();\n}\n\nfunction Assert( testContext ) {\n\tthis.test = testContext;\n}\n\n// Assert helpers\nQUnit.assert = Assert.prototype = {\n\n\t// Specify the number of expected assertions to guarantee that failed test\n\t// (no assertions are run at all) don't slip through.\n\texpect: function( asserts ) {\n\t\tif ( arguments.length === 1 ) {\n\t\t\tthis.test.expected = asserts;\n\t\t} else {\n\t\t\treturn this.test.expected;\n\t\t}\n\t},\n\n\t// Increment this Test's semaphore counter, then return a function that\n\t// decrements that counter a maximum of once.\n\tasync: function( count ) {\n\t\tvar test = this.test,\n\t\t\tpopped = false,\n\t\t\tacceptCallCount = count;\n\n\t\tif ( typeof acceptCallCount === \"undefined\" ) {\n\t\t\tacceptCallCount = 1;\n\t\t}\n\n\t\ttest.semaphore += 1;\n\t\ttest.usedAsync = true;\n\t\tpauseProcessing();\n\n\t\treturn function done() {\n\n\t\t\tif ( popped ) {\n\t\t\t\ttest.pushFailure( \"Too many calls to the `assert.async` callback\",\n\t\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tacceptCallCount -= 1;\n\t\t\tif ( acceptCallCount > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttest.semaphore -= 1;\n\t\t\tpopped = true;\n\t\t\tresumeProcessing();\n\t\t};\n\t},\n\n\t// Exports test.push() to the user API\n\tpush: function( /* result, actual, expected, message, negative */ ) {\n\t\tvar assert = this,\n\t\t\tcurrentTest = ( assert instanceof Assert && assert.test ) || QUnit.config.current;\n\n\t\t// Backwards compatibility fix.\n\t\t// Allows the direct use of global exported assertions and QUnit.assert.*\n\t\t// Although, it's use is not recommended as it can leak assertions\n\t\t// to other tests from async tests, because we only get a reference to the current test,\n\t\t// not exactly the test where assertion were intended to be called.\n\t\tif ( !currentTest ) {\n\t\t\tthrow new Error( \"assertion outside test context, in \" + sourceFromStacktrace( 2 ) );\n\t\t}\n\n\t\tif ( currentTest.usedAsync === true && currentTest.semaphore === 0 ) {\n\t\t\tcurrentTest.pushFailure( \"Assertion after the final `assert.async` was resolved\",\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\n\t\t\t// Allow this assertion to continue running anyway...\n\t\t}\n\n\t\tif ( !( assert instanceof Assert ) ) {\n\t\t\tassert = currentTest.assert;\n\t\t}\n\t\treturn assert.test.push.apply( assert.test, arguments );\n\t},\n\n\tok: function( result, message ) {\n\t\tmessage = message || ( result ? \"okay\" : \"failed, expected argument to be truthy, was: \" +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tthis.push( !!result, result, true, message );\n\t},\n\n\tnotOk: function( result, message ) {\n\t\tmessage = message || ( !result ? \"okay\" : \"failed, expected argument to be falsy, was: \" +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tthis.push( !result, result, false, message, true );\n\t},\n\n\tequal: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.push( expected == actual, actual, expected, message );\n\t},\n\n\tnotEqual: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.push( expected != actual, actual, expected, message, true );\n\t},\n\n\tpropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.push( QUnit.equiv( actual, expected ), actual, expected, message );\n\t},\n\n\tnotPropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.push( !QUnit.equiv( actual, expected ), actual, expected, message, true );\n\t},\n\n\tdeepEqual: function( actual, expected, message ) {\n\t\tthis.push( QUnit.equiv( actual, expected ), actual, expected, message );\n\t},\n\n\tnotDeepEqual: function( actual, expected, message ) {\n\t\tthis.push( !QUnit.equiv( actual, expected ), actual, expected, message, true );\n\t},\n\n\tstrictEqual: function( actual, expected, message ) {\n\t\tthis.push( expected === actual, actual, expected, message );\n\t},\n\n\tnotStrictEqual: function( actual, expected, message ) {\n\t\tthis.push( expected !== actual, actual, expected, message, true );\n\t},\n\n\t\"throws\": function( block, expected, message ) {\n\t\tvar actual, expectedType,\n\t\t\texpectedOutput = expected,\n\t\t\tok = false,\n\t\t\tcurrentTest = ( this instanceof Assert && this.test ) || QUnit.config.current;\n\n\t\t// 'expected' is optional unless doing string comparison\n\t\tif ( message == null && typeof expected === \"string\" ) {\n\t\t\tmessage = expected;\n\t\t\texpected = null;\n\t\t}\n\n\t\tcurrentTest.ignoreGlobalErrors = true;\n\t\ttry {\n\t\t\tblock.call( currentTest.testEnvironment );\n\t\t} catch (e) {\n\t\t\tactual = e;\n\t\t}\n\t\tcurrentTest.ignoreGlobalErrors = false;\n\n\t\tif ( actual ) {\n\t\t\texpectedType = QUnit.objectType( expected );\n\n\t\t\t// we don't want to validate thrown error\n\t\t\tif ( !expected ) {\n\t\t\t\tok = true;\n\t\t\t\texpectedOutput = null;\n\n\t\t\t// expected is a regexp\n\t\t\t} else if ( expectedType === \"regexp\" ) {\n\t\t\t\tok = expected.test( errorString( actual ) );\n\n\t\t\t// expected is a string\n\t\t\t} else if ( expectedType === \"string\" ) {\n\t\t\t\tok = expected === errorString( actual );\n\n\t\t\t// expected is a constructor, maybe an Error constructor\n\t\t\t} else if ( expectedType === \"function\" && actual instanceof expected ) {\n\t\t\t\tok = true;\n\n\t\t\t// expected is an Error object\n\t\t\t} else if ( expectedType === \"object\" ) {\n\t\t\t\tok = actual instanceof expected.constructor &&\n\t\t\t\t\tactual.name === expected.name &&\n\t\t\t\t\tactual.message === expected.message;\n\n\t\t\t// expected is a validation function which returns true if validation passed\n\t\t\t} else if ( expectedType === \"function\" && expected.call( {}, actual ) === true ) {\n\t\t\t\texpectedOutput = null;\n\t\t\t\tok = true;\n\t\t\t}\n\t\t}\n\n\t\tcurrentTest.assert.push( ok, actual, expectedOutput, message );\n\t}\n};\n\n// Provide an alternative to assert.throws(), for environments that consider throws a reserved word\n// Known to us are: Closure Compiler, Narwhal\n(function() {\n\t/*jshint sub:true */\n\tAssert.prototype.raises = Assert.prototype[ \"throws\" ];\n}());\n\nfunction errorString( error ) {\n\tvar name, message,\n\t\tresultErrorString = error.toString();\n\tif ( resultErrorString.substring( 0, 7 ) === \"[object\" ) {\n\t\tname = error.name ? error.name.toString() : \"Error\";\n\t\tmessage = error.message ? error.message.toString() : \"\";\n\t\tif ( name && message ) {\n\t\t\treturn name + \": \" + message;\n\t\t} else if ( name ) {\n\t\t\treturn name;\n\t\t} else if ( message ) {\n\t\t\treturn message;\n\t\t} else {\n\t\t\treturn \"Error\";\n\t\t}\n\t} else {\n\t\treturn resultErrorString;\n\t}\n}\n\n// Test for equality any JavaScript type.\n// Author: Philippe Rath√© <prathe@gmail.com>\nQUnit.equiv = (function() {\n\n\t// Stack to decide between skip/abort functions\n\tvar callers = [];\n\n\t// Stack to avoiding loops from circular referencing\n\tvar parents = [];\n\tvar parentsB = [];\n\n\tfunction useStrictEquality( b, a ) {\n\n\t\t/*jshint eqeqeq:false */\n\t\tif ( b instanceof a.constructor || a instanceof b.constructor ) {\n\n\t\t\t// To catch short annotation VS 'new' annotation of a declaration. e.g.:\n\t\t\t// `var i = 1;`\n\t\t\t// `var j = new Number(1);`\n\t\t\treturn a == b;\n\t\t} else {\n\t\t\treturn a === b;\n\t\t}\n\t}\n\n\tfunction compareConstructors( a, b ) {\n\t\tvar getProto = Object.getPrototypeOf || function( obj ) {\n\n\t\t\t/*jshint proto: true */\n\t\t\treturn obj.__proto__;\n\t\t};\n\t\tvar protoA = getProto( a );\n\t\tvar protoB = getProto( b );\n\n\t\t// Comparing constructors is more strict than using `instanceof`\n\t\tif ( a.constructor === b.constructor ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Ref #851\n\t\t// If the obj prototype descends from a null constructor, treat it\n\t\t// as a null prototype.\n\t\tif ( protoA && protoA.constructor === null ) {\n\t\t\tprotoA = null;\n\t\t}\n\t\tif ( protoB && protoB.constructor === null ) {\n\t\t\tprotoB = null;\n\t\t}\n\n\t\t// Allow objects with no prototype to be equivalent to\n\t\t// objects with Object as their constructor.\n\t\tif ( ( protoA === null && protoB === Object.prototype ) ||\n\t\t\t\t( protoB === null && protoA === Object.prototype ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tvar callbacks = {\n\t\t\"string\": useStrictEquality,\n\t\t\"boolean\": useStrictEquality,\n\t\t\"number\": useStrictEquality,\n\t\t\"null\": useStrictEquality,\n\t\t\"undefined\": useStrictEquality,\n\t\t\"symbol\": useStrictEquality,\n\n\t\t\"nan\": function( b ) {\n\t\t\treturn isNaN( b );\n\t\t},\n\n\t\t\"date\": function( b, a ) {\n\t\t\treturn QUnit.objectType( b ) === \"date\" && a.valueOf() === b.valueOf();\n\t\t},\n\n\t\t\"regexp\": function( b, a ) {\n\t\t\treturn QUnit.objectType( b ) === \"regexp\" &&\n\n\t\t\t\t// The regex itself\n\t\t\t\ta.source === b.source &&\n\n\t\t\t\t// And its modifiers\n\t\t\t\ta.global === b.global &&\n\n\t\t\t\t// (gmi) ...\n\t\t\t\ta.ignoreCase === b.ignoreCase &&\n\t\t\t\ta.multiline === b.multiline &&\n\t\t\t\ta.sticky === b.sticky;\n\t\t},\n\n\t\t// - skip when the property is a method of an instance (OOP)\n\t\t// - abort otherwise,\n\t\t// initial === would have catch identical references anyway\n\t\t\"function\": function() {\n\t\t\tvar caller = callers[ callers.length - 1 ];\n\t\t\treturn caller !== Object && typeof caller !== \"undefined\";\n\t\t},\n\n\t\t\"array\": function( b, a ) {\n\t\t\tvar i, j, len, loop, aCircular, bCircular;\n\n\t\t\t// b could be an object literal here\n\t\t\tif ( QUnit.objectType( b ) !== \"array\" ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlen = a.length;\n\t\t\tif ( len !== b.length ) {\n\t\t\t\t// safe and faster\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Track reference to avoid circular references\n\t\t\tparents.push( a );\n\t\t\tparentsB.push( b );\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\tloop = false;\n\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\tparents.pop();\n\t\t\t\t\tparentsB.pop();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparents.pop();\n\t\t\tparentsB.pop();\n\t\t\treturn true;\n\t\t},\n\n\t\t\"set\": function( b, a ) {\n\t\t\tvar aArray, bArray;\n\n\t\t\t// `b` could be any object here\n\t\t\tif ( QUnit.objectType( b ) !== \"set\" ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\taArray = [];\n\t\t\ta.forEach( function( v ) {\n\t\t\t\taArray.push( v );\n\t\t\t});\n\t\t\tbArray = [];\n\t\t\tb.forEach( function( v ) {\n\t\t\t\tbArray.push( v );\n\t\t\t});\n\n\t\t\treturn innerEquiv( bArray, aArray );\n\t\t},\n\n\t\t\"map\": function( b, a ) {\n\t\t\tvar aArray, bArray;\n\n\t\t\t// `b` could be any object here\n\t\t\tif ( QUnit.objectType( b ) !== \"map\" ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\taArray = [];\n\t\t\ta.forEach( function( v, k ) {\n\t\t\t\taArray.push( [ k, v ] );\n\t\t\t});\n\t\t\tbArray = [];\n\t\t\tb.forEach( function( v, k ) {\n\t\t\t\tbArray.push( [ k, v ] );\n\t\t\t});\n\n\t\t\treturn innerEquiv( bArray, aArray );\n\t\t},\n\n\t\t\"object\": function( b, a ) {\n\t\t\tvar i, j, loop, aCircular, bCircular;\n\n\t\t\t// Default to true\n\t\t\tvar eq = true;\n\t\t\tvar aProperties = [];\n\t\t\tvar bProperties = [];\n\n\t\t\tif ( compareConstructors( a, b ) === false ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Stack constructor before traversing properties\n\t\t\tcallers.push( a.constructor );\n\n\t\t\t// Track reference to avoid circular references\n\t\t\tparents.push( a );\n\t\t\tparentsB.push( b );\n\n\t\t\t// Be strict: don't ensure hasOwnProperty and go deep\n\t\t\tfor ( i in a ) {\n\t\t\t\tloop = false;\n\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taProperties.push( i );\n\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\teq = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparents.pop();\n\t\t\tparentsB.pop();\n\n\t\t\t// Unstack, we are done\n\t\t\tcallers.pop();\n\n\t\t\tfor ( i in b ) {\n\n\t\t\t\t// Collect b's properties\n\t\t\t\tbProperties.push( i );\n\t\t\t}\n\n\t\t\t// Ensures identical properties name\n\t\t\treturn eq && innerEquiv( aProperties.sort(), bProperties.sort() );\n\t\t}\n\t};\n\n\tfunction typeEquiv( a, b ) {\n\t\tvar prop = QUnit.objectType( a );\n\t\treturn callbacks[ prop ]( b, a );\n\t}\n\n\t// The real equiv function\n\tfunction innerEquiv() {\n\t\tvar args = [].slice.apply( arguments );\n\t\tif ( args.length < 2 ) {\n\n\t\t\t// End transition\n\t\t\treturn true;\n\t\t}\n\n\t\treturn ( (function( a, b ) {\n\t\t\tif ( a === b ) {\n\n\t\t\t\t// Catch the most you can\n\t\t\t\treturn true;\n\t\t\t} else if ( a === null || b === null || typeof a === \"undefined\" ||\n\t\t\t\t\ttypeof b === \"undefined\" ||\n\t\t\t\t\tQUnit.objectType( a ) !== QUnit.objectType( b ) ) {\n\n\t\t\t\t// Don't lose time with error prone cases\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn typeEquiv( a, b );\n\t\t\t}\n\n\t\t// Apply transition with (1..n) arguments\n\t\t}( args[ 0 ], args[ 1 ] ) ) &&\n\t\t\tinnerEquiv.apply( this, args.splice( 1, args.length - 1 ) ) );\n\t}\n\n\treturn innerEquiv;\n}());\n\n// Based on jsDump by Ariel Flesler\n// http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html\nQUnit.dump = (function() {\n\tfunction quote( str ) {\n\t\treturn \"\\\"\" + str.toString().replace( /\\\\/g, \"\\\\\\\\\" ).replace( /\"/g, \"\\\\\\\"\" ) + \"\\\"\";\n\t}\n\tfunction literal( o ) {\n\t\treturn o + \"\";\n\t}\n\tfunction join( pre, arr, post ) {\n\t\tvar s = dump.separator(),\n\t\t\tbase = dump.indent(),\n\t\t\tinner = dump.indent( 1 );\n\t\tif ( arr.join ) {\n\t\t\tarr = arr.join( \",\" + s + inner );\n\t\t}\n\t\tif ( !arr ) {\n\t\t\treturn pre + post;\n\t\t}\n\t\treturn [ pre, inner + arr, base + post ].join( s );\n\t}\n\tfunction array( arr, stack ) {\n\t\tvar i = arr.length,\n\t\t\tret = new Array( i );\n\n\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {\n\t\t\treturn \"[object Array]\";\n\t\t}\n\n\t\tthis.up();\n\t\twhile ( i-- ) {\n\t\t\tret[ i ] = this.parse( arr[ i ], undefined, stack );\n\t\t}\n\t\tthis.down();\n\t\treturn join( \"[\", ret, \"]\" );\n\t}\n\n\tvar reName = /^function (\\w+)/,\n\t\tdump = {\n\n\t\t\t// objType is used mostly internally, you can fix a (custom) type in advance\n\t\t\tparse: function( obj, objType, stack ) {\n\t\t\t\tstack = stack || [];\n\t\t\t\tvar res, parser, parserType,\n\t\t\t\t\tinStack = inArray( obj, stack );\n\n\t\t\t\tif ( inStack !== -1 ) {\n\t\t\t\t\treturn \"recursion(\" + ( inStack - stack.length ) + \")\";\n\t\t\t\t}\n\n\t\t\t\tobjType = objType || this.typeOf( obj  );\n\t\t\t\tparser = this.parsers[ objType ];\n\t\t\t\tparserType = typeof parser;\n\n\t\t\t\tif ( parserType === \"function\" ) {\n\t\t\t\t\tstack.push( obj );\n\t\t\t\t\tres = parser.call( this, obj, stack );\n\t\t\t\t\tstack.pop();\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\treturn ( parserType === \"string\" ) ? parser : this.parsers.error;\n\t\t\t},\n\t\t\ttypeOf: function( obj ) {\n\t\t\t\tvar type;\n\t\t\t\tif ( obj === null ) {\n\t\t\t\t\ttype = \"null\";\n\t\t\t\t} else if ( typeof obj === \"undefined\" ) {\n\t\t\t\t\ttype = \"undefined\";\n\t\t\t\t} else if ( QUnit.is( \"regexp\", obj ) ) {\n\t\t\t\t\ttype = \"regexp\";\n\t\t\t\t} else if ( QUnit.is( \"date\", obj ) ) {\n\t\t\t\t\ttype = \"date\";\n\t\t\t\t} else if ( QUnit.is( \"function\", obj ) ) {\n\t\t\t\t\ttype = \"function\";\n\t\t\t\t} else if ( obj.setInterval !== undefined &&\n\t\t\t\t\t\tobj.document !== undefined &&\n\t\t\t\t\t\tobj.nodeType === undefined ) {\n\t\t\t\t\ttype = \"window\";\n\t\t\t\t} else if ( obj.nodeType === 9 ) {\n\t\t\t\t\ttype = \"document\";\n\t\t\t\t} else if ( obj.nodeType ) {\n\t\t\t\t\ttype = \"node\";\n\t\t\t\t} else if (\n\n\t\t\t\t\t// native arrays\n\t\t\t\t\ttoString.call( obj ) === \"[object Array]\" ||\n\n\t\t\t\t\t// NodeList objects\n\t\t\t\t\t( typeof obj.length === \"number\" && obj.item !== undefined &&\n\t\t\t\t\t( obj.length ? obj.item( 0 ) === obj[ 0 ] : ( obj.item( 0 ) === null &&\n\t\t\t\t\tobj[ 0 ] === undefined ) ) )\n\t\t\t\t) {\n\t\t\t\t\ttype = \"array\";\n\t\t\t\t} else if ( obj.constructor === Error.prototype.constructor ) {\n\t\t\t\t\ttype = \"error\";\n\t\t\t\t} else {\n\t\t\t\t\ttype = typeof obj;\n\t\t\t\t}\n\t\t\t\treturn type;\n\t\t\t},\n\t\t\tseparator: function() {\n\t\t\t\treturn this.multiline ? this.HTML ? \"<br />\" : \"\\n\" : this.HTML ? \"&#160;\" : \" \";\n\t\t\t},\n\t\t\t// extra can be a number, shortcut for increasing-calling-decreasing\n\t\t\tindent: function( extra ) {\n\t\t\t\tif ( !this.multiline ) {\n\t\t\t\t\treturn \"\";\n\t\t\t\t}\n\t\t\t\tvar chr = this.indentChar;\n\t\t\t\tif ( this.HTML ) {\n\t\t\t\t\tchr = chr.replace( /\\t/g, \"   \" ).replace( / /g, \"&#160;\" );\n\t\t\t\t}\n\t\t\t\treturn new Array( this.depth + ( extra || 0 ) ).join( chr );\n\t\t\t},\n\t\t\tup: function( a ) {\n\t\t\t\tthis.depth += a || 1;\n\t\t\t},\n\t\t\tdown: function( a ) {\n\t\t\t\tthis.depth -= a || 1;\n\t\t\t},\n\t\t\tsetParser: function( name, parser ) {\n\t\t\t\tthis.parsers[ name ] = parser;\n\t\t\t},\n\t\t\t// The next 3 are exposed so you can use them\n\t\t\tquote: quote,\n\t\t\tliteral: literal,\n\t\t\tjoin: join,\n\t\t\t//\n\t\t\tdepth: 1,\n\t\t\tmaxDepth: QUnit.config.maxDepth,\n\n\t\t\t// This is the list of parsers, to modify them, use dump.setParser\n\t\t\tparsers: {\n\t\t\t\twindow: \"[Window]\",\n\t\t\t\tdocument: \"[Document]\",\n\t\t\t\terror: function( error ) {\n\t\t\t\t\treturn \"Error(\\\"\" + error.message + \"\\\")\";\n\t\t\t\t},\n\t\t\t\tunknown: \"[Unknown]\",\n\t\t\t\t\"null\": \"null\",\n\t\t\t\t\"undefined\": \"undefined\",\n\t\t\t\t\"function\": function( fn ) {\n\t\t\t\t\tvar ret = \"function\",\n\n\t\t\t\t\t\t// functions never have name in IE\n\t\t\t\t\t\tname = \"name\" in fn ? fn.name : ( reName.exec( fn ) || [] )[ 1 ];\n\n\t\t\t\t\tif ( name ) {\n\t\t\t\t\t\tret += \" \" + name;\n\t\t\t\t\t}\n\t\t\t\t\tret += \"( \";\n\n\t\t\t\t\tret = [ ret, dump.parse( fn, \"functionArgs\" ), \"){\" ].join( \"\" );\n\t\t\t\t\treturn join( ret, dump.parse( fn, \"functionCode\" ), \"}\" );\n\t\t\t\t},\n\t\t\t\tarray: array,\n\t\t\t\tnodelist: array,\n\t\t\t\t\"arguments\": array,\n\t\t\t\tobject: function( map, stack ) {\n\t\t\t\t\tvar keys, key, val, i, nonEnumerableProperties,\n\t\t\t\t\t\tret = [];\n\n\t\t\t\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {\n\t\t\t\t\t\treturn \"[object Object]\";\n\t\t\t\t\t}\n\n\t\t\t\t\tdump.up();\n\t\t\t\t\tkeys = [];\n\t\t\t\t\tfor ( key in map ) {\n\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Some properties are not always enumerable on Error objects.\n\t\t\t\t\tnonEnumerableProperties = [ \"message\", \"name\" ];\n\t\t\t\t\tfor ( i in nonEnumerableProperties ) {\n\t\t\t\t\t\tkey = nonEnumerableProperties[ i ];\n\t\t\t\t\t\tif ( key in map && inArray( key, keys ) < 0 ) {\n\t\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tkeys.sort();\n\t\t\t\t\tfor ( i = 0; i < keys.length; i++ ) {\n\t\t\t\t\t\tkey = keys[ i ];\n\t\t\t\t\t\tval = map[ key ];\n\t\t\t\t\t\tret.push( dump.parse( key, \"key\" ) + \": \" +\n\t\t\t\t\t\t\tdump.parse( val, undefined, stack ) );\n\t\t\t\t\t}\n\t\t\t\t\tdump.down();\n\t\t\t\t\treturn join( \"{\", ret, \"}\" );\n\t\t\t\t},\n\t\t\t\tnode: function( node ) {\n\t\t\t\t\tvar len, i, val,\n\t\t\t\t\t\topen = dump.HTML ? \"&lt;\" : \"<\",\n\t\t\t\t\t\tclose = dump.HTML ? \"&gt;\" : \">\",\n\t\t\t\t\t\ttag = node.nodeName.toLowerCase(),\n\t\t\t\t\t\tret = open + tag,\n\t\t\t\t\t\tattrs = node.attributes;\n\n\t\t\t\t\tif ( attrs ) {\n\t\t\t\t\t\tfor ( i = 0, len = attrs.length; i < len; i++ ) {\n\t\t\t\t\t\t\tval = attrs[ i ].nodeValue;\n\n\t\t\t\t\t\t\t// IE6 includes all attributes in .attributes, even ones not explicitly\n\t\t\t\t\t\t\t// set. Those have values like undefined, null, 0, false, \"\" or\n\t\t\t\t\t\t\t// \"inherit\".\n\t\t\t\t\t\t\tif ( val && val !== \"inherit\" ) {\n\t\t\t\t\t\t\t\tret += \" \" + attrs[ i ].nodeName + \"=\" +\n\t\t\t\t\t\t\t\t\tdump.parse( val, \"attribute\" );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret += close;\n\n\t\t\t\t\t// Show content of TextNode or CDATASection\n\t\t\t\t\tif ( node.nodeType === 3 || node.nodeType === 4 ) {\n\t\t\t\t\t\tret += node.nodeValue;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn ret + open + \"/\" + tag + close;\n\t\t\t\t},\n\n\t\t\t\t// function calls it internally, it's the arguments part of the function\n\t\t\t\tfunctionArgs: function( fn ) {\n\t\t\t\t\tvar args,\n\t\t\t\t\t\tl = fn.length;\n\n\t\t\t\t\tif ( !l ) {\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t}\n\n\t\t\t\t\targs = new Array( l );\n\t\t\t\t\twhile ( l-- ) {\n\n\t\t\t\t\t\t// 97 is 'a'\n\t\t\t\t\t\targs[ l ] = String.fromCharCode( 97 + l );\n\t\t\t\t\t}\n\t\t\t\t\treturn \" \" + args.join( \", \" ) + \" \";\n\t\t\t\t},\n\t\t\t\t// object calls it internally, the key part of an item in a map\n\t\t\t\tkey: quote,\n\t\t\t\t// function calls it internally, it's the content of the function\n\t\t\t\tfunctionCode: \"[code]\",\n\t\t\t\t// node calls it internally, it's an html attribute value\n\t\t\t\tattribute: quote,\n\t\t\t\tstring: quote,\n\t\t\t\tdate: quote,\n\t\t\t\tregexp: literal,\n\t\t\t\tnumber: literal,\n\t\t\t\t\"boolean\": literal\n\t\t\t},\n\t\t\t// if true, entities are escaped ( <, >, \\t, space and \\n )\n\t\t\tHTML: false,\n\t\t\t// indentation unit\n\t\t\tindentChar: \"  \",\n\t\t\t// if true, items in a collection, are separated by a \\n, else just a space.\n\t\t\tmultiline: true\n\t\t};\n\n\treturn dump;\n}());\n\n// back compat\nQUnit.jsDump = QUnit.dump;\n\n// For browser, export only select globals\nif ( defined.document ) {\n\n\t// Deprecated\n\t// Extend assert methods to QUnit and Global scope through Backwards compatibility\n\t(function() {\n\t\tvar i,\n\t\t\tassertions = Assert.prototype;\n\n\t\tfunction applyCurrent( current ) {\n\t\t\treturn function() {\n\t\t\t\tvar assert = new Assert( QUnit.config.current );\n\t\t\t\tcurrent.apply( assert, arguments );\n\t\t\t};\n\t\t}\n\n\t\tfor ( i in assertions ) {\n\t\t\tQUnit[ i ] = applyCurrent( assertions[ i ] );\n\t\t}\n\t})();\n\n\t(function() {\n\t\tvar i, l,\n\t\t\tkeys = [\n\t\t\t\t\"test\",\n\t\t\t\t\"module\",\n\t\t\t\t\"expect\",\n\t\t\t\t\"asyncTest\",\n\t\t\t\t\"start\",\n\t\t\t\t\"stop\",\n\t\t\t\t\"ok\",\n\t\t\t\t\"notOk\",\n\t\t\t\t\"equal\",\n\t\t\t\t\"notEqual\",\n\t\t\t\t\"propEqual\",\n\t\t\t\t\"notPropEqual\",\n\t\t\t\t\"deepEqual\",\n\t\t\t\t\"notDeepEqual\",\n\t\t\t\t\"strictEqual\",\n\t\t\t\t\"notStrictEqual\",\n\t\t\t\t\"throws\",\n\t\t\t\t\"raises\"\n\t\t\t];\n\n\t\tfor ( i = 0, l = keys.length; i < l; i++ ) {\n\t\t\twindow[ keys[ i ] ] = QUnit[ keys[ i ] ];\n\t\t}\n\t})();\n\n\twindow.QUnit = QUnit;\n}\n\n// For nodejs\nif ( typeof module !== \"undefined\" && module && module.exports ) {\n\tmodule.exports = QUnit;\n\n\t// For consistency with CommonJS environments' exports\n\tmodule.exports.QUnit = QUnit;\n}\n\n// For CommonJS with exports, but without module.exports, like Rhino\nif ( typeof exports !== \"undefined\" && exports ) {\n\texports.QUnit = QUnit;\n}\n\nif ( typeof define === \"function\" && define.amd ) {\n\tdefine( function() {\n\t\treturn QUnit;\n\t} );\n\tQUnit.config.autostart = false;\n}\n\n/*\n * This file is a modified version of google-diff-match-patch's JavaScript implementation\n * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),\n * modifications are licensed as more fully set forth in LICENSE.txt.\n *\n * The original source of google-diff-match-patch is attributable and licensed as follows:\n *\n * Copyright 2006 Google Inc.\n * http://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * More Info:\n *  https://code.google.com/p/google-diff-match-patch/\n *\n * Usage: QUnit.diff(expected, actual)\n *\n */\nQUnit.diff = ( function() {\n\tfunction DiffMatchPatch() {\n\t}\n\n\t//  DIFF FUNCTIONS\n\n\t/**\n\t * The data structure representing a diff is an array of tuples:\n\t * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n\t * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n\t */\n\tvar DIFF_DELETE = -1,\n\t\tDIFF_INSERT = 1,\n\t\tDIFF_EQUAL = 0;\n\n\t/**\n\t * Find the differences between two texts.  Simplifies the problem by stripping\n\t * any common prefix or suffix off the texts before diffing.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {boolean=} optChecklines Optional speedup flag. If present and false,\n\t *     then don't run a line-level diff first to identify the changed areas.\n\t *     Defaults to true, which does a faster, slightly less optimal diff.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.DiffMain = function( text1, text2, optChecklines ) {\n\t\tvar deadline, checklines, commonlength,\n\t\t\tcommonprefix, commonsuffix, diffs;\n\n\t\t// The diff must be complete in up to 1 second.\n\t\tdeadline = ( new Date() ).getTime() + 1000;\n\n\t\t// Check for null inputs.\n\t\tif ( text1 === null || text2 === null ) {\n\t\t\tthrow new Error( \"Null input. (DiffMain)\" );\n\t\t}\n\n\t\t// Check for equality (speedup).\n\t\tif ( text1 === text2 ) {\n\t\t\tif ( text1 ) {\n\t\t\t\treturn [\n\t\t\t\t\t[ DIFF_EQUAL, text1 ]\n\t\t\t\t];\n\t\t\t}\n\t\t\treturn [];\n\t\t}\n\n\t\tif ( typeof optChecklines === \"undefined\" ) {\n\t\t\toptChecklines = true;\n\t\t}\n\n\t\tchecklines = optChecklines;\n\n\t\t// Trim off common prefix (speedup).\n\t\tcommonlength = this.diffCommonPrefix( text1, text2 );\n\t\tcommonprefix = text1.substring( 0, commonlength );\n\t\ttext1 = text1.substring( commonlength );\n\t\ttext2 = text2.substring( commonlength );\n\n\t\t// Trim off common suffix (speedup).\n\t\tcommonlength = this.diffCommonSuffix( text1, text2 );\n\t\tcommonsuffix = text1.substring( text1.length - commonlength );\n\t\ttext1 = text1.substring( 0, text1.length - commonlength );\n\t\ttext2 = text2.substring( 0, text2.length - commonlength );\n\n\t\t// Compute the diff on the middle block.\n\t\tdiffs = this.diffCompute( text1, text2, checklines, deadline );\n\n\t\t// Restore the prefix and suffix.\n\t\tif ( commonprefix ) {\n\t\t\tdiffs.unshift( [ DIFF_EQUAL, commonprefix ] );\n\t\t}\n\t\tif ( commonsuffix ) {\n\t\t\tdiffs.push( [ DIFF_EQUAL, commonsuffix ] );\n\t\t}\n\t\tthis.diffCleanupMerge( diffs );\n\t\treturn diffs;\n\t};\n\n\t/**\n\t * Reduce the number of edits by eliminating operationally trivial equalities.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupEfficiency = function( diffs ) {\n\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\tpointer, preIns, preDel, postIns, postDel;\n\t\tchanges = false;\n\t\tequalities = []; // Stack of indices where equalities are found.\n\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t/** @type {?string} */\n\t\tlastequality = null;\n\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\tpointer = 0; // Index of current position.\n\t\t// Is there an insertion operation before the last equality.\n\t\tpreIns = false;\n\t\t// Is there a deletion operation before the last equality.\n\t\tpreDel = false;\n\t\t// Is there an insertion operation after the last equality.\n\t\tpostIns = false;\n\t\t// Is there a deletion operation after the last equality.\n\t\tpostDel = false;\n\t\twhile ( pointer < diffs.length ) {\n\n\t\t\t// Equality found.\n\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) {\n\t\t\t\tif ( diffs[ pointer ][ 1 ].length < 4 && ( postIns || postDel ) ) {\n\n\t\t\t\t\t// Candidate found.\n\t\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\t\tpreIns = postIns;\n\t\t\t\t\tpreDel = postDel;\n\t\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t\t} else {\n\n\t\t\t\t\t// Not a candidate, and can never become one.\n\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t}\n\t\t\t\tpostIns = postDel = false;\n\n\t\t\t// An insertion or deletion.\n\t\t\t} else {\n\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_DELETE ) {\n\t\t\t\t\tpostDel = true;\n\t\t\t\t} else {\n\t\t\t\t\tpostIns = true;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Five types to be split:\n\t\t\t\t * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins>X<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins><del>B</del>X<ins>C</ins>\n\t\t\t\t * <ins>A</del>X<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins><del>B</del>X<del>C</del>\n\t\t\t\t */\n\t\t\t\tif ( lastequality && ( ( preIns && preDel && postIns && postDel ) ||\n\t\t\t\t\t\t( ( lastequality.length < 2 ) &&\n\t\t\t\t\t\t( preIns + preDel + postIns + postDel ) === 3 ) ) ) {\n\n\t\t\t\t\t// Duplicate record.\n\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t);\n\n\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\tequalitiesLength--; // Throw away the equality we just deleted;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t\tif ( preIns && preDel ) {\n\t\t\t\t\t\t// No changes made which could affect previous entry, keep going.\n\t\t\t\t\t\tpostIns = postDel = true;\n\t\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tequalitiesLength--; // Throw away the previous equality.\n\t\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\t\t\t\t\t\tpostIns = postDel = false;\n\t\t\t\t\t}\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\t};\n\n\t/**\n\t * Convert a diff array into a pretty HTML report.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t * @param {integer} string to be beautified.\n\t * @return {string} HTML representation.\n\t */\n\tDiffMatchPatch.prototype.diffPrettyHtml = function( diffs ) {\n\t\tvar op, data, x,\n\t\t\thtml = [];\n\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\top = diffs[ x ][ 0 ]; // Operation (insert, delete, equal)\n\t\t\tdata = diffs[ x ][ 1 ]; // Text of change.\n\t\t\tswitch ( op ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\thtml[ x ] = \"<ins>\" + data + \"</ins>\";\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\thtml[ x ] = \"<del>\" + data + \"</del>\";\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\t\t\t\thtml[ x ] = \"<span>\" + data + \"</span>\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn html.join( \"\" );\n\t};\n\n\t/**\n\t * Determine the common prefix of two strings.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the start of each\n\t *     string.\n\t */\n\tDiffMatchPatch.prototype.diffCommonPrefix = function( text1, text2 ) {\n\t\tvar pointermid, pointermax, pointermin, pointerstart;\n\t\t// Quick check for common null cases.\n\t\tif ( !text1 || !text2 || text1.charAt( 0 ) !== text2.charAt( 0 ) ) {\n\t\t\treturn 0;\n\t\t}\n\t\t// Binary search.\n\t\t// Performance analysis: http://neil.fraser.name/news/2007/10/09/\n\t\tpointermin = 0;\n\t\tpointermax = Math.min( text1.length, text2.length );\n\t\tpointermid = pointermax;\n\t\tpointerstart = 0;\n\t\twhile ( pointermin < pointermid ) {\n\t\t\tif ( text1.substring( pointerstart, pointermid ) ===\n\t\t\t\t\ttext2.substring( pointerstart, pointermid ) ) {\n\t\t\t\tpointermin = pointermid;\n\t\t\t\tpointerstart = pointermin;\n\t\t\t} else {\n\t\t\t\tpointermax = pointermid;\n\t\t\t}\n\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t}\n\t\treturn pointermid;\n\t};\n\n\t/**\n\t * Determine the common suffix of two strings.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the end of each string.\n\t */\n\tDiffMatchPatch.prototype.diffCommonSuffix = function( text1, text2 ) {\n\t\tvar pointermid, pointermax, pointermin, pointerend;\n\t\t// Quick check for common null cases.\n\t\tif ( !text1 ||\n\t\t\t\t!text2 ||\n\t\t\t\ttext1.charAt( text1.length - 1 ) !== text2.charAt( text2.length - 1 ) ) {\n\t\t\treturn 0;\n\t\t}\n\t\t// Binary search.\n\t\t// Performance analysis: http://neil.fraser.name/news/2007/10/09/\n\t\tpointermin = 0;\n\t\tpointermax = Math.min( text1.length, text2.length );\n\t\tpointermid = pointermax;\n\t\tpointerend = 0;\n\t\twhile ( pointermin < pointermid ) {\n\t\t\tif ( text1.substring( text1.length - pointermid, text1.length - pointerend ) ===\n\t\t\t\t\ttext2.substring( text2.length - pointermid, text2.length - pointerend ) ) {\n\t\t\t\tpointermin = pointermid;\n\t\t\t\tpointerend = pointermin;\n\t\t\t} else {\n\t\t\t\tpointermax = pointermid;\n\t\t\t}\n\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t}\n\t\treturn pointermid;\n\t};\n\n\t/**\n\t * Find the differences between two texts.  Assumes that the texts do not\n\t * have any common prefix or suffix.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {boolean} checklines Speedup flag.  If false, then don't run a\n\t *     line-level diff first to identify the changed areas.\n\t *     If true, then run a faster, slightly less optimal diff.\n\t * @param {number} deadline Time when the diff should be complete by.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCompute = function( text1, text2, checklines, deadline ) {\n\t\tvar diffs, longtext, shorttext, i, hm,\n\t\t\ttext1A, text2A, text1B, text2B,\n\t\t\tmidCommon, diffsA, diffsB;\n\n\t\tif ( !text1 ) {\n\t\t\t// Just add some text (speedup).\n\t\t\treturn [\n\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t];\n\t\t}\n\n\t\tif ( !text2 ) {\n\t\t\t// Just delete some text (speedup).\n\t\t\treturn [\n\t\t\t\t[ DIFF_DELETE, text1 ]\n\t\t\t];\n\t\t}\n\n\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\ti = longtext.indexOf( shorttext );\n\t\tif ( i !== -1 ) {\n\t\t\t// Shorter text is inside the longer text (speedup).\n\t\t\tdiffs = [\n\t\t\t\t[ DIFF_INSERT, longtext.substring( 0, i ) ],\n\t\t\t\t[ DIFF_EQUAL, shorttext ],\n\t\t\t\t[ DIFF_INSERT, longtext.substring( i + shorttext.length ) ]\n\t\t\t];\n\t\t\t// Swap insertions for deletions if diff is reversed.\n\t\t\tif ( text1.length > text2.length ) {\n\t\t\t\tdiffs[ 0 ][ 0 ] = diffs[ 2 ][ 0 ] = DIFF_DELETE;\n\t\t\t}\n\t\t\treturn diffs;\n\t\t}\n\n\t\tif ( shorttext.length === 1 ) {\n\t\t\t// Single character string.\n\t\t\t// After the previous speedup, the character can't be an equality.\n\t\t\treturn [\n\t\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t];\n\t\t}\n\n\t\t// Check to see if the problem can be split in two.\n\t\thm = this.diffHalfMatch( text1, text2 );\n\t\tif ( hm ) {\n\t\t\t// A half-match was found, sort out the return data.\n\t\t\ttext1A = hm[ 0 ];\n\t\t\ttext1B = hm[ 1 ];\n\t\t\ttext2A = hm[ 2 ];\n\t\t\ttext2B = hm[ 3 ];\n\t\t\tmidCommon = hm[ 4 ];\n\t\t\t// Send both pairs off for separate processing.\n\t\t\tdiffsA = this.DiffMain( text1A, text2A, checklines, deadline );\n\t\t\tdiffsB = this.DiffMain( text1B, text2B, checklines, deadline );\n\t\t\t// Merge the results.\n\t\t\treturn diffsA.concat( [\n\t\t\t\t[ DIFF_EQUAL, midCommon ]\n\t\t\t], diffsB );\n\t\t}\n\n\t\tif ( checklines && text1.length > 100 && text2.length > 100 ) {\n\t\t\treturn this.diffLineMode( text1, text2, deadline );\n\t\t}\n\n\t\treturn this.diffBisect( text1, text2, deadline );\n\t};\n\n\t/**\n\t * Do the two texts share a substring which is at least half the length of the\n\t * longer text?\n\t * This speedup can produce non-minimal diffs.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t *     text1, the suffix of text1, the prefix of text2, the suffix of\n\t *     text2 and the common middle.  Or null if there was no match.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffHalfMatch = function( text1, text2 ) {\n\t\tvar longtext, shorttext, dmp,\n\t\t\ttext1A, text2B, text2A, text1B, midCommon,\n\t\t\thm1, hm2, hm;\n\n\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\tif ( longtext.length < 4 || shorttext.length * 2 < longtext.length ) {\n\t\t\treturn null; // Pointless.\n\t\t}\n\t\tdmp = this; // 'this' becomes 'window' in a closure.\n\n\t\t/**\n\t\t * Does a substring of shorttext exist within longtext such that the substring\n\t\t * is at least half the length of longtext?\n\t\t * Closure, but does not reference any external variables.\n\t\t * @param {string} longtext Longer string.\n\t\t * @param {string} shorttext Shorter string.\n\t\t * @param {number} i Start index of quarter length substring within longtext.\n\t\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t\t *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n\t\t *     of shorttext and the common middle.  Or null if there was no match.\n\t\t * @private\n\t\t */\n\t\tfunction diffHalfMatchI( longtext, shorttext, i ) {\n\t\t\tvar seed, j, bestCommon, prefixLength, suffixLength,\n\t\t\t\tbestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;\n\t\t\t// Start with a 1/4 length substring at position i as a seed.\n\t\t\tseed = longtext.substring( i, i + Math.floor( longtext.length / 4 ) );\n\t\t\tj = -1;\n\t\t\tbestCommon = \"\";\n\t\t\twhile ( ( j = shorttext.indexOf( seed, j + 1 ) ) !== -1 ) {\n\t\t\t\tprefixLength = dmp.diffCommonPrefix( longtext.substring( i ),\n\t\t\t\t\tshorttext.substring( j ) );\n\t\t\t\tsuffixLength = dmp.diffCommonSuffix( longtext.substring( 0, i ),\n\t\t\t\t\tshorttext.substring( 0, j ) );\n\t\t\t\tif ( bestCommon.length < suffixLength + prefixLength ) {\n\t\t\t\t\tbestCommon = shorttext.substring( j - suffixLength, j ) +\n\t\t\t\t\t\tshorttext.substring( j, j + prefixLength );\n\t\t\t\t\tbestLongtextA = longtext.substring( 0, i - suffixLength );\n\t\t\t\t\tbestLongtextB = longtext.substring( i + prefixLength );\n\t\t\t\t\tbestShorttextA = shorttext.substring( 0, j - suffixLength );\n\t\t\t\t\tbestShorttextB = shorttext.substring( j + prefixLength );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( bestCommon.length * 2 >= longtext.length ) {\n\t\t\t\treturn [ bestLongtextA, bestLongtextB,\n\t\t\t\t\tbestShorttextA, bestShorttextB, bestCommon\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// First check if the second quarter is the seed for a half-match.\n\t\thm1 = diffHalfMatchI( longtext, shorttext,\n\t\t\tMath.ceil( longtext.length / 4 ) );\n\t\t// Check again based on the third quarter.\n\t\thm2 = diffHalfMatchI( longtext, shorttext,\n\t\t\tMath.ceil( longtext.length / 2 ) );\n\t\tif ( !hm1 && !hm2 ) {\n\t\t\treturn null;\n\t\t} else if ( !hm2 ) {\n\t\t\thm = hm1;\n\t\t} else if ( !hm1 ) {\n\t\t\thm = hm2;\n\t\t} else {\n\t\t\t// Both matched.  Select the longest.\n\t\t\thm = hm1[ 4 ].length > hm2[ 4 ].length ? hm1 : hm2;\n\t\t}\n\n\t\t// A half-match was found, sort out the return data.\n\t\ttext1A, text1B, text2A, text2B;\n\t\tif ( text1.length > text2.length ) {\n\t\t\ttext1A = hm[ 0 ];\n\t\t\ttext1B = hm[ 1 ];\n\t\t\ttext2A = hm[ 2 ];\n\t\t\ttext2B = hm[ 3 ];\n\t\t} else {\n\t\t\ttext2A = hm[ 0 ];\n\t\t\ttext2B = hm[ 1 ];\n\t\t\ttext1A = hm[ 2 ];\n\t\t\ttext1B = hm[ 3 ];\n\t\t}\n\t\tmidCommon = hm[ 4 ];\n\t\treturn [ text1A, text1B, text2A, text2B, midCommon ];\n\t};\n\n\t/**\n\t * Do a quick line-level diff on both strings, then rediff the parts for\n\t * greater accuracy.\n\t * This speedup can produce non-minimal diffs.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} deadline Time when the diff should be complete by.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffLineMode = function( text1, text2, deadline ) {\n\t\tvar a, diffs, linearray, pointer, countInsert,\n\t\t\tcountDelete, textInsert, textDelete, j;\n\t\t// Scan the text on a line-by-line basis first.\n\t\ta = this.diffLinesToChars( text1, text2 );\n\t\ttext1 = a.chars1;\n\t\ttext2 = a.chars2;\n\t\tlinearray = a.lineArray;\n\n\t\tdiffs = this.DiffMain( text1, text2, false, deadline );\n\n\t\t// Convert the diff back to original text.\n\t\tthis.diffCharsToLines( diffs, linearray );\n\t\t// Eliminate freak matches (e.g. blank lines)\n\t\tthis.diffCleanupSemantic( diffs );\n\n\t\t// Rediff any replacement blocks, this time character-by-character.\n\t\t// Add a dummy entry at the end.\n\t\tdiffs.push( [ DIFF_EQUAL, \"\" ] );\n\t\tpointer = 0;\n\t\tcountDelete = 0;\n\t\tcountInsert = 0;\n\t\ttextDelete = \"\";\n\t\ttextInsert = \"\";\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tcountInsert++;\n\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tcountDelete++;\n\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\tif ( countDelete >= 1 && countInsert >= 1 ) {\n\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\tdiffs.splice( pointer - countDelete - countInsert,\n\t\t\t\t\t\tcountDelete + countInsert );\n\t\t\t\t\tpointer = pointer - countDelete - countInsert;\n\t\t\t\t\ta = this.DiffMain( textDelete, textInsert, false, deadline );\n\t\t\t\t\tfor ( j = a.length - 1; j >= 0; j-- ) {\n\t\t\t\t\t\tdiffs.splice( pointer, 0, a[ j ] );\n\t\t\t\t\t}\n\t\t\t\t\tpointer = pointer + a.length;\n\t\t\t\t}\n\t\t\t\tcountInsert = 0;\n\t\t\t\tcountDelete = 0;\n\t\t\t\ttextDelete = \"\";\n\t\t\t\ttextInsert = \"\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\n\t\treturn diffs;\n\t};\n\n\t/**\n\t * Find the 'middle snake' of a diff, split the problem in two\n\t * and return the recursively constructed diff.\n\t * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} deadline Time at which to bail if not yet complete.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffBisect = function( text1, text2, deadline ) {\n\t\tvar text1Length, text2Length, maxD, vOffset, vLength,\n\t\t\tv1, v2, x, delta, front, k1start, k1end, k2start,\n\t\t\tk2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;\n\t\t// Cache the text lengths to prevent multiple calls.\n\t\ttext1Length = text1.length;\n\t\ttext2Length = text2.length;\n\t\tmaxD = Math.ceil( ( text1Length + text2Length ) / 2 );\n\t\tvOffset = maxD;\n\t\tvLength = 2 * maxD;\n\t\tv1 = new Array( vLength );\n\t\tv2 = new Array( vLength );\n\t\t// Setting all elements to -1 is faster in Chrome & Firefox than mixing\n\t\t// integers and undefined.\n\t\tfor ( x = 0; x < vLength; x++ ) {\n\t\t\tv1[ x ] = -1;\n\t\t\tv2[ x ] = -1;\n\t\t}\n\t\tv1[ vOffset + 1 ] = 0;\n\t\tv2[ vOffset + 1 ] = 0;\n\t\tdelta = text1Length - text2Length;\n\t\t// If the total number of characters is odd, then the front path will collide\n\t\t// with the reverse path.\n\t\tfront = ( delta % 2 !== 0 );\n\t\t// Offsets for start and end of k loop.\n\t\t// Prevents mapping of space beyond the grid.\n\t\tk1start = 0;\n\t\tk1end = 0;\n\t\tk2start = 0;\n\t\tk2end = 0;\n\t\tfor ( d = 0; d < maxD; d++ ) {\n\t\t\t// Bail out if deadline is reached.\n\t\t\tif ( ( new Date() ).getTime() > deadline ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Walk the front path one step.\n\t\t\tfor ( k1 = -d + k1start; k1 <= d - k1end; k1 += 2 ) {\n\t\t\t\tk1Offset = vOffset + k1;\n\t\t\t\tif ( k1 === -d || ( k1 !== d && v1[ k1Offset - 1 ] < v1[ k1Offset + 1 ] ) ) {\n\t\t\t\t\tx1 = v1[ k1Offset + 1 ];\n\t\t\t\t} else {\n\t\t\t\t\tx1 = v1[ k1Offset - 1 ] + 1;\n\t\t\t\t}\n\t\t\t\ty1 = x1 - k1;\n\t\t\t\twhile ( x1 < text1Length && y1 < text2Length &&\n\t\t\t\t\ttext1.charAt( x1 ) === text2.charAt( y1 ) ) {\n\t\t\t\t\tx1++;\n\t\t\t\t\ty1++;\n\t\t\t\t}\n\t\t\t\tv1[ k1Offset ] = x1;\n\t\t\t\tif ( x1 > text1Length ) {\n\t\t\t\t\t// Ran off the right of the graph.\n\t\t\t\t\tk1end += 2;\n\t\t\t\t} else if ( y1 > text2Length ) {\n\t\t\t\t\t// Ran off the bottom of the graph.\n\t\t\t\t\tk1start += 2;\n\t\t\t\t} else if ( front ) {\n\t\t\t\t\tk2Offset = vOffset + delta - k1;\n\t\t\t\t\tif ( k2Offset >= 0 && k2Offset < vLength && v2[ k2Offset ] !== -1 ) {\n\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\tx2 = text1Length - v2[ k2Offset ];\n\t\t\t\t\t\tif ( x1 >= x2 ) {\n\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Walk the reverse path one step.\n\t\t\tfor ( k2 = -d + k2start; k2 <= d - k2end; k2 += 2 ) {\n\t\t\t\tk2Offset = vOffset + k2;\n\t\t\t\tif ( k2 === -d || ( k2 !== d && v2[ k2Offset - 1 ] < v2[ k2Offset + 1 ] ) ) {\n\t\t\t\t\tx2 = v2[ k2Offset + 1 ];\n\t\t\t\t} else {\n\t\t\t\t\tx2 = v2[ k2Offset - 1 ] + 1;\n\t\t\t\t}\n\t\t\t\ty2 = x2 - k2;\n\t\t\t\twhile ( x2 < text1Length && y2 < text2Length &&\n\t\t\t\t\ttext1.charAt( text1Length - x2 - 1 ) ===\n\t\t\t\t\ttext2.charAt( text2Length - y2 - 1 ) ) {\n\t\t\t\t\tx2++;\n\t\t\t\t\ty2++;\n\t\t\t\t}\n\t\t\t\tv2[ k2Offset ] = x2;\n\t\t\t\tif ( x2 > text1Length ) {\n\t\t\t\t\t// Ran off the left of the graph.\n\t\t\t\t\tk2end += 2;\n\t\t\t\t} else if ( y2 > text2Length ) {\n\t\t\t\t\t// Ran off the top of the graph.\n\t\t\t\t\tk2start += 2;\n\t\t\t\t} else if ( !front ) {\n\t\t\t\t\tk1Offset = vOffset + delta - k2;\n\t\t\t\t\tif ( k1Offset >= 0 && k1Offset < vLength && v1[ k1Offset ] !== -1 ) {\n\t\t\t\t\t\tx1 = v1[ k1Offset ];\n\t\t\t\t\t\ty1 = vOffset + x1 - k1Offset;\n\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\tx2 = text1Length - x2;\n\t\t\t\t\t\tif ( x1 >= x2 ) {\n\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Diff took too long and hit the deadline or\n\t\t// number of diffs equals number of characters, no commonality at all.\n\t\treturn [\n\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t[ DIFF_INSERT, text2 ]\n\t\t];\n\t};\n\n\t/**\n\t * Given the location of the 'middle snake', split the diff in two parts\n\t * and recurse.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} x Index of split point in text1.\n\t * @param {number} y Index of split point in text2.\n\t * @param {number} deadline Time at which to bail if not yet complete.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffBisectSplit = function( text1, text2, x, y, deadline ) {\n\t\tvar text1a, text1b, text2a, text2b, diffs, diffsb;\n\t\ttext1a = text1.substring( 0, x );\n\t\ttext2a = text2.substring( 0, y );\n\t\ttext1b = text1.substring( x );\n\t\ttext2b = text2.substring( y );\n\n\t\t// Compute both diffs serially.\n\t\tdiffs = this.DiffMain( text1a, text2a, false, deadline );\n\t\tdiffsb = this.DiffMain( text1b, text2b, false, deadline );\n\n\t\treturn diffs.concat( diffsb );\n\t};\n\n\t/**\n\t * Reduce the number of edits by eliminating semantically trivial equalities.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupSemantic = function( diffs ) {\n\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\tpointer, lengthInsertions2, lengthDeletions2, lengthInsertions1,\n\t\t\tlengthDeletions1, deletion, insertion, overlapLength1, overlapLength2;\n\t\tchanges = false;\n\t\tequalities = []; // Stack of indices where equalities are found.\n\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t/** @type {?string} */\n\t\tlastequality = null;\n\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\tpointer = 0; // Index of current position.\n\t\t// Number of characters that changed prior to the equality.\n\t\tlengthInsertions1 = 0;\n\t\tlengthDeletions1 = 0;\n\t\t// Number of characters that changed after the equality.\n\t\tlengthInsertions2 = 0;\n\t\tlengthDeletions2 = 0;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) { // Equality found.\n\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\tlengthInsertions1 = lengthInsertions2;\n\t\t\t\tlengthDeletions1 = lengthDeletions2;\n\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t} else { // An insertion or deletion.\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\t\tlengthInsertions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t} else {\n\t\t\t\t\tlengthDeletions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t}\n\t\t\t\t// Eliminate an equality that is smaller or equal to the edits on both\n\t\t\t\t// sides of it.\n\t\t\t\tif ( lastequality && ( lastequality.length <=\n\t\t\t\t\t\tMath.max( lengthInsertions1, lengthDeletions1 ) ) &&\n\t\t\t\t\t\t( lastequality.length <= Math.max( lengthInsertions2,\n\t\t\t\t\t\t\tlengthDeletions2 ) ) ) {\n\n\t\t\t\t\t// Duplicate record.\n\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t);\n\n\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\n\t\t\t\t\t// Throw away the equality we just deleted.\n\t\t\t\t\tequalitiesLength--;\n\n\t\t\t\t\t// Throw away the previous equality (it needs to be reevaluated).\n\t\t\t\t\tequalitiesLength--;\n\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\n\t\t\t\t\t// Reset the counters.\n\t\t\t\t\tlengthInsertions1 = 0;\n\t\t\t\t\tlengthDeletions1 = 0;\n\t\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\t// Normalize the diff.\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\n\t\t// Find any overlaps between deletions and insertions.\n\t\t// e.g: <del>abcxxx</del><ins>xxxdef</ins>\n\t\t//   -> <del>abc</del>xxx<ins>def</ins>\n\t\t// e.g: <del>xxxabc</del><ins>defxxx</ins>\n\t\t//   -> <ins>def</ins>xxx<del>abc</del>\n\t\t// Only extract an overlap if it is as big as the edit ahead or behind it.\n\t\tpointer = 1;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_DELETE &&\n\t\t\t\t\tdiffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\tdeletion = diffs[ pointer - 1 ][ 1 ];\n\t\t\t\tinsertion = diffs[ pointer ][ 1 ];\n\t\t\t\toverlapLength1 = this.diffCommonOverlap( deletion, insertion );\n\t\t\t\toverlapLength2 = this.diffCommonOverlap( insertion, deletion );\n\t\t\t\tif ( overlapLength1 >= overlapLength2 ) {\n\t\t\t\t\tif ( overlapLength1 >= deletion.length / 2 ||\n\t\t\t\t\t\t\toverlapLength1 >= insertion.length / 2 ) {\n\t\t\t\t\t\t// Overlap found.  Insert an equality and trim the surrounding edits.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_EQUAL, insertion.substring( 0, overlapLength1 ) ]\n\t\t\t\t\t\t);\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\tdeletion.substring( 0, deletion.length - overlapLength1 );\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] = insertion.substring( overlapLength1 );\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ( overlapLength2 >= deletion.length / 2 ||\n\t\t\t\t\t\t\toverlapLength2 >= insertion.length / 2 ) {\n\n\t\t\t\t\t\t// Reverse overlap found.\n\t\t\t\t\t\t// Insert an equality and swap and trim the surrounding edits.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_EQUAL, deletion.substring( 0, overlapLength2 ) ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\tinsertion.substring( 0, insertion.length - overlapLength2 );\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] = DIFF_DELETE;\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\t\tdeletion.substring( overlapLength2 );\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t};\n\n\t/**\n\t * Determine if the suffix of one string is the prefix of another.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the end of the first\n\t *     string and the start of the second string.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCommonOverlap = function( text1, text2 ) {\n\t\tvar text1Length, text2Length, textLength,\n\t\t\tbest, length, pattern, found;\n\t\t// Cache the text lengths to prevent multiple calls.\n\t\ttext1Length = text1.length;\n\t\ttext2Length = text2.length;\n\t\t// Eliminate the null case.\n\t\tif ( text1Length === 0 || text2Length === 0 ) {\n\t\t\treturn 0;\n\t\t}\n\t\t// Truncate the longer string.\n\t\tif ( text1Length > text2Length ) {\n\t\t\ttext1 = text1.substring( text1Length - text2Length );\n\t\t} else if ( text1Length < text2Length ) {\n\t\t\ttext2 = text2.substring( 0, text1Length );\n\t\t}\n\t\ttextLength = Math.min( text1Length, text2Length );\n\t\t// Quick check for the worst case.\n\t\tif ( text1 === text2 ) {\n\t\t\treturn textLength;\n\t\t}\n\n\t\t// Start by looking for a single character match\n\t\t// and increase length until no match is found.\n\t\t// Performance analysis: http://neil.fraser.name/news/2010/11/04/\n\t\tbest = 0;\n\t\tlength = 1;\n\t\twhile ( true ) {\n\t\t\tpattern = text1.substring( textLength - length );\n\t\t\tfound = text2.indexOf( pattern );\n\t\t\tif ( found === -1 ) {\n\t\t\t\treturn best;\n\t\t\t}\n\t\t\tlength += found;\n\t\t\tif ( found === 0 || text1.substring( textLength - length ) ===\n\t\t\t\t\ttext2.substring( 0, length ) ) {\n\t\t\t\tbest = length;\n\t\t\t\tlength++;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Split two texts into an array of strings.  Reduce the texts to a string of\n\t * hashes where each Unicode character represents one line.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n\t *     An object containing the encoded text1, the encoded text2 and\n\t *     the array of unique strings.\n\t *     The zeroth element of the array of unique strings is intentionally blank.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffLinesToChars = function( text1, text2 ) {\n\t\tvar lineArray, lineHash, chars1, chars2;\n\t\tlineArray = []; // e.g. lineArray[4] === 'Hello\\n'\n\t\tlineHash = {}; // e.g. lineHash['Hello\\n'] === 4\n\n\t\t// '\\x00' is a valid character, but various debuggers don't like it.\n\t\t// So we'll insert a junk entry to avoid generating a null character.\n\t\tlineArray[ 0 ] = \"\";\n\n\t\t/**\n\t\t * Split a text into an array of strings.  Reduce the texts to a string of\n\t\t * hashes where each Unicode character represents one line.\n\t\t * Modifies linearray and linehash through being a closure.\n\t\t * @param {string} text String to encode.\n\t\t * @return {string} Encoded string.\n\t\t * @private\n\t\t */\n\t\tfunction diffLinesToCharsMunge( text ) {\n\t\t\tvar chars, lineStart, lineEnd, lineArrayLength, line;\n\t\t\tchars = \"\";\n\t\t\t// Walk the text, pulling out a substring for each line.\n\t\t\t// text.split('\\n') would would temporarily double our memory footprint.\n\t\t\t// Modifying text would create many large strings to garbage collect.\n\t\t\tlineStart = 0;\n\t\t\tlineEnd = -1;\n\t\t\t// Keeping our own length variable is faster than looking it up.\n\t\t\tlineArrayLength = lineArray.length;\n\t\t\twhile ( lineEnd < text.length - 1 ) {\n\t\t\t\tlineEnd = text.indexOf( \"\\n\", lineStart );\n\t\t\t\tif ( lineEnd === -1 ) {\n\t\t\t\t\tlineEnd = text.length - 1;\n\t\t\t\t}\n\t\t\t\tline = text.substring( lineStart, lineEnd + 1 );\n\t\t\t\tlineStart = lineEnd + 1;\n\n\t\t\t\tif ( lineHash.hasOwnProperty ? lineHash.hasOwnProperty( line ) :\n\t\t\t\t\t\t\t( lineHash[ line ] !== undefined ) ) {\n\t\t\t\t\tchars += String.fromCharCode( lineHash[ line ] );\n\t\t\t\t} else {\n\t\t\t\t\tchars += String.fromCharCode( lineArrayLength );\n\t\t\t\t\tlineHash[ line ] = lineArrayLength;\n\t\t\t\t\tlineArray[ lineArrayLength++ ] = line;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn chars;\n\t\t}\n\n\t\tchars1 = diffLinesToCharsMunge( text1 );\n\t\tchars2 = diffLinesToCharsMunge( text2 );\n\t\treturn {\n\t\t\tchars1: chars1,\n\t\t\tchars2: chars2,\n\t\t\tlineArray: lineArray\n\t\t};\n\t};\n\n\t/**\n\t * Rehydrate the text in a diff from a string of line hashes to real lines of\n\t * text.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t * @param {!Array.<string>} lineArray Array of unique strings.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCharsToLines = function( diffs, lineArray ) {\n\t\tvar x, chars, text, y;\n\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\tchars = diffs[ x ][ 1 ];\n\t\t\ttext = [];\n\t\t\tfor ( y = 0; y < chars.length; y++ ) {\n\t\t\t\ttext[ y ] = lineArray[ chars.charCodeAt( y ) ];\n\t\t\t}\n\t\t\tdiffs[ x ][ 1 ] = text.join( \"\" );\n\t\t}\n\t};\n\n\t/**\n\t * Reorder and merge like edit sections.  Merge equalities.\n\t * Any edit section can move as long as it doesn't cross an equality.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupMerge = function( diffs ) {\n\t\tvar pointer, countDelete, countInsert, textInsert, textDelete,\n\t\t\tcommonlength, changes, diffPointer, position;\n\t\tdiffs.push( [ DIFF_EQUAL, \"\" ] ); // Add a dummy entry at the end.\n\t\tpointer = 0;\n\t\tcountDelete = 0;\n\t\tcountInsert = 0;\n\t\ttextDelete = \"\";\n\t\ttextInsert = \"\";\n\t\tcommonlength;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tcountInsert++;\n\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\tpointer++;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tcountDelete++;\n\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\tpointer++;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\tif ( countDelete + countInsert > 1 ) {\n\t\t\t\t\tif ( countDelete !== 0 && countInsert !== 0 ) {\n\t\t\t\t\t\t// Factor out any common prefixies.\n\t\t\t\t\t\tcommonlength = this.diffCommonPrefix( textInsert, textDelete );\n\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\tif ( ( pointer - countDelete - countInsert ) > 0 &&\n\t\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 0 ] ===\n\t\t\t\t\t\t\t\t\tDIFF_EQUAL ) {\n\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 1 ] +=\n\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdiffs.splice( 0, 0, [ DIFF_EQUAL,\n\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength )\n\t\t\t\t\t\t\t\t] );\n\t\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttextInsert = textInsert.substring( commonlength );\n\t\t\t\t\t\t\ttextDelete = textDelete.substring( commonlength );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Factor out any common suffixies.\n\t\t\t\t\t\tcommonlength = this.diffCommonSuffix( textInsert, textDelete );\n\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\tdiffs[ pointer ][ 1 ] = textInsert.substring( textInsert.length -\n\t\t\t\t\t\t\t\t\tcommonlength ) + diffs[ pointer ][ 1 ];\n\t\t\t\t\t\t\ttextInsert = textInsert.substring( 0, textInsert.length -\n\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t\ttextDelete = textDelete.substring( 0, textDelete.length -\n\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\tif ( countDelete === 0 ) {\n\t\t\t\t\t\tdiffs.splice( pointer - countInsert,\n\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_INSERT, textInsert ] );\n\t\t\t\t\t} else if ( countInsert === 0 ) {\n\t\t\t\t\t\tdiffs.splice( pointer - countDelete,\n\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_DELETE, textDelete ] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer - countDelete - countInsert,\n\t\t\t\t\t\t\tcountDelete + countInsert,\n\t\t\t\t\t\t\t[ DIFF_DELETE, textDelete ], [ DIFF_INSERT, textInsert ]\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tpointer = pointer - countDelete - countInsert +\n\t\t\t\t\t\t( countDelete ? 1 : 0 ) + ( countInsert ? 1 : 0 ) + 1;\n\t\t\t\t} else if ( pointer !== 0 && diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL ) {\n\n\t\t\t\t\t// Merge this equality with the previous one.\n\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer, 1 );\n\t\t\t\t} else {\n\t\t\t\t\tpointer++;\n\t\t\t\t}\n\t\t\t\tcountInsert = 0;\n\t\t\t\tcountDelete = 0;\n\t\t\t\ttextDelete = \"\";\n\t\t\t\ttextInsert = \"\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( diffs[ diffs.length - 1 ][ 1 ] === \"\" ) {\n\t\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\t\t}\n\n\t\t// Second pass: look for single edits surrounded on both sides by equalities\n\t\t// which can be shifted sideways to eliminate an equality.\n\t\t// e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n\t\tchanges = false;\n\t\tpointer = 1;\n\n\t\t// Intentionally ignore the first and last element (don't need checking).\n\t\twhile ( pointer < diffs.length - 1 ) {\n\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL &&\n\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] === DIFF_EQUAL ) {\n\n\t\t\t\tdiffPointer = diffs[ pointer ][ 1 ];\n\t\t\t\tposition = diffPointer.substring(\n\t\t\t\t\tdiffPointer.length - diffs[ pointer - 1 ][ 1 ].length\n\t\t\t\t);\n\n\t\t\t\t// This is a single edit surrounded by equalities.\n\t\t\t\tif ( position === diffs[ pointer - 1 ][ 1 ] ) {\n\n\t\t\t\t\t// Shift the edit over the previous equality.\n\t\t\t\t\tdiffs[ pointer ][ 1 ] = diffs[ pointer - 1 ][ 1 ] +\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( 0, diffs[ pointer ][ 1 ].length -\n\t\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ].length );\n\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] + diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer - 1, 1 );\n\t\t\t\t\tchanges = true;\n\t\t\t\t} else if ( diffPointer.substring( 0, diffs[ pointer + 1 ][ 1 ].length ) ===\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] ) {\n\n\t\t\t\t\t// Shift the edit over the next equality.\n\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs[ pointer ][ 1 ] =\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( diffs[ pointer + 1 ][ 1 ].length ) +\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer + 1, 1 );\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t\t// If shifts were made, the diff needs reordering and another shift sweep.\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\t};\n\n\treturn function( o, n ) {\n\t\tvar diff, output, text;\n\t\tdiff = new DiffMatchPatch();\n\t\toutput = diff.DiffMain( o, n );\n\t\tdiff.diffCleanupEfficiency( output );\n\t\ttext = diff.diffPrettyHtml( output );\n\n\t\treturn text;\n\t};\n}() );\n\n// Get a reference to the global object, like window in browsers\n}( (function() {\n\treturn this;\n})() ));\n\n(function() {\n\n// Don't load the HTML Reporter on non-Browser environments\nif ( typeof window === \"undefined\" || !window.document ) {\n\treturn;\n}\n\n// Deprecated QUnit.init - Ref #530\n// Re-initialize the configuration options\nQUnit.init = function() {\n\tvar tests, banner, result, qunit,\n\t\tconfig = QUnit.config;\n\n\tconfig.stats = { all: 0, bad: 0 };\n\tconfig.moduleStats = { all: 0, bad: 0 };\n\tconfig.started = 0;\n\tconfig.updateRate = 1000;\n\tconfig.blocking = false;\n\tconfig.autostart = true;\n\tconfig.autorun = false;\n\tconfig.filter = \"\";\n\tconfig.queue = [];\n\n\t// Return on non-browser environments\n\t// This is necessary to not break on node tests\n\tif ( typeof window === \"undefined\" ) {\n\t\treturn;\n\t}\n\n\tqunit = id( \"qunit\" );\n\tif ( qunit ) {\n\t\tqunit.innerHTML =\n\t\t\t\"<h1 id='qunit-header'>\" + escapeText( document.title ) + \"</h1>\" +\n\t\t\t\"<h2 id='qunit-banner'></h2>\" +\n\t\t\t\"<div id='qunit-testrunner-toolbar'></div>\" +\n\t\t\t\"<h2 id='qunit-userAgent'></h2>\" +\n\t\t\t\"<ol id='qunit-tests'></ol>\";\n\t}\n\n\ttests = id( \"qunit-tests\" );\n\tbanner = id( \"qunit-banner\" );\n\tresult = id( \"qunit-testresult\" );\n\n\tif ( tests ) {\n\t\ttests.innerHTML = \"\";\n\t}\n\n\tif ( banner ) {\n\t\tbanner.className = \"\";\n\t}\n\n\tif ( result ) {\n\t\tresult.parentNode.removeChild( result );\n\t}\n\n\tif ( tests ) {\n\t\tresult = document.createElement( \"p\" );\n\t\tresult.id = \"qunit-testresult\";\n\t\tresult.className = \"result\";\n\t\ttests.parentNode.insertBefore( result, tests );\n\t\tresult.innerHTML = \"Running...<br />&#160;\";\n\t}\n};\n\nvar config = QUnit.config,\n\tcollapseNext = false,\n\thasOwn = Object.prototype.hasOwnProperty,\n\tdefined = {\n\t\tdocument: window.document !== undefined,\n\t\tsessionStorage: (function() {\n\t\t\tvar x = \"qunit-test-string\";\n\t\t\ttry {\n\t\t\t\tsessionStorage.setItem( x, x );\n\t\t\t\tsessionStorage.removeItem( x );\n\t\t\t\treturn true;\n\t\t\t} catch ( e ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}())\n\t},\n\tmodulesList = [];\n\n/**\n* Escape text for attribute or text content.\n*/\nfunction escapeText( s ) {\n\tif ( !s ) {\n\t\treturn \"\";\n\t}\n\ts = s + \"\";\n\n\t// Both single quotes and double quotes (for attributes)\n\treturn s.replace( /['\"<>&]/g, function( s ) {\n\t\tswitch ( s ) {\n\t\tcase \"'\":\n\t\t\treturn \"&#039;\";\n\t\tcase \"\\\"\":\n\t\t\treturn \"&quot;\";\n\t\tcase \"<\":\n\t\t\treturn \"&lt;\";\n\t\tcase \">\":\n\t\t\treturn \"&gt;\";\n\t\tcase \"&\":\n\t\t\treturn \"&amp;\";\n\t\t}\n\t});\n}\n\n/**\n * @param {HTMLElement} elem\n * @param {string} type\n * @param {Function} fn\n */\nfunction addEvent( elem, type, fn ) {\n\tif ( elem.addEventListener ) {\n\n\t\t// Standards-based browsers\n\t\telem.addEventListener( type, fn, false );\n\t} else if ( elem.attachEvent ) {\n\n\t\t// support: IE <9\n\t\telem.attachEvent( \"on\" + type, function() {\n\t\t\tvar event = window.event;\n\t\t\tif ( !event.target ) {\n\t\t\t\tevent.target = event.srcElement || document;\n\t\t\t}\n\n\t\t\tfn.call( elem, event );\n\t\t});\n\t}\n}\n\n/**\n * @param {Array|NodeList} elems\n * @param {string} type\n * @param {Function} fn\n */\nfunction addEvents( elems, type, fn ) {\n\tvar i = elems.length;\n\twhile ( i-- ) {\n\t\taddEvent( elems[ i ], type, fn );\n\t}\n}\n\nfunction hasClass( elem, name ) {\n\treturn ( \" \" + elem.className + \" \" ).indexOf( \" \" + name + \" \" ) >= 0;\n}\n\nfunction addClass( elem, name ) {\n\tif ( !hasClass( elem, name ) ) {\n\t\telem.className += ( elem.className ? \" \" : \"\" ) + name;\n\t}\n}\n\nfunction toggleClass( elem, name ) {\n\tif ( hasClass( elem, name ) ) {\n\t\tremoveClass( elem, name );\n\t} else {\n\t\taddClass( elem, name );\n\t}\n}\n\nfunction removeClass( elem, name ) {\n\tvar set = \" \" + elem.className + \" \";\n\n\t// Class name may appear multiple times\n\twhile ( set.indexOf( \" \" + name + \" \" ) >= 0 ) {\n\t\tset = set.replace( \" \" + name + \" \", \" \" );\n\t}\n\n\t// trim for prettiness\n\telem.className = typeof set.trim === \"function\" ? set.trim() : set.replace( /^\\s+|\\s+$/g, \"\" );\n}\n\nfunction id( name ) {\n\treturn defined.document && document.getElementById && document.getElementById( name );\n}\n\nfunction getUrlConfigHtml() {\n\tvar i, j, val,\n\t\tescaped, escapedTooltip,\n\t\tselection = false,\n\t\tlen = config.urlConfig.length,\n\t\turlConfigHtml = \"\";\n\n\tfor ( i = 0; i < len; i++ ) {\n\t\tval = config.urlConfig[ i ];\n\t\tif ( typeof val === \"string\" ) {\n\t\t\tval = {\n\t\t\t\tid: val,\n\t\t\t\tlabel: val\n\t\t\t};\n\t\t}\n\n\t\tescaped = escapeText( val.id );\n\t\tescapedTooltip = escapeText( val.tooltip );\n\n\t\tif ( config[ val.id ] === undefined ) {\n\t\t\tconfig[ val.id ] = QUnit.urlParams[ val.id ];\n\t\t}\n\n\t\tif ( !val.value || typeof val.value === \"string\" ) {\n\t\t\turlConfigHtml += \"<input id='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' name='\" + escaped + \"' type='checkbox'\" +\n\t\t\t\t( val.value ? \" value='\" + escapeText( val.value ) + \"'\" : \"\" ) +\n\t\t\t\t( config[ val.id ] ? \" checked='checked'\" : \"\" ) +\n\t\t\t\t\" title='\" + escapedTooltip + \"' /><label for='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' title='\" + escapedTooltip + \"'>\" + val.label + \"</label>\";\n\t\t} else {\n\t\t\turlConfigHtml += \"<label for='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' title='\" + escapedTooltip + \"'>\" + val.label +\n\t\t\t\t\": </label><select id='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' name='\" + escaped + \"' title='\" + escapedTooltip + \"'><option></option>\";\n\n\t\t\tif ( QUnit.is( \"array\", val.value ) ) {\n\t\t\t\tfor ( j = 0; j < val.value.length; j++ ) {\n\t\t\t\t\tescaped = escapeText( val.value[ j ] );\n\t\t\t\t\turlConfigHtml += \"<option value='\" + escaped + \"'\" +\n\t\t\t\t\t\t( config[ val.id ] === val.value[ j ] ?\n\t\t\t\t\t\t\t( selection = true ) && \" selected='selected'\" : \"\" ) +\n\t\t\t\t\t\t\">\" + escaped + \"</option>\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( j in val.value ) {\n\t\t\t\t\tif ( hasOwn.call( val.value, j ) ) {\n\t\t\t\t\t\turlConfigHtml += \"<option value='\" + escapeText( j ) + \"'\" +\n\t\t\t\t\t\t\t( config[ val.id ] === j ?\n\t\t\t\t\t\t\t\t( selection = true ) && \" selected='selected'\" : \"\" ) +\n\t\t\t\t\t\t\t\">\" + escapeText( val.value[ j ] ) + \"</option>\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( config[ val.id ] && !selection ) {\n\t\t\t\tescaped = escapeText( config[ val.id ] );\n\t\t\t\turlConfigHtml += \"<option value='\" + escaped +\n\t\t\t\t\t\"' selected='selected' disabled='disabled'>\" + escaped + \"</option>\";\n\t\t\t}\n\t\t\turlConfigHtml += \"</select>\";\n\t\t}\n\t}\n\n\treturn urlConfigHtml;\n}\n\n// Handle \"click\" events on toolbar checkboxes and \"change\" for select menus.\n// Updates the URL with the new state of `config.urlConfig` values.\nfunction toolbarChanged() {\n\tvar updatedUrl, value,\n\t\tfield = this,\n\t\tparams = {};\n\n\t// Detect if field is a select menu or a checkbox\n\tif ( \"selectedIndex\" in field ) {\n\t\tvalue = field.options[ field.selectedIndex ].value || undefined;\n\t} else {\n\t\tvalue = field.checked ? ( field.defaultValue || true ) : undefined;\n\t}\n\n\tparams[ field.name ] = value;\n\tupdatedUrl = setUrl( params );\n\n\tif ( \"hidepassed\" === field.name && \"replaceState\" in window.history ) {\n\t\tconfig[ field.name ] = value || false;\n\t\tif ( value ) {\n\t\t\taddClass( id( \"qunit-tests\" ), \"hidepass\" );\n\t\t} else {\n\t\t\tremoveClass( id( \"qunit-tests\" ), \"hidepass\" );\n\t\t}\n\n\t\t// It is not necessary to refresh the whole page\n\t\twindow.history.replaceState( null, \"\", updatedUrl );\n\t} else {\n\t\twindow.location = updatedUrl;\n\t}\n}\n\nfunction setUrl( params ) {\n\tvar key,\n\t\tquerystring = \"?\";\n\n\tparams = QUnit.extend( QUnit.extend( {}, QUnit.urlParams ), params );\n\n\tfor ( key in params ) {\n\t\tif ( hasOwn.call( params, key ) ) {\n\t\t\tif ( params[ key ] === undefined ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tquerystring += encodeURIComponent( key );\n\t\t\tif ( params[ key ] !== true ) {\n\t\t\t\tquerystring += \"=\" + encodeURIComponent( params[ key ] );\n\t\t\t}\n\t\t\tquerystring += \"&\";\n\t\t}\n\t}\n\treturn location.protocol + \"//\" + location.host +\n\t\tlocation.pathname + querystring.slice( 0, -1 );\n}\n\nfunction applyUrlParams() {\n\tvar selectedModule,\n\t\tmodulesList = id( \"qunit-modulefilter\" ),\n\t\tfilter = id( \"qunit-filter-input\" ).value;\n\n\tselectedModule = modulesList ?\n\t\tdecodeURIComponent( modulesList.options[ modulesList.selectedIndex ].value ) :\n\t\tundefined;\n\n\twindow.location = setUrl({\n\t\tmodule: ( selectedModule === \"\" ) ? undefined : selectedModule,\n\t\tfilter: ( filter === \"\" ) ? undefined : filter,\n\n\t\t// Remove testId filter\n\t\ttestId: undefined\n\t});\n}\n\nfunction toolbarUrlConfigContainer() {\n\tvar urlConfigContainer = document.createElement( \"span\" );\n\n\turlConfigContainer.innerHTML = getUrlConfigHtml();\n\taddClass( urlConfigContainer, \"qunit-url-config\" );\n\n\t// For oldIE support:\n\t// * Add handlers to the individual elements instead of the container\n\t// * Use \"click\" instead of \"change\" for checkboxes\n\taddEvents( urlConfigContainer.getElementsByTagName( \"input\" ), \"click\", toolbarChanged );\n\taddEvents( urlConfigContainer.getElementsByTagName( \"select\" ), \"change\", toolbarChanged );\n\n\treturn urlConfigContainer;\n}\n\nfunction toolbarLooseFilter() {\n\tvar filter = document.createElement( \"form\" ),\n\t\tlabel = document.createElement( \"label\" ),\n\t\tinput = document.createElement( \"input\" ),\n\t\tbutton = document.createElement( \"button\" );\n\n\taddClass( filter, \"qunit-filter\" );\n\n\tlabel.innerHTML = \"Filter: \";\n\n\tinput.type = \"text\";\n\tinput.value = config.filter || \"\";\n\tinput.name = \"filter\";\n\tinput.id = \"qunit-filter-input\";\n\n\tbutton.innerHTML = \"Go\";\n\n\tlabel.appendChild( input );\n\n\tfilter.appendChild( label );\n\tfilter.appendChild( button );\n\taddEvent( filter, \"submit\", function( ev ) {\n\t\tapplyUrlParams();\n\n\t\tif ( ev && ev.preventDefault ) {\n\t\t\tev.preventDefault();\n\t\t}\n\n\t\treturn false;\n\t});\n\n\treturn filter;\n}\n\nfunction toolbarModuleFilterHtml() {\n\tvar i,\n\t\tmoduleFilterHtml = \"\";\n\n\tif ( !modulesList.length ) {\n\t\treturn false;\n\t}\n\n\tmodulesList.sort(function( a, b ) {\n\t\treturn a.localeCompare( b );\n\t});\n\n\tmoduleFilterHtml += \"<label for='qunit-modulefilter'>Module: </label>\" +\n\t\t\"<select id='qunit-modulefilter' name='modulefilter'><option value='' \" +\n\t\t( QUnit.urlParams.module === undefined ? \"selected='selected'\" : \"\" ) +\n\t\t\">< All Modules ></option>\";\n\n\tfor ( i = 0; i < modulesList.length; i++ ) {\n\t\tmoduleFilterHtml += \"<option value='\" +\n\t\t\tescapeText( encodeURIComponent( modulesList[ i ] ) ) + \"' \" +\n\t\t\t( QUnit.urlParams.module === modulesList[ i ] ? \"selected='selected'\" : \"\" ) +\n\t\t\t\">\" + escapeText( modulesList[ i ] ) + \"</option>\";\n\t}\n\tmoduleFilterHtml += \"</select>\";\n\n\treturn moduleFilterHtml;\n}\n\nfunction toolbarModuleFilter() {\n\tvar toolbar = id( \"qunit-testrunner-toolbar\" ),\n\t\tmoduleFilter = document.createElement( \"span\" ),\n\t\tmoduleFilterHtml = toolbarModuleFilterHtml();\n\n\tif ( !toolbar || !moduleFilterHtml ) {\n\t\treturn false;\n\t}\n\n\tmoduleFilter.setAttribute( \"id\", \"qunit-modulefilter-container\" );\n\tmoduleFilter.innerHTML = moduleFilterHtml;\n\n\taddEvent( moduleFilter.lastChild, \"change\", applyUrlParams );\n\n\ttoolbar.appendChild( moduleFilter );\n}\n\nfunction appendToolbar() {\n\tvar toolbar = id( \"qunit-testrunner-toolbar\" );\n\n\tif ( toolbar ) {\n\t\ttoolbar.appendChild( toolbarUrlConfigContainer() );\n\t\ttoolbar.appendChild( toolbarLooseFilter() );\n\t}\n}\n\nfunction appendHeader() {\n\tvar header = id( \"qunit-header\" );\n\n\tif ( header ) {\n\t\theader.innerHTML = \"<a href='\" +\n\t\t\tsetUrl({ filter: undefined, module: undefined, testId: undefined }) +\n\t\t\t\"'>\" + header.innerHTML + \"</a> \";\n\t}\n}\n\nfunction appendBanner() {\n\tvar banner = id( \"qunit-banner\" );\n\n\tif ( banner ) {\n\t\tbanner.className = \"\";\n\t}\n}\n\nfunction appendTestResults() {\n\tvar tests = id( \"qunit-tests\" ),\n\t\tresult = id( \"qunit-testresult\" );\n\n\tif ( result ) {\n\t\tresult.parentNode.removeChild( result );\n\t}\n\n\tif ( tests ) {\n\t\ttests.innerHTML = \"\";\n\t\tresult = document.createElement( \"p\" );\n\t\tresult.id = \"qunit-testresult\";\n\t\tresult.className = \"result\";\n\t\ttests.parentNode.insertBefore( result, tests );\n\t\tresult.innerHTML = \"Running...<br />&#160;\";\n\t}\n}\n\nfunction storeFixture() {\n\tvar fixture = id( \"qunit-fixture\" );\n\tif ( fixture ) {\n\t\tconfig.fixture = fixture.innerHTML;\n\t}\n}\n\nfunction appendFilteredTest() {\n\tvar testId = QUnit.config.testId;\n\tif ( !testId || testId.length <= 0 ) {\n\t\treturn \"\";\n\t}\n\treturn \"<div id='qunit-filteredTest'>Rerunning selected tests: \" + testId.join(\", \") +\n\t\t\" <a id='qunit-clearFilter' href='\" +\n\t\tsetUrl({ filter: undefined, module: undefined, testId: undefined }) +\n\t\t\"'>\" + \"Run all tests\" + \"</a></div>\";\n}\n\nfunction appendUserAgent() {\n\tvar userAgent = id( \"qunit-userAgent\" );\n\n\tif ( userAgent ) {\n\t\tuserAgent.innerHTML = \"\";\n\t\tuserAgent.appendChild(\n\t\t\tdocument.createTextNode(\n\t\t\t\t\"QUnit \" + QUnit.version + \"; \" + navigator.userAgent\n\t\t\t)\n\t\t);\n\t}\n}\n\nfunction appendTestsList( modules ) {\n\tvar i, l, x, z, test, moduleObj;\n\n\tfor ( i = 0, l = modules.length; i < l; i++ ) {\n\t\tmoduleObj = modules[ i ];\n\n\t\tif ( moduleObj.name ) {\n\t\t\tmodulesList.push( moduleObj.name );\n\t\t}\n\n\t\tfor ( x = 0, z = moduleObj.tests.length; x < z; x++ ) {\n\t\t\ttest = moduleObj.tests[ x ];\n\n\t\t\tappendTest( test.name, test.testId, moduleObj.name );\n\t\t}\n\t}\n}\n\nfunction appendTest( name, testId, moduleName ) {\n\tvar title, rerunTrigger, testBlock, assertList,\n\t\ttests = id( \"qunit-tests\" );\n\n\tif ( !tests ) {\n\t\treturn;\n\t}\n\n\ttitle = document.createElement( \"strong\" );\n\ttitle.innerHTML = getNameHtml( name, moduleName );\n\n\trerunTrigger = document.createElement( \"a\" );\n\trerunTrigger.innerHTML = \"Rerun\";\n\trerunTrigger.href = setUrl({ testId: testId });\n\n\ttestBlock = document.createElement( \"li\" );\n\ttestBlock.appendChild( title );\n\ttestBlock.appendChild( rerunTrigger );\n\ttestBlock.id = \"qunit-test-output-\" + testId;\n\n\tassertList = document.createElement( \"ol\" );\n\tassertList.className = \"qunit-assert-list\";\n\n\ttestBlock.appendChild( assertList );\n\n\ttests.appendChild( testBlock );\n}\n\n// HTML Reporter initialization and load\nQUnit.begin(function( details ) {\n\tvar qunit = id( \"qunit\" );\n\n\t// Fixture is the only one necessary to run without the #qunit element\n\tstoreFixture();\n\n\tif ( qunit ) {\n\t\tqunit.innerHTML =\n\t\t\t\"<h1 id='qunit-header'>\" + escapeText( document.title ) + \"</h1>\" +\n\t\t\t\"<h2 id='qunit-banner'></h2>\" +\n\t\t\t\"<div id='qunit-testrunner-toolbar'></div>\" +\n\t\t\tappendFilteredTest() +\n\t\t\t\"<h2 id='qunit-userAgent'></h2>\" +\n\t\t\t\"<ol id='qunit-tests'></ol>\";\n\t}\n\n\tappendHeader();\n\tappendBanner();\n\tappendTestResults();\n\tappendUserAgent();\n\tappendToolbar();\n\tappendTestsList( details.modules );\n\ttoolbarModuleFilter();\n\n\tif ( qunit && config.hidepassed ) {\n\t\taddClass( qunit.lastChild, \"hidepass\" );\n\t}\n});\n\nQUnit.done(function( details ) {\n\tvar i, key,\n\t\tbanner = id( \"qunit-banner\" ),\n\t\ttests = id( \"qunit-tests\" ),\n\t\thtml = [\n\t\t\t\"Tests completed in \",\n\t\t\tdetails.runtime,\n\t\t\t\" milliseconds.<br />\",\n\t\t\t\"<span class='passed'>\",\n\t\t\tdetails.passed,\n\t\t\t\"</span> assertions of <span class='total'>\",\n\t\t\tdetails.total,\n\t\t\t\"</span> passed, <span class='failed'>\",\n\t\t\tdetails.failed,\n\t\t\t\"</span> failed.\"\n\t\t].join( \"\" );\n\n\tif ( banner ) {\n\t\tbanner.className = details.failed ? \"qunit-fail\" : \"qunit-pass\";\n\t}\n\n\tif ( tests ) {\n\t\tid( \"qunit-testresult\" ).innerHTML = html;\n\t}\n\n\tif ( config.altertitle && defined.document && document.title ) {\n\n\t\t// show ‚úñ for good, ‚úî for bad suite result in title\n\t\t// use escape sequences in case file gets loaded with non-utf-8-charset\n\t\tdocument.title = [\n\t\t\t( details.failed ? \"\\u2716\" : \"\\u2714\" ),\n\t\t\tdocument.title.replace( /^[\\u2714\\u2716] /i, \"\" )\n\t\t].join( \" \" );\n\t}\n\n\t// clear own sessionStorage items if all tests passed\n\tif ( config.reorder && defined.sessionStorage && details.failed === 0 ) {\n\t\tfor ( i = 0; i < sessionStorage.length; i++ ) {\n\t\t\tkey = sessionStorage.key( i++ );\n\t\t\tif ( key.indexOf( \"qunit-test-\" ) === 0 ) {\n\t\t\t\tsessionStorage.removeItem( key );\n\t\t\t}\n\t\t}\n\t}\n\n\t// scroll back to top to show results\n\tif ( config.scrolltop && window.scrollTo ) {\n\t\twindow.scrollTo( 0, 0 );\n\t}\n});\n\nfunction getNameHtml( name, module ) {\n\tvar nameHtml = \"\";\n\n\tif ( module ) {\n\t\tnameHtml = \"<span class='module-name'>\" + escapeText( module ) + \"</span>: \";\n\t}\n\n\tnameHtml += \"<span class='test-name'>\" + escapeText( name ) + \"</span>\";\n\n\treturn nameHtml;\n}\n\nQUnit.testStart(function( details ) {\n\tvar running, testBlock, bad;\n\n\ttestBlock = id( \"qunit-test-output-\" + details.testId );\n\tif ( testBlock ) {\n\t\ttestBlock.className = \"running\";\n\t} else {\n\n\t\t// Report later registered tests\n\t\tappendTest( details.name, details.testId, details.module );\n\t}\n\n\trunning = id( \"qunit-testresult\" );\n\tif ( running ) {\n\t\tbad = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t+sessionStorage.getItem( \"qunit-test-\" + details.module + \"-\" + details.name );\n\n\t\trunning.innerHTML = ( bad ?\n\t\t\t\"Rerunning previously failed test: <br />\" :\n\t\t\t\"Running: <br />\" ) +\n\t\t\tgetNameHtml( details.name, details.module );\n\t}\n\n});\n\nfunction stripHtml( string ) {\n\t// strip tags, html entity and whitespaces\n\treturn string.replace(/<\\/?[^>]+(>|$)/g, \"\").replace(/\\&quot;/g, \"\").replace(/\\s+/g, \"\");\n}\n\nQUnit.log(function( details ) {\n\tvar assertList, assertLi,\n\t\tmessage, expected, actual, diff,\n\t\tshowDiff = false,\n\t\ttestItem = id( \"qunit-test-output-\" + details.testId );\n\n\tif ( !testItem ) {\n\t\treturn;\n\t}\n\n\tmessage = escapeText( details.message ) || ( details.result ? \"okay\" : \"failed\" );\n\tmessage = \"<span class='test-message'>\" + message + \"</span>\";\n\tmessage += \"<span class='runtime'>@ \" + details.runtime + \" ms</span>\";\n\n\t// pushFailure doesn't provide details.expected\n\t// when it calls, it's implicit to also not show expected and diff stuff\n\t// Also, we need to check details.expected existence, as it can exist and be undefined\n\tif ( !details.result && hasOwn.call( details, \"expected\" ) ) {\n\t\tif ( details.negative ) {\n\t\t\texpected = escapeText( \"NOT \" + QUnit.dump.parse( details.expected ) );\n\t\t} else {\n\t\t\texpected = escapeText( QUnit.dump.parse( details.expected ) );\n\t\t}\n\n\t\tactual = escapeText( QUnit.dump.parse( details.actual ) );\n\t\tmessage += \"<table><tr class='test-expected'><th>Expected: </th><td><pre>\" +\n\t\t\texpected +\n\t\t\t\"</pre></td></tr>\";\n\n\t\tif ( actual !== expected ) {\n\n\t\t\tmessage += \"<tr class='test-actual'><th>Result: </th><td><pre>\" +\n\t\t\t\tactual + \"</pre></td></tr>\";\n\n\t\t\t// Don't show diff if actual or expected are booleans\n\t\t\tif ( !( /^(true|false)$/.test( actual ) ) &&\n\t\t\t\t\t!( /^(true|false)$/.test( expected ) ) ) {\n\t\t\t\tdiff = QUnit.diff( expected, actual );\n\t\t\t\tshowDiff = stripHtml( diff ).length !==\n\t\t\t\t\tstripHtml( expected ).length +\n\t\t\t\t\tstripHtml( actual ).length;\n\t\t\t}\n\n\t\t\t// Don't show diff if expected and actual are totally different\n\t\t\tif ( showDiff ) {\n\t\t\t\tmessage += \"<tr class='test-diff'><th>Diff: </th><td><pre>\" +\n\t\t\t\t\tdiff + \"</pre></td></tr>\";\n\t\t\t}\n\t\t} else if ( expected.indexOf( \"[object Array]\" ) !== -1 ||\n\t\t\t\texpected.indexOf( \"[object Object]\" ) !== -1 ) {\n\t\t\tmessage += \"<tr class='test-message'><th>Message: </th><td>\" +\n\t\t\t\t\"Diff suppressed as the depth of object is more than current max depth (\" +\n\t\t\t\tQUnit.config.maxDepth + \").<p>Hint: Use <code>QUnit.dump.maxDepth</code> to \" +\n\t\t\t\t\" run with a higher max depth or <a href='\" + setUrl({ maxDepth: -1 }) + \"'>\" +\n\t\t\t\t\"Rerun</a> without max depth.</p></td></tr>\";\n\t\t}\n\n\t\tif ( details.source ) {\n\t\t\tmessage += \"<tr class='test-source'><th>Source: </th><td><pre>\" +\n\t\t\t\tescapeText( details.source ) + \"</pre></td></tr>\";\n\t\t}\n\n\t\tmessage += \"</table>\";\n\n\t// this occours when pushFailure is set and we have an extracted stack trace\n\t} else if ( !details.result && details.source ) {\n\t\tmessage += \"<table>\" +\n\t\t\t\"<tr class='test-source'><th>Source: </th><td><pre>\" +\n\t\t\tescapeText( details.source ) + \"</pre></td></tr>\" +\n\t\t\t\"</table>\";\n\t}\n\n\tassertList = testItem.getElementsByTagName( \"ol\" )[ 0 ];\n\n\tassertLi = document.createElement( \"li\" );\n\tassertLi.className = details.result ? \"pass\" : \"fail\";\n\tassertLi.innerHTML = message;\n\tassertList.appendChild( assertLi );\n});\n\nQUnit.testDone(function( details ) {\n\tvar testTitle, time, testItem, assertList,\n\t\tgood, bad, testCounts, skipped, sourceName,\n\t\ttests = id( \"qunit-tests\" );\n\n\tif ( !tests ) {\n\t\treturn;\n\t}\n\n\ttestItem = id( \"qunit-test-output-\" + details.testId );\n\n\tassertList = testItem.getElementsByTagName( \"ol\" )[ 0 ];\n\n\tgood = details.passed;\n\tbad = details.failed;\n\n\t// store result when possible\n\tif ( config.reorder && defined.sessionStorage ) {\n\t\tif ( bad ) {\n\t\t\tsessionStorage.setItem( \"qunit-test-\" + details.module + \"-\" + details.name, bad );\n\t\t} else {\n\t\t\tsessionStorage.removeItem( \"qunit-test-\" + details.module + \"-\" + details.name );\n\t\t}\n\t}\n\n\tif ( bad === 0 ) {\n\n\t\t// Collapse the passing tests\n\t\taddClass( assertList, \"qunit-collapsed\" );\n\t} else if ( bad && config.collapse && !collapseNext ) {\n\n\t\t// Skip collapsing the first failing test\n\t\tcollapseNext = true;\n\t} else {\n\n\t\t// Collapse remaining tests\n\t\taddClass( assertList, \"qunit-collapsed\" );\n\t}\n\n\t// testItem.firstChild is the test name\n\ttestTitle = testItem.firstChild;\n\n\ttestCounts = bad ?\n\t\t\"<b class='failed'>\" + bad + \"</b>, \" + \"<b class='passed'>\" + good + \"</b>, \" :\n\t\t\"\";\n\n\ttestTitle.innerHTML += \" <b class='counts'>(\" + testCounts +\n\t\tdetails.assertions.length + \")</b>\";\n\n\tif ( details.skipped ) {\n\t\ttestItem.className = \"skipped\";\n\t\tskipped = document.createElement( \"em\" );\n\t\tskipped.className = \"qunit-skipped-label\";\n\t\tskipped.innerHTML = \"skipped\";\n\t\ttestItem.insertBefore( skipped, testTitle );\n\t} else {\n\t\taddEvent( testTitle, \"click\", function() {\n\t\t\ttoggleClass( assertList, \"qunit-collapsed\" );\n\t\t});\n\n\t\ttestItem.className = bad ? \"fail\" : \"pass\";\n\n\t\ttime = document.createElement( \"span\" );\n\t\ttime.className = \"runtime\";\n\t\ttime.innerHTML = details.runtime + \" ms\";\n\t\ttestItem.insertBefore( time, assertList );\n\t}\n\n\t// Show the source of the test when showing assertions\n\tif ( details.source ) {\n\t\tsourceName = document.createElement( \"p\" );\n\t\tsourceName.innerHTML = \"<strong>Source: </strong>\" + details.source;\n\t\taddClass( sourceName, \"qunit-source\" );\n\t\tif ( bad === 0 ) {\n\t\t\taddClass( sourceName, \"qunit-collapsed\" );\n\t\t}\n\t\taddEvent( testTitle, \"click\", function() {\n\t\t\ttoggleClass( sourceName, \"qunit-collapsed\" );\n\t\t});\n\t\ttestItem.appendChild( sourceName );\n\t}\n});\n\nif ( defined.document ) {\n\n\t// Avoid readyState issue with phantomjs\n\t// Ref: #818\n\tvar notPhantom = ( function( p ) {\n\t\treturn !( p && p.version && p.version.major > 0 );\n\t} )( window.phantom );\n\n\tif ( notPhantom && document.readyState === \"complete\" ) {\n\t\tQUnit.load();\n\t} else {\n\t\taddEvent( window, \"load\", QUnit.load );\n\t}\n} else {\n\tconfig.pageLoaded = true;\n\tconfig.autorun = true;\n}\n\n})();\n"]},"hash":"719be2808e65ada44d295c5c72a7232667eeb1a9"}
