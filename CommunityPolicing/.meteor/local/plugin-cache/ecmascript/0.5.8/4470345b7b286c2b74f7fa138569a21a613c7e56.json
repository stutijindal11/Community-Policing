{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/assert.js","filenameRelative":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/assert.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/assert.js.map","sourceFileName":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/assert.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"assert"},"ignored":false,"code":"function Assert(testContext) {\n\tthis.test = testContext;\n}\n\n// Assert helpers\nQUnit.assert = Assert.prototype = {\n\n\t// Specify the number of expected assertions to guarantee that failed test\n\t// (no assertions are run at all) don't slip through.\n\texpect: function () {\n\t\tfunction expect(asserts) {\n\t\t\tif (arguments.length === 1) {\n\t\t\t\tthis.test.expected = asserts;\n\t\t\t} else {\n\t\t\t\treturn this.test.expected;\n\t\t\t}\n\t\t}\n\n\t\treturn expect;\n\t}(),\n\n\t// Increment this Test's semaphore counter, then return a function that\n\t// decrements that counter a maximum of once.\n\tasync: function () {\n\t\tfunction async(count) {\n\t\t\tvar test = this.test,\n\t\t\t    popped = false,\n\t\t\t    acceptCallCount = count;\n\n\t\t\tif (typeof acceptCallCount === \"undefined\") {\n\t\t\t\tacceptCallCount = 1;\n\t\t\t}\n\n\t\t\ttest.semaphore += 1;\n\t\t\ttest.usedAsync = true;\n\t\t\tpauseProcessing();\n\n\t\t\treturn function () {\n\t\t\t\tfunction done() {\n\n\t\t\t\t\tif (popped) {\n\t\t\t\t\t\ttest.pushFailure(\"Too many calls to the `assert.async` callback\", sourceFromStacktrace(2));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tacceptCallCount -= 1;\n\t\t\t\t\tif (acceptCallCount > 0) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttest.semaphore -= 1;\n\t\t\t\t\tpopped = true;\n\t\t\t\t\tresumeProcessing();\n\t\t\t\t}\n\n\t\t\t\treturn done;\n\t\t\t}();\n\t\t}\n\n\t\treturn async;\n\t}(),\n\n\t// Exports test.push() to the user API\n\tpush: function () {\n\t\tfunction push() /* result, actual, expected, message, negative */{\n\t\t\tvar assert = this,\n\t\t\t    currentTest = assert instanceof Assert && assert.test || QUnit.config.current;\n\n\t\t\t// Backwards compatibility fix.\n\t\t\t// Allows the direct use of global exported assertions and QUnit.assert.*\n\t\t\t// Although, it's use is not recommended as it can leak assertions\n\t\t\t// to other tests from async tests, because we only get a reference to the current test,\n\t\t\t// not exactly the test where assertion were intended to be called.\n\t\t\tif (!currentTest) {\n\t\t\t\tthrow new Error(\"assertion outside test context, in \" + sourceFromStacktrace(2));\n\t\t\t}\n\n\t\t\tif (currentTest.usedAsync === true && currentTest.semaphore === 0) {\n\t\t\t\tcurrentTest.pushFailure(\"Assertion after the final `assert.async` was resolved\", sourceFromStacktrace(2));\n\n\t\t\t\t// Allow this assertion to continue running anyway...\n\t\t\t}\n\n\t\t\tif (!(assert instanceof Assert)) {\n\t\t\t\tassert = currentTest.assert;\n\t\t\t}\n\t\t\treturn assert.test.push.apply(assert.test, arguments);\n\t\t}\n\n\t\treturn push;\n\t}(),\n\n\tok: function () {\n\t\tfunction ok(result, message) {\n\t\t\tmessage = message || (result ? \"okay\" : \"failed, expected argument to be truthy, was: \" + QUnit.dump.parse(result));\n\t\t\tthis.push(!!result, result, true, message);\n\t\t}\n\n\t\treturn ok;\n\t}(),\n\n\tnotOk: function () {\n\t\tfunction notOk(result, message) {\n\t\t\tmessage = message || (!result ? \"okay\" : \"failed, expected argument to be falsy, was: \" + QUnit.dump.parse(result));\n\t\t\tthis.push(!result, result, false, message, true);\n\t\t}\n\n\t\treturn notOk;\n\t}(),\n\n\tequal: function () {\n\t\tfunction equal(actual, expected, message) {\n\t\t\t/*jshint eqeqeq:false */\n\t\t\tthis.push(expected == actual, actual, expected, message);\n\t\t}\n\n\t\treturn equal;\n\t}(),\n\n\tnotEqual: function () {\n\t\tfunction notEqual(actual, expected, message) {\n\t\t\t/*jshint eqeqeq:false */\n\t\t\tthis.push(expected != actual, actual, expected, message, true);\n\t\t}\n\n\t\treturn notEqual;\n\t}(),\n\n\tpropEqual: function () {\n\t\tfunction propEqual(actual, expected, message) {\n\t\t\tactual = objectValues(actual);\n\t\t\texpected = objectValues(expected);\n\t\t\tthis.push(QUnit.equiv(actual, expected), actual, expected, message);\n\t\t}\n\n\t\treturn propEqual;\n\t}(),\n\n\tnotPropEqual: function () {\n\t\tfunction notPropEqual(actual, expected, message) {\n\t\t\tactual = objectValues(actual);\n\t\t\texpected = objectValues(expected);\n\t\t\tthis.push(!QUnit.equiv(actual, expected), actual, expected, message, true);\n\t\t}\n\n\t\treturn notPropEqual;\n\t}(),\n\n\tdeepEqual: function () {\n\t\tfunction deepEqual(actual, expected, message) {\n\t\t\tthis.push(QUnit.equiv(actual, expected), actual, expected, message);\n\t\t}\n\n\t\treturn deepEqual;\n\t}(),\n\n\tnotDeepEqual: function () {\n\t\tfunction notDeepEqual(actual, expected, message) {\n\t\t\tthis.push(!QUnit.equiv(actual, expected), actual, expected, message, true);\n\t\t}\n\n\t\treturn notDeepEqual;\n\t}(),\n\n\tstrictEqual: function () {\n\t\tfunction strictEqual(actual, expected, message) {\n\t\t\tthis.push(expected === actual, actual, expected, message);\n\t\t}\n\n\t\treturn strictEqual;\n\t}(),\n\n\tnotStrictEqual: function () {\n\t\tfunction notStrictEqual(actual, expected, message) {\n\t\t\tthis.push(expected !== actual, actual, expected, message, true);\n\t\t}\n\n\t\treturn notStrictEqual;\n\t}(),\n\n\t\"throws\": function () {\n\t\tfunction throws(block, expected, message) {\n\t\t\tvar actual,\n\t\t\t    expectedType,\n\t\t\t    expectedOutput = expected,\n\t\t\t    ok = false,\n\t\t\t    currentTest = this instanceof Assert && this.test || QUnit.config.current;\n\n\t\t\t// 'expected' is optional unless doing string comparison\n\t\t\tif (message == null && typeof expected === \"string\") {\n\t\t\t\tmessage = expected;\n\t\t\t\texpected = null;\n\t\t\t}\n\n\t\t\tcurrentTest.ignoreGlobalErrors = true;\n\t\t\ttry {\n\t\t\t\tblock.call(currentTest.testEnvironment);\n\t\t\t} catch (e) {\n\t\t\t\tactual = e;\n\t\t\t}\n\t\t\tcurrentTest.ignoreGlobalErrors = false;\n\n\t\t\tif (actual) {\n\t\t\t\texpectedType = QUnit.objectType(expected);\n\n\t\t\t\t// we don't want to validate thrown error\n\t\t\t\tif (!expected) {\n\t\t\t\t\tok = true;\n\t\t\t\t\texpectedOutput = null;\n\n\t\t\t\t\t// expected is a regexp\n\t\t\t\t} else if (expectedType === \"regexp\") {\n\t\t\t\t\t\tok = expected.test(errorString(actual));\n\n\t\t\t\t\t\t// expected is a string\n\t\t\t\t\t} else if (expectedType === \"string\") {\n\t\t\t\t\t\t\tok = expected === errorString(actual);\n\n\t\t\t\t\t\t\t// expected is a constructor, maybe an Error constructor\n\t\t\t\t\t\t} else if (expectedType === \"function\" && actual instanceof expected) {\n\t\t\t\t\t\t\t\tok = true;\n\n\t\t\t\t\t\t\t\t// expected is an Error object\n\t\t\t\t\t\t\t} else if (expectedType === \"object\") {\n\t\t\t\t\t\t\t\t\tok = actual instanceof expected.constructor && actual.name === expected.name && actual.message === expected.message;\n\n\t\t\t\t\t\t\t\t\t// expected is a validation function which returns true if validation passed\n\t\t\t\t\t\t\t\t} else if (expectedType === \"function\" && expected.call({}, actual) === true) {\n\t\t\t\t\t\t\t\t\t\texpectedOutput = null;\n\t\t\t\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurrentTest.assert.push(ok, actual, expectedOutput, message);\n\t\t}\n\n\t\treturn throws;\n\t}()\n};\n\n// Provide an alternative to assert.throws(), for environments that consider throws a reserved word\n// Known to us are: Closure Compiler, Narwhal\n(function () {\n\t/*jshint sub:true */\n\tAssert.prototype.raises = Assert.prototype[\"throws\"];\n})();\n\nfunction errorString(error) {\n\tvar name,\n\t    message,\n\t    resultErrorString = error.toString();\n\tif (resultErrorString.substring(0, 7) === \"[object\") {\n\t\tname = error.name ? error.name.toString() : \"Error\";\n\t\tmessage = error.message ? error.message.toString() : \"\";\n\t\tif (name && message) {\n\t\t\treturn name + \": \" + message;\n\t\t} else if (name) {\n\t\t\treturn name;\n\t\t} else if (message) {\n\t\t\treturn message;\n\t\t} else {\n\t\t\treturn \"Error\";\n\t\t}\n\t} else {\n\t\treturn resultErrorString;\n\t}\n}","ast":null,"map":{"version":3,"sources":["/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/assert.js"],"names":[],"mappings":"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","file":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/assert.js.map","sourcesContent":["function Assert( testContext ) {\n\tthis.test = testContext;\n}\n\n// Assert helpers\nQUnit.assert = Assert.prototype = {\n\n\t// Specify the number of expected assertions to guarantee that failed test\n\t// (no assertions are run at all) don't slip through.\n\texpect: function( asserts ) {\n\t\tif ( arguments.length === 1 ) {\n\t\t\tthis.test.expected = asserts;\n\t\t} else {\n\t\t\treturn this.test.expected;\n\t\t}\n\t},\n\n\t// Increment this Test's semaphore counter, then return a function that\n\t// decrements that counter a maximum of once.\n\tasync: function( count ) {\n\t\tvar test = this.test,\n\t\t\tpopped = false,\n\t\t\tacceptCallCount = count;\n\n\t\tif ( typeof acceptCallCount === \"undefined\" ) {\n\t\t\tacceptCallCount = 1;\n\t\t}\n\n\t\ttest.semaphore += 1;\n\t\ttest.usedAsync = true;\n\t\tpauseProcessing();\n\n\t\treturn function done() {\n\n\t\t\tif ( popped ) {\n\t\t\t\ttest.pushFailure( \"Too many calls to the `assert.async` callback\",\n\t\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tacceptCallCount -= 1;\n\t\t\tif ( acceptCallCount > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttest.semaphore -= 1;\n\t\t\tpopped = true;\n\t\t\tresumeProcessing();\n\t\t};\n\t},\n\n\t// Exports test.push() to the user API\n\tpush: function( /* result, actual, expected, message, negative */ ) {\n\t\tvar assert = this,\n\t\t\tcurrentTest = ( assert instanceof Assert && assert.test ) || QUnit.config.current;\n\n\t\t// Backwards compatibility fix.\n\t\t// Allows the direct use of global exported assertions and QUnit.assert.*\n\t\t// Although, it's use is not recommended as it can leak assertions\n\t\t// to other tests from async tests, because we only get a reference to the current test,\n\t\t// not exactly the test where assertion were intended to be called.\n\t\tif ( !currentTest ) {\n\t\t\tthrow new Error( \"assertion outside test context, in \" + sourceFromStacktrace( 2 ) );\n\t\t}\n\n\t\tif ( currentTest.usedAsync === true && currentTest.semaphore === 0 ) {\n\t\t\tcurrentTest.pushFailure( \"Assertion after the final `assert.async` was resolved\",\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\n\t\t\t// Allow this assertion to continue running anyway...\n\t\t}\n\n\t\tif ( !( assert instanceof Assert ) ) {\n\t\t\tassert = currentTest.assert;\n\t\t}\n\t\treturn assert.test.push.apply( assert.test, arguments );\n\t},\n\n\tok: function( result, message ) {\n\t\tmessage = message || ( result ? \"okay\" : \"failed, expected argument to be truthy, was: \" +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tthis.push( !!result, result, true, message );\n\t},\n\n\tnotOk: function( result, message ) {\n\t\tmessage = message || ( !result ? \"okay\" : \"failed, expected argument to be falsy, was: \" +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tthis.push( !result, result, false, message, true );\n\t},\n\n\tequal: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.push( expected == actual, actual, expected, message );\n\t},\n\n\tnotEqual: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.push( expected != actual, actual, expected, message, true );\n\t},\n\n\tpropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.push( QUnit.equiv( actual, expected ), actual, expected, message );\n\t},\n\n\tnotPropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.push( !QUnit.equiv( actual, expected ), actual, expected, message, true );\n\t},\n\n\tdeepEqual: function( actual, expected, message ) {\n\t\tthis.push( QUnit.equiv( actual, expected ), actual, expected, message );\n\t},\n\n\tnotDeepEqual: function( actual, expected, message ) {\n\t\tthis.push( !QUnit.equiv( actual, expected ), actual, expected, message, true );\n\t},\n\n\tstrictEqual: function( actual, expected, message ) {\n\t\tthis.push( expected === actual, actual, expected, message );\n\t},\n\n\tnotStrictEqual: function( actual, expected, message ) {\n\t\tthis.push( expected !== actual, actual, expected, message, true );\n\t},\n\n\t\"throws\": function( block, expected, message ) {\n\t\tvar actual, expectedType,\n\t\t\texpectedOutput = expected,\n\t\t\tok = false,\n\t\t\tcurrentTest = ( this instanceof Assert && this.test ) || QUnit.config.current;\n\n\t\t// 'expected' is optional unless doing string comparison\n\t\tif ( message == null && typeof expected === \"string\" ) {\n\t\t\tmessage = expected;\n\t\t\texpected = null;\n\t\t}\n\n\t\tcurrentTest.ignoreGlobalErrors = true;\n\t\ttry {\n\t\t\tblock.call( currentTest.testEnvironment );\n\t\t} catch (e) {\n\t\t\tactual = e;\n\t\t}\n\t\tcurrentTest.ignoreGlobalErrors = false;\n\n\t\tif ( actual ) {\n\t\t\texpectedType = QUnit.objectType( expected );\n\n\t\t\t// we don't want to validate thrown error\n\t\t\tif ( !expected ) {\n\t\t\t\tok = true;\n\t\t\t\texpectedOutput = null;\n\n\t\t\t// expected is a regexp\n\t\t\t} else if ( expectedType === \"regexp\" ) {\n\t\t\t\tok = expected.test( errorString( actual ) );\n\n\t\t\t// expected is a string\n\t\t\t} else if ( expectedType === \"string\" ) {\n\t\t\t\tok = expected === errorString( actual );\n\n\t\t\t// expected is a constructor, maybe an Error constructor\n\t\t\t} else if ( expectedType === \"function\" && actual instanceof expected ) {\n\t\t\t\tok = true;\n\n\t\t\t// expected is an Error object\n\t\t\t} else if ( expectedType === \"object\" ) {\n\t\t\t\tok = actual instanceof expected.constructor &&\n\t\t\t\t\tactual.name === expected.name &&\n\t\t\t\t\tactual.message === expected.message;\n\n\t\t\t// expected is a validation function which returns true if validation passed\n\t\t\t} else if ( expectedType === \"function\" && expected.call( {}, actual ) === true ) {\n\t\t\t\texpectedOutput = null;\n\t\t\t\tok = true;\n\t\t\t}\n\t\t}\n\n\t\tcurrentTest.assert.push( ok, actual, expectedOutput, message );\n\t}\n};\n\n// Provide an alternative to assert.throws(), for environments that consider throws a reserved word\n// Known to us are: Closure Compiler, Narwhal\n(function() {\n\t/*jshint sub:true */\n\tAssert.prototype.raises = Assert.prototype[ \"throws\" ];\n}());\n\nfunction errorString( error ) {\n\tvar name, message,\n\t\tresultErrorString = error.toString();\n\tif ( resultErrorString.substring( 0, 7 ) === \"[object\" ) {\n\t\tname = error.name ? error.name.toString() : \"Error\";\n\t\tmessage = error.message ? error.message.toString() : \"\";\n\t\tif ( name && message ) {\n\t\t\treturn name + \": \" + message;\n\t\t} else if ( name ) {\n\t\t\treturn name;\n\t\t} else if ( message ) {\n\t\t\treturn message;\n\t\t} else {\n\t\t\treturn \"Error\";\n\t\t}\n\t} else {\n\t\treturn resultErrorString;\n\t}\n}\n"]},"hash":"4470345b7b286c2b74f7fa138569a21a613c7e56"}
