{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/core.js","filenameRelative":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/core.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/core.js.map","sourceFileName":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/core.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"core"},"ignored":false,"code":"QUnit.urlParams = urlParams;\n\n// Figure out if we're running the tests from a server or not\nQUnit.isLocal = !(defined.document && window.location.protocol !== \"file:\");\n\n// Expose the current QUnit version\nQUnit.version = \"@VERSION\";\n\nextend(QUnit, {\n\n\t// call on start of module test to prepend name to all tests\n\tmodule: function module(name, testEnvironment, executeNow) {\n\t\tvar module, moduleFns;\n\t\tvar currentModule = config.currentModule;\n\n\t\tif (arguments.length === 2) {\n\t\t\tif (testEnvironment instanceof Function) {\n\t\t\t\texecuteNow = testEnvironment;\n\t\t\t\ttestEnvironment = undefined;\n\t\t\t}\n\t\t}\n\n\t\t// DEPRECATED: handles setup/teardown functions,\n\t\t// beforeEach and afterEach should be used instead\n\t\tif (testEnvironment && testEnvironment.setup) {\n\t\t\ttestEnvironment.beforeEach = testEnvironment.setup;\n\t\t\tdelete testEnvironment.setup;\n\t\t}\n\t\tif (testEnvironment && testEnvironment.teardown) {\n\t\t\ttestEnvironment.afterEach = testEnvironment.teardown;\n\t\t\tdelete testEnvironment.teardown;\n\t\t}\n\n\t\tmodule = createModule();\n\n\t\tmoduleFns = {\n\t\t\tbeforeEach: setHook(module, \"beforeEach\"),\n\t\t\tafterEach: setHook(module, \"afterEach\")\n\t\t};\n\n\t\tif (executeNow instanceof Function) {\n\t\t\tconfig.moduleStack.push(module);\n\t\t\tsetCurrentModule(module);\n\t\t\texecuteNow.call(module.testEnvironment, moduleFns);\n\t\t\tconfig.moduleStack.pop();\n\t\t\tmodule = module.parentModule || currentModule;\n\t\t}\n\n\t\tsetCurrentModule(module);\n\n\t\tfunction createModule() {\n\t\t\tvar parentModule = config.moduleStack.length ? config.moduleStack.slice(-1)[0] : null;\n\t\t\tvar moduleName = parentModule !== null ? [parentModule.name, name].join(\" > \") : name;\n\t\t\tvar module = {\n\t\t\t\tname: moduleName,\n\t\t\t\tparentModule: parentModule,\n\t\t\t\ttests: []\n\t\t\t};\n\n\t\t\tvar env = {};\n\t\t\tif (parentModule) {\n\t\t\t\textend(env, parentModule.testEnvironment);\n\t\t\t\tdelete env.beforeEach;\n\t\t\t\tdelete env.afterEach;\n\t\t\t}\n\t\t\textend(env, testEnvironment);\n\t\t\tmodule.testEnvironment = env;\n\n\t\t\tconfig.modules.push(module);\n\t\t\treturn module;\n\t\t}\n\n\t\tfunction setCurrentModule(module) {\n\t\t\tconfig.currentModule = module;\n\t\t}\n\t},\n\n\t// DEPRECATED: QUnit.asyncTest() will be removed in QUnit 2.0.\n\tasyncTest: asyncTest,\n\n\ttest: test,\n\n\tskip: skip,\n\n\tonly: only,\n\n\t// DEPRECATED: The functionality of QUnit.start() will be altered in QUnit 2.0.\n\t// In QUnit 2.0, invoking it will ONLY affect the `QUnit.config.autostart` blocking behavior.\n\tstart: function start(count) {\n\t\tvar globalStartAlreadyCalled = globalStartCalled;\n\n\t\tif (!config.current) {\n\t\t\tglobalStartCalled = true;\n\n\t\t\tif (runStarted) {\n\t\t\t\tthrow new Error(\"Called start() outside of a test context while already started\");\n\t\t\t} else if (globalStartAlreadyCalled || count > 1) {\n\t\t\t\tthrow new Error(\"Called start() outside of a test context too many times\");\n\t\t\t} else if (config.autostart) {\n\t\t\t\tthrow new Error(\"Called start() outside of a test context when \" + \"QUnit.config.autostart was true\");\n\t\t\t} else if (!config.pageLoaded) {\n\n\t\t\t\t// The page isn't completely loaded yet, so bail out and let `QUnit.load` handle it\n\t\t\t\tconfig.autostart = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\n\t\t\t// If a test is running, adjust its semaphore\n\t\t\tconfig.current.semaphore -= count || 1;\n\n\t\t\t// If semaphore is non-numeric, throw error\n\t\t\tif (isNaN(config.current.semaphore)) {\n\t\t\t\tconfig.current.semaphore = 0;\n\n\t\t\t\tQUnit.pushFailure(\"Called start() with a non-numeric decrement.\", sourceFromStacktrace(2));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Don't start until equal number of stop-calls\n\t\t\tif (config.current.semaphore > 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// throw an Error if start is called more often than stop\n\t\t\tif (config.current.semaphore < 0) {\n\t\t\t\tconfig.current.semaphore = 0;\n\n\t\t\t\tQUnit.pushFailure(\"Called start() while already started (test's semaphore was 0 already)\", sourceFromStacktrace(2));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tresumeProcessing();\n\t},\n\n\t// DEPRECATED: QUnit.stop() will be removed in QUnit 2.0.\n\tstop: function stop(count) {\n\n\t\t// If there isn't a test running, don't allow QUnit.stop() to be called\n\t\tif (!config.current) {\n\t\t\tthrow new Error(\"Called stop() outside of a test context\");\n\t\t}\n\n\t\t// If a test is running, adjust its semaphore\n\t\tconfig.current.semaphore += count || 1;\n\n\t\tpauseProcessing();\n\t},\n\n\tconfig: config,\n\n\tis: is,\n\n\tobjectType: objectType,\n\n\textend: extend,\n\n\tload: function load() {\n\t\tconfig.pageLoaded = true;\n\n\t\t// Initialize the configuration options\n\t\textend(config, {\n\t\t\tstats: { all: 0, bad: 0 },\n\t\t\tmoduleStats: { all: 0, bad: 0 },\n\t\t\tstarted: 0,\n\t\t\tupdateRate: 1000,\n\t\t\tautostart: true,\n\t\t\tfilter: \"\"\n\t\t}, true);\n\n\t\tconfig.blocking = false;\n\n\t\tif (config.autostart) {\n\t\t\tresumeProcessing();\n\t\t}\n\t},\n\n\tstack: function stack(offset) {\n\t\toffset = (offset || 0) + 2;\n\t\treturn sourceFromStacktrace(offset);\n\t}\n});\n\nregisterLoggingCallbacks(QUnit);\n\nfunction begin() {\n\tvar i,\n\t    l,\n\t    modulesLog = [];\n\n\t// If the test run hasn't officially begun yet\n\tif (!config.started) {\n\n\t\t// Record the time of the test run's beginning\n\t\tconfig.started = now();\n\n\t\tverifyLoggingCallbacks();\n\n\t\t// Delete the loose unnamed module if unused.\n\t\tif (config.modules[0].name === \"\" && config.modules[0].tests.length === 0) {\n\t\t\tconfig.modules.shift();\n\t\t}\n\n\t\t// Avoid unnecessary information by not logging modules' test environments\n\t\tfor (i = 0, l = config.modules.length; i < l; i++) {\n\t\t\tmodulesLog.push({\n\t\t\t\tname: config.modules[i].name,\n\t\t\t\ttests: config.modules[i].tests\n\t\t\t});\n\t\t}\n\n\t\t// The test run is officially beginning now\n\t\trunLoggingCallbacks(\"begin\", {\n\t\t\ttotalTests: Test.count,\n\t\t\tmodules: modulesLog\n\t\t});\n\t}\n\n\tconfig.blocking = false;\n\tprocess(true);\n}\n\nfunction process(last) {\n\tfunction next() {\n\t\tprocess(last);\n\t}\n\tvar start = now();\n\tconfig.depth = (config.depth || 0) + 1;\n\n\twhile (config.queue.length && !config.blocking) {\n\t\tif (!defined.setTimeout || config.updateRate <= 0 || now() - start < config.updateRate) {\n\t\t\tif (config.current) {\n\n\t\t\t\t// Reset async tracking for each phase of the Test lifecycle\n\t\t\t\tconfig.current.usedAsync = false;\n\t\t\t}\n\t\t\tconfig.queue.shift()();\n\t\t} else {\n\t\t\tsetTimeout(next, 13);\n\t\t\tbreak;\n\t\t}\n\t}\n\tconfig.depth--;\n\tif (last && !config.blocking && !config.queue.length && config.depth === 0) {\n\t\tdone();\n\t}\n}\n\nfunction pauseProcessing() {\n\tconfig.blocking = true;\n\n\tif (config.testTimeout && defined.setTimeout) {\n\t\tclearTimeout(config.timeout);\n\t\tconfig.timeout = setTimeout(function () {\n\t\t\tif (config.current) {\n\t\t\t\tconfig.current.semaphore = 0;\n\t\t\t\tQUnit.pushFailure(\"Test timed out\", sourceFromStacktrace(2));\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Test timed out\");\n\t\t\t}\n\t\t\tresumeProcessing();\n\t\t}, config.testTimeout);\n\t}\n}\n\nfunction resumeProcessing() {\n\trunStarted = true;\n\n\t// A slight delay to allow this iteration of the event loop to finish (more assertions, etc.)\n\tif (defined.setTimeout) {\n\t\tsetTimeout(function () {\n\t\t\tif (config.current && config.current.semaphore > 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (config.timeout) {\n\t\t\t\tclearTimeout(config.timeout);\n\t\t\t}\n\n\t\t\tbegin();\n\t\t}, 13);\n\t} else {\n\t\tbegin();\n\t}\n}\n\nfunction done() {\n\tvar runtime, passed;\n\n\tconfig.autorun = true;\n\n\t// Log the last module results\n\tif (config.previousModule) {\n\t\trunLoggingCallbacks(\"moduleDone\", {\n\t\t\tname: config.previousModule.name,\n\t\t\ttests: config.previousModule.tests,\n\t\t\tfailed: config.moduleStats.bad,\n\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\ttotal: config.moduleStats.all,\n\t\t\truntime: now() - config.moduleStats.started\n\t\t});\n\t}\n\tdelete config.previousModule;\n\n\truntime = now() - config.started;\n\tpassed = config.stats.all - config.stats.bad;\n\n\trunLoggingCallbacks(\"done\", {\n\t\tfailed: config.stats.bad,\n\t\tpassed: passed,\n\t\ttotal: config.stats.all,\n\t\truntime: runtime\n\t});\n}\n\nfunction setHook(module, hookName) {\n\tif (module.testEnvironment === undefined) {\n\t\tmodule.testEnvironment = {};\n\t}\n\n\treturn function (callback) {\n\t\tmodule.testEnvironment[hookName] = callback;\n\t};\n}","ast":null,"map":{"version":3,"sources":["/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/core.js"],"names":[],"mappings":"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","file":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/core.js.map","sourcesContent":["QUnit.urlParams = urlParams;\n\n// Figure out if we're running the tests from a server or not\nQUnit.isLocal = !( defined.document && window.location.protocol !== \"file:\" );\n\n// Expose the current QUnit version\nQUnit.version = \"@VERSION\";\n\nextend( QUnit, {\n\n\t// call on start of module test to prepend name to all tests\n\tmodule: function( name, testEnvironment, executeNow ) {\n\t\tvar module, moduleFns;\n\t\tvar currentModule = config.currentModule;\n\n\t\tif ( arguments.length === 2 ) {\n\t\t\tif ( testEnvironment instanceof Function ) {\n\t\t\t\texecuteNow = testEnvironment;\n\t\t\t\ttestEnvironment = undefined;\n\t\t\t}\n\t\t}\n\n\t\t// DEPRECATED: handles setup/teardown functions,\n\t\t// beforeEach and afterEach should be used instead\n\t\tif ( testEnvironment && testEnvironment.setup ) {\n\t\t\ttestEnvironment.beforeEach = testEnvironment.setup;\n\t\t\tdelete testEnvironment.setup;\n\t\t}\n\t\tif ( testEnvironment && testEnvironment.teardown ) {\n\t\t\ttestEnvironment.afterEach = testEnvironment.teardown;\n\t\t\tdelete testEnvironment.teardown;\n\t\t}\n\n\t\tmodule = createModule();\n\n\t\tmoduleFns = {\n\t\t\tbeforeEach: setHook( module, \"beforeEach\" ),\n\t\t\tafterEach: setHook( module, \"afterEach\" )\n\t\t};\n\n\t\tif ( executeNow instanceof Function ) {\n\t\t\tconfig.moduleStack.push( module );\n\t\t\tsetCurrentModule( module );\n\t\t\texecuteNow.call( module.testEnvironment, moduleFns );\n\t\t\tconfig.moduleStack.pop();\n\t\t\tmodule = module.parentModule || currentModule;\n\t\t}\n\n\t\tsetCurrentModule( module );\n\n\t\tfunction createModule() {\n\t\t\tvar parentModule = config.moduleStack.length ?\n\t\t\t\tconfig.moduleStack.slice( -1 )[ 0 ] : null;\n\t\t\tvar moduleName = parentModule !== null ?\n\t\t\t\t[ parentModule.name, name ].join( \" > \" ) : name;\n\t\t\tvar module = {\n\t\t\t\tname: moduleName,\n\t\t\t\tparentModule: parentModule,\n\t\t\t\ttests: []\n\t\t\t};\n\n\t\t\tvar env = {};\n\t\t\tif ( parentModule ) {\n\t\t\t\textend( env, parentModule.testEnvironment );\n\t\t\t\tdelete env.beforeEach;\n\t\t\t\tdelete env.afterEach;\n\t\t\t}\n\t\t\textend( env, testEnvironment );\n\t\t\tmodule.testEnvironment = env;\n\n\t\t\tconfig.modules.push( module );\n\t\t\treturn module;\n\t\t}\n\n\t\tfunction setCurrentModule( module ) {\n\t\t\tconfig.currentModule = module;\n\t\t}\n\n\t},\n\n\t// DEPRECATED: QUnit.asyncTest() will be removed in QUnit 2.0.\n\tasyncTest: asyncTest,\n\n\ttest: test,\n\n\tskip: skip,\n\n\tonly: only,\n\n\t// DEPRECATED: The functionality of QUnit.start() will be altered in QUnit 2.0.\n\t// In QUnit 2.0, invoking it will ONLY affect the `QUnit.config.autostart` blocking behavior.\n\tstart: function( count ) {\n\t\tvar globalStartAlreadyCalled = globalStartCalled;\n\n\t\tif ( !config.current ) {\n\t\t\tglobalStartCalled = true;\n\n\t\t\tif ( runStarted ) {\n\t\t\t\tthrow new Error( \"Called start() outside of a test context while already started\" );\n\t\t\t} else if ( globalStartAlreadyCalled || count > 1 ) {\n\t\t\t\tthrow new Error( \"Called start() outside of a test context too many times\" );\n\t\t\t} else if ( config.autostart ) {\n\t\t\t\tthrow new Error( \"Called start() outside of a test context when \" +\n\t\t\t\t\t\"QUnit.config.autostart was true\" );\n\t\t\t} else if ( !config.pageLoaded ) {\n\n\t\t\t\t// The page isn't completely loaded yet, so bail out and let `QUnit.load` handle it\n\t\t\t\tconfig.autostart = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\n\t\t\t// If a test is running, adjust its semaphore\n\t\t\tconfig.current.semaphore -= count || 1;\n\n\t\t\t// If semaphore is non-numeric, throw error\n\t\t\tif ( isNaN( config.current.semaphore ) ) {\n\t\t\t\tconfig.current.semaphore = 0;\n\n\t\t\t\tQUnit.pushFailure(\n\t\t\t\t\t\"Called start() with a non-numeric decrement.\",\n\t\t\t\t\tsourceFromStacktrace( 2 )\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Don't start until equal number of stop-calls\n\t\t\tif ( config.current.semaphore > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// throw an Error if start is called more often than stop\n\t\t\tif ( config.current.semaphore < 0 ) {\n\t\t\t\tconfig.current.semaphore = 0;\n\n\t\t\t\tQUnit.pushFailure(\n\t\t\t\t\t\"Called start() while already started (test's semaphore was 0 already)\",\n\t\t\t\t\tsourceFromStacktrace( 2 )\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tresumeProcessing();\n\t},\n\n\t// DEPRECATED: QUnit.stop() will be removed in QUnit 2.0.\n\tstop: function( count ) {\n\n\t\t// If there isn't a test running, don't allow QUnit.stop() to be called\n\t\tif ( !config.current ) {\n\t\t\tthrow new Error( \"Called stop() outside of a test context\" );\n\t\t}\n\n\t\t// If a test is running, adjust its semaphore\n\t\tconfig.current.semaphore += count || 1;\n\n\t\tpauseProcessing();\n\t},\n\n\tconfig: config,\n\n\tis: is,\n\n\tobjectType: objectType,\n\n\textend: extend,\n\n\tload: function() {\n\t\tconfig.pageLoaded = true;\n\n\t\t// Initialize the configuration options\n\t\textend( config, {\n\t\t\tstats: { all: 0, bad: 0 },\n\t\t\tmoduleStats: { all: 0, bad: 0 },\n\t\t\tstarted: 0,\n\t\t\tupdateRate: 1000,\n\t\t\tautostart: true,\n\t\t\tfilter: \"\"\n\t\t}, true );\n\n\t\tconfig.blocking = false;\n\n\t\tif ( config.autostart ) {\n\t\t\tresumeProcessing();\n\t\t}\n\t},\n\n\tstack: function( offset ) {\n\t\toffset = ( offset || 0 ) + 2;\n\t\treturn sourceFromStacktrace( offset );\n\t}\n});\n\nregisterLoggingCallbacks( QUnit );\n\nfunction begin() {\n\tvar i, l,\n\t\tmodulesLog = [];\n\n\t// If the test run hasn't officially begun yet\n\tif ( !config.started ) {\n\n\t\t// Record the time of the test run's beginning\n\t\tconfig.started = now();\n\n\t\tverifyLoggingCallbacks();\n\n\t\t// Delete the loose unnamed module if unused.\n\t\tif ( config.modules[ 0 ].name === \"\" && config.modules[ 0 ].tests.length === 0 ) {\n\t\t\tconfig.modules.shift();\n\t\t}\n\n\t\t// Avoid unnecessary information by not logging modules' test environments\n\t\tfor ( i = 0, l = config.modules.length; i < l; i++ ) {\n\t\t\tmodulesLog.push({\n\t\t\t\tname: config.modules[ i ].name,\n\t\t\t\ttests: config.modules[ i ].tests\n\t\t\t});\n\t\t}\n\n\t\t// The test run is officially beginning now\n\t\trunLoggingCallbacks( \"begin\", {\n\t\t\ttotalTests: Test.count,\n\t\t\tmodules: modulesLog\n\t\t});\n\t}\n\n\tconfig.blocking = false;\n\tprocess( true );\n}\n\nfunction process( last ) {\n\tfunction next() {\n\t\tprocess( last );\n\t}\n\tvar start = now();\n\tconfig.depth = ( config.depth || 0 ) + 1;\n\n\twhile ( config.queue.length && !config.blocking ) {\n\t\tif ( !defined.setTimeout || config.updateRate <= 0 ||\n\t\t\t\t( ( now() - start ) < config.updateRate ) ) {\n\t\t\tif ( config.current ) {\n\n\t\t\t\t// Reset async tracking for each phase of the Test lifecycle\n\t\t\t\tconfig.current.usedAsync = false;\n\t\t\t}\n\t\t\tconfig.queue.shift()();\n\t\t} else {\n\t\t\tsetTimeout( next, 13 );\n\t\t\tbreak;\n\t\t}\n\t}\n\tconfig.depth--;\n\tif ( last && !config.blocking && !config.queue.length && config.depth === 0 ) {\n\t\tdone();\n\t}\n}\n\nfunction pauseProcessing() {\n\tconfig.blocking = true;\n\n\tif ( config.testTimeout && defined.setTimeout ) {\n\t\tclearTimeout( config.timeout );\n\t\tconfig.timeout = setTimeout(function() {\n\t\t\tif ( config.current ) {\n\t\t\t\tconfig.current.semaphore = 0;\n\t\t\t\tQUnit.pushFailure( \"Test timed out\", sourceFromStacktrace( 2 ) );\n\t\t\t} else {\n\t\t\t\tthrow new Error( \"Test timed out\" );\n\t\t\t}\n\t\t\tresumeProcessing();\n\t\t}, config.testTimeout );\n\t}\n}\n\nfunction resumeProcessing() {\n\trunStarted = true;\n\n\t// A slight delay to allow this iteration of the event loop to finish (more assertions, etc.)\n\tif ( defined.setTimeout ) {\n\t\tsetTimeout(function() {\n\t\t\tif ( config.current && config.current.semaphore > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( config.timeout ) {\n\t\t\t\tclearTimeout( config.timeout );\n\t\t\t}\n\n\t\t\tbegin();\n\t\t}, 13 );\n\t} else {\n\t\tbegin();\n\t}\n}\n\nfunction done() {\n\tvar runtime, passed;\n\n\tconfig.autorun = true;\n\n\t// Log the last module results\n\tif ( config.previousModule ) {\n\t\trunLoggingCallbacks( \"moduleDone\", {\n\t\t\tname: config.previousModule.name,\n\t\t\ttests: config.previousModule.tests,\n\t\t\tfailed: config.moduleStats.bad,\n\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\ttotal: config.moduleStats.all,\n\t\t\truntime: now() - config.moduleStats.started\n\t\t});\n\t}\n\tdelete config.previousModule;\n\n\truntime = now() - config.started;\n\tpassed = config.stats.all - config.stats.bad;\n\n\trunLoggingCallbacks( \"done\", {\n\t\tfailed: config.stats.bad,\n\t\tpassed: passed,\n\t\ttotal: config.stats.all,\n\t\truntime: runtime\n\t});\n}\n\nfunction setHook( module, hookName ) {\n\tif ( module.testEnvironment === undefined ) {\n\t\tmodule.testEnvironment = {};\n\t}\n\n\treturn function( callback ) {\n\t\tmodule.testEnvironment[ hookName ] = callback;\n\t};\n}\n"]},"hash":"0c9cf057e6b7453b781a32b0e2e68b4b122af1f5"}
