{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/diff.js","filenameRelative":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/diff.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/diff.js.map","sourceFileName":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/diff.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"diff"},"ignored":false,"code":"/*\n * This file is a modified version of google-diff-match-patch's JavaScript implementation\n * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),\n * modifications are licensed as more fully set forth in LICENSE.txt.\n *\n * The original source of google-diff-match-patch is attributable and licensed as follows:\n *\n * Copyright 2006 Google Inc.\n * http://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * More Info:\n *  https://code.google.com/p/google-diff-match-patch/\n *\n * Usage: QUnit.diff(expected, actual)\n *\n */\nQUnit.diff = function () {\n\tfunction DiffMatchPatch() {}\n\n\t//  DIFF FUNCTIONS\n\n\t/**\n  * The data structure representing a diff is an array of tuples:\n  * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n  * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n  */\n\tvar DIFF_DELETE = -1,\n\t    DIFF_INSERT = 1,\n\t    DIFF_EQUAL = 0;\n\n\t/**\n  * Find the differences between two texts.  Simplifies the problem by stripping\n  * any common prefix or suffix off the texts before diffing.\n  * @param {string} text1 Old string to be diffed.\n  * @param {string} text2 New string to be diffed.\n  * @param {boolean=} optChecklines Optional speedup flag. If present and false,\n  *     then don't run a line-level diff first to identify the changed areas.\n  *     Defaults to true, which does a faster, slightly less optimal diff.\n  * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n  */\n\tDiffMatchPatch.prototype.DiffMain = function (text1, text2, optChecklines) {\n\t\tvar deadline, checklines, commonlength, commonprefix, commonsuffix, diffs;\n\n\t\t// The diff must be complete in up to 1 second.\n\t\tdeadline = new Date().getTime() + 1000;\n\n\t\t// Check for null inputs.\n\t\tif (text1 === null || text2 === null) {\n\t\t\tthrow new Error(\"Null input. (DiffMain)\");\n\t\t}\n\n\t\t// Check for equality (speedup).\n\t\tif (text1 === text2) {\n\t\t\tif (text1) {\n\t\t\t\treturn [[DIFF_EQUAL, text1]];\n\t\t\t}\n\t\t\treturn [];\n\t\t}\n\n\t\tif (typeof optChecklines === \"undefined\") {\n\t\t\toptChecklines = true;\n\t\t}\n\n\t\tchecklines = optChecklines;\n\n\t\t// Trim off common prefix (speedup).\n\t\tcommonlength = this.diffCommonPrefix(text1, text2);\n\t\tcommonprefix = text1.substring(0, commonlength);\n\t\ttext1 = text1.substring(commonlength);\n\t\ttext2 = text2.substring(commonlength);\n\n\t\t// Trim off common suffix (speedup).\n\t\tcommonlength = this.diffCommonSuffix(text1, text2);\n\t\tcommonsuffix = text1.substring(text1.length - commonlength);\n\t\ttext1 = text1.substring(0, text1.length - commonlength);\n\t\ttext2 = text2.substring(0, text2.length - commonlength);\n\n\t\t// Compute the diff on the middle block.\n\t\tdiffs = this.diffCompute(text1, text2, checklines, deadline);\n\n\t\t// Restore the prefix and suffix.\n\t\tif (commonprefix) {\n\t\t\tdiffs.unshift([DIFF_EQUAL, commonprefix]);\n\t\t}\n\t\tif (commonsuffix) {\n\t\t\tdiffs.push([DIFF_EQUAL, commonsuffix]);\n\t\t}\n\t\tthis.diffCleanupMerge(diffs);\n\t\treturn diffs;\n\t};\n\n\t/**\n  * Reduce the number of edits by eliminating operationally trivial equalities.\n  * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n  */\n\tDiffMatchPatch.prototype.diffCleanupEfficiency = function (diffs) {\n\t\tvar changes, equalities, equalitiesLength, lastequality, pointer, preIns, preDel, postIns, postDel;\n\t\tchanges = false;\n\t\tequalities = []; // Stack of indices where equalities are found.\n\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t/** @type {?string} */\n\t\tlastequality = null;\n\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\tpointer = 0; // Index of current position.\n\t\t// Is there an insertion operation before the last equality.\n\t\tpreIns = false;\n\t\t// Is there a deletion operation before the last equality.\n\t\tpreDel = false;\n\t\t// Is there an insertion operation after the last equality.\n\t\tpostIns = false;\n\t\t// Is there a deletion operation after the last equality.\n\t\tpostDel = false;\n\t\twhile (pointer < diffs.length) {\n\n\t\t\t// Equality found.\n\t\t\tif (diffs[pointer][0] === DIFF_EQUAL) {\n\t\t\t\tif (diffs[pointer][1].length < 4 && (postIns || postDel)) {\n\n\t\t\t\t\t// Candidate found.\n\t\t\t\t\tequalities[equalitiesLength++] = pointer;\n\t\t\t\t\tpreIns = postIns;\n\t\t\t\t\tpreDel = postDel;\n\t\t\t\t\tlastequality = diffs[pointer][1];\n\t\t\t\t} else {\n\n\t\t\t\t\t// Not a candidate, and can never become one.\n\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t}\n\t\t\t\tpostIns = postDel = false;\n\n\t\t\t\t// An insertion or deletion.\n\t\t\t} else {\n\n\t\t\t\t\tif (diffs[pointer][0] === DIFF_DELETE) {\n\t\t\t\t\t\tpostDel = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpostIns = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n      * Five types to be split:\n      * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n      * <ins>A</ins>X<ins>C</ins><del>D</del>\n      * <ins>A</ins><del>B</del>X<ins>C</ins>\n      * <ins>A</del>X<ins>C</ins><del>D</del>\n      * <ins>A</ins><del>B</del>X<del>C</del>\n      */\n\t\t\t\t\tif (lastequality && (preIns && preDel && postIns && postDel || lastequality.length < 2 && preIns + preDel + postIns + postDel === 3)) {\n\n\t\t\t\t\t\t// Duplicate record.\n\t\t\t\t\t\tdiffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastequality]);\n\n\t\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\t\tdiffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n\t\t\t\t\t\tequalitiesLength--; // Throw away the equality we just deleted;\n\t\t\t\t\t\tlastequality = null;\n\t\t\t\t\t\tif (preIns && preDel) {\n\t\t\t\t\t\t\t// No changes made which could affect previous entry, keep going.\n\t\t\t\t\t\t\tpostIns = postDel = true;\n\t\t\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tequalitiesLength--; // Throw away the previous equality.\n\t\t\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n\t\t\t\t\t\t\tpostIns = postDel = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchanges = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\tif (changes) {\n\t\t\tthis.diffCleanupMerge(diffs);\n\t\t}\n\t};\n\n\t/**\n  * Convert a diff array into a pretty HTML report.\n  * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n  * @param {integer} string to be beautified.\n  * @return {string} HTML representation.\n  */\n\tDiffMatchPatch.prototype.diffPrettyHtml = function (diffs) {\n\t\tvar op,\n\t\t    data,\n\t\t    x,\n\t\t    html = [];\n\t\tfor (x = 0; x < diffs.length; x++) {\n\t\t\top = diffs[x][0]; // Operation (insert, delete, equal)\n\t\t\tdata = diffs[x][1]; // Text of change.\n\t\t\tswitch (op) {\n\t\t\t\tcase DIFF_INSERT:\n\t\t\t\t\thtml[x] = \"<ins>\" + data + \"</ins>\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIFF_DELETE:\n\t\t\t\t\thtml[x] = \"<del>\" + data + \"</del>\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIFF_EQUAL:\n\t\t\t\t\thtml[x] = \"<span>\" + data + \"</span>\";\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn html.join(\"\");\n\t};\n\n\t/**\n  * Determine the common prefix of two strings.\n  * @param {string} text1 First string.\n  * @param {string} text2 Second string.\n  * @return {number} The number of characters common to the start of each\n  *     string.\n  */\n\tDiffMatchPatch.prototype.diffCommonPrefix = function (text1, text2) {\n\t\tvar pointermid, pointermax, pointermin, pointerstart;\n\t\t// Quick check for common null cases.\n\t\tif (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {\n\t\t\treturn 0;\n\t\t}\n\t\t// Binary search.\n\t\t// Performance analysis: http://neil.fraser.name/news/2007/10/09/\n\t\tpointermin = 0;\n\t\tpointermax = Math.min(text1.length, text2.length);\n\t\tpointermid = pointermax;\n\t\tpointerstart = 0;\n\t\twhile (pointermin < pointermid) {\n\t\t\tif (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {\n\t\t\t\tpointermin = pointermid;\n\t\t\t\tpointerstart = pointermin;\n\t\t\t} else {\n\t\t\t\tpointermax = pointermid;\n\t\t\t}\n\t\t\tpointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n\t\t}\n\t\treturn pointermid;\n\t};\n\n\t/**\n  * Determine the common suffix of two strings.\n  * @param {string} text1 First string.\n  * @param {string} text2 Second string.\n  * @return {number} The number of characters common to the end of each string.\n  */\n\tDiffMatchPatch.prototype.diffCommonSuffix = function (text1, text2) {\n\t\tvar pointermid, pointermax, pointermin, pointerend;\n\t\t// Quick check for common null cases.\n\t\tif (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1)) {\n\t\t\treturn 0;\n\t\t}\n\t\t// Binary search.\n\t\t// Performance analysis: http://neil.fraser.name/news/2007/10/09/\n\t\tpointermin = 0;\n\t\tpointermax = Math.min(text1.length, text2.length);\n\t\tpointermid = pointermax;\n\t\tpointerend = 0;\n\t\twhile (pointermin < pointermid) {\n\t\t\tif (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n\t\t\t\tpointermin = pointermid;\n\t\t\t\tpointerend = pointermin;\n\t\t\t} else {\n\t\t\t\tpointermax = pointermid;\n\t\t\t}\n\t\t\tpointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n\t\t}\n\t\treturn pointermid;\n\t};\n\n\t/**\n  * Find the differences between two texts.  Assumes that the texts do not\n  * have any common prefix or suffix.\n  * @param {string} text1 Old string to be diffed.\n  * @param {string} text2 New string to be diffed.\n  * @param {boolean} checklines Speedup flag.  If false, then don't run a\n  *     line-level diff first to identify the changed areas.\n  *     If true, then run a faster, slightly less optimal diff.\n  * @param {number} deadline Time when the diff should be complete by.\n  * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n  * @private\n  */\n\tDiffMatchPatch.prototype.diffCompute = function (text1, text2, checklines, deadline) {\n\t\tvar diffs, longtext, shorttext, i, hm, text1A, text2A, text1B, text2B, midCommon, diffsA, diffsB;\n\n\t\tif (!text1) {\n\t\t\t// Just add some text (speedup).\n\t\t\treturn [[DIFF_INSERT, text2]];\n\t\t}\n\n\t\tif (!text2) {\n\t\t\t// Just delete some text (speedup).\n\t\t\treturn [[DIFF_DELETE, text1]];\n\t\t}\n\n\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\ti = longtext.indexOf(shorttext);\n\t\tif (i !== -1) {\n\t\t\t// Shorter text is inside the longer text (speedup).\n\t\t\tdiffs = [[DIFF_INSERT, longtext.substring(0, i)], [DIFF_EQUAL, shorttext], [DIFF_INSERT, longtext.substring(i + shorttext.length)]];\n\t\t\t// Swap insertions for deletions if diff is reversed.\n\t\t\tif (text1.length > text2.length) {\n\t\t\t\tdiffs[0][0] = diffs[2][0] = DIFF_DELETE;\n\t\t\t}\n\t\t\treturn diffs;\n\t\t}\n\n\t\tif (shorttext.length === 1) {\n\t\t\t// Single character string.\n\t\t\t// After the previous speedup, the character can't be an equality.\n\t\t\treturn [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n\t\t}\n\n\t\t// Check to see if the problem can be split in two.\n\t\thm = this.diffHalfMatch(text1, text2);\n\t\tif (hm) {\n\t\t\t// A half-match was found, sort out the return data.\n\t\t\ttext1A = hm[0];\n\t\t\ttext1B = hm[1];\n\t\t\ttext2A = hm[2];\n\t\t\ttext2B = hm[3];\n\t\t\tmidCommon = hm[4];\n\t\t\t// Send both pairs off for separate processing.\n\t\t\tdiffsA = this.DiffMain(text1A, text2A, checklines, deadline);\n\t\t\tdiffsB = this.DiffMain(text1B, text2B, checklines, deadline);\n\t\t\t// Merge the results.\n\t\t\treturn diffsA.concat([[DIFF_EQUAL, midCommon]], diffsB);\n\t\t}\n\n\t\tif (checklines && text1.length > 100 && text2.length > 100) {\n\t\t\treturn this.diffLineMode(text1, text2, deadline);\n\t\t}\n\n\t\treturn this.diffBisect(text1, text2, deadline);\n\t};\n\n\t/**\n  * Do the two texts share a substring which is at least half the length of the\n  * longer text?\n  * This speedup can produce non-minimal diffs.\n  * @param {string} text1 First string.\n  * @param {string} text2 Second string.\n  * @return {Array.<string>} Five element Array, containing the prefix of\n  *     text1, the suffix of text1, the prefix of text2, the suffix of\n  *     text2 and the common middle.  Or null if there was no match.\n  * @private\n  */\n\tDiffMatchPatch.prototype.diffHalfMatch = function (text1, text2) {\n\t\tvar longtext, shorttext, dmp, text1A, text2B, text2A, text1B, midCommon, hm1, hm2, hm;\n\n\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\tif (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n\t\t\treturn null; // Pointless.\n\t\t}\n\t\tdmp = this; // 'this' becomes 'window' in a closure.\n\n\t\t/**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */\n\t\tfunction diffHalfMatchI(longtext, shorttext, i) {\n\t\t\tvar seed, j, bestCommon, prefixLength, suffixLength, bestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;\n\t\t\t// Start with a 1/4 length substring at position i as a seed.\n\t\t\tseed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n\t\t\tj = -1;\n\t\t\tbestCommon = \"\";\n\t\t\twhile ((j = shorttext.indexOf(seed, j + 1)) !== -1) {\n\t\t\t\tprefixLength = dmp.diffCommonPrefix(longtext.substring(i), shorttext.substring(j));\n\t\t\t\tsuffixLength = dmp.diffCommonSuffix(longtext.substring(0, i), shorttext.substring(0, j));\n\t\t\t\tif (bestCommon.length < suffixLength + prefixLength) {\n\t\t\t\t\tbestCommon = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);\n\t\t\t\t\tbestLongtextA = longtext.substring(0, i - suffixLength);\n\t\t\t\t\tbestLongtextB = longtext.substring(i + prefixLength);\n\t\t\t\t\tbestShorttextA = shorttext.substring(0, j - suffixLength);\n\t\t\t\t\tbestShorttextB = shorttext.substring(j + prefixLength);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bestCommon.length * 2 >= longtext.length) {\n\t\t\t\treturn [bestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB, bestCommon];\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// First check if the second quarter is the seed for a half-match.\n\t\thm1 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 4));\n\t\t// Check again based on the third quarter.\n\t\thm2 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 2));\n\t\tif (!hm1 && !hm2) {\n\t\t\treturn null;\n\t\t} else if (!hm2) {\n\t\t\thm = hm1;\n\t\t} else if (!hm1) {\n\t\t\thm = hm2;\n\t\t} else {\n\t\t\t// Both matched.  Select the longest.\n\t\t\thm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n\t\t}\n\n\t\t// A half-match was found, sort out the return data.\n\t\ttext1A, text1B, text2A, text2B;\n\t\tif (text1.length > text2.length) {\n\t\t\ttext1A = hm[0];\n\t\t\ttext1B = hm[1];\n\t\t\ttext2A = hm[2];\n\t\t\ttext2B = hm[3];\n\t\t} else {\n\t\t\ttext2A = hm[0];\n\t\t\ttext2B = hm[1];\n\t\t\ttext1A = hm[2];\n\t\t\ttext1B = hm[3];\n\t\t}\n\t\tmidCommon = hm[4];\n\t\treturn [text1A, text1B, text2A, text2B, midCommon];\n\t};\n\n\t/**\n  * Do a quick line-level diff on both strings, then rediff the parts for\n  * greater accuracy.\n  * This speedup can produce non-minimal diffs.\n  * @param {string} text1 Old string to be diffed.\n  * @param {string} text2 New string to be diffed.\n  * @param {number} deadline Time when the diff should be complete by.\n  * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n  * @private\n  */\n\tDiffMatchPatch.prototype.diffLineMode = function (text1, text2, deadline) {\n\t\tvar a, diffs, linearray, pointer, countInsert, countDelete, textInsert, textDelete, j;\n\t\t// Scan the text on a line-by-line basis first.\n\t\ta = this.diffLinesToChars(text1, text2);\n\t\ttext1 = a.chars1;\n\t\ttext2 = a.chars2;\n\t\tlinearray = a.lineArray;\n\n\t\tdiffs = this.DiffMain(text1, text2, false, deadline);\n\n\t\t// Convert the diff back to original text.\n\t\tthis.diffCharsToLines(diffs, linearray);\n\t\t// Eliminate freak matches (e.g. blank lines)\n\t\tthis.diffCleanupSemantic(diffs);\n\n\t\t// Rediff any replacement blocks, this time character-by-character.\n\t\t// Add a dummy entry at the end.\n\t\tdiffs.push([DIFF_EQUAL, \"\"]);\n\t\tpointer = 0;\n\t\tcountDelete = 0;\n\t\tcountInsert = 0;\n\t\ttextDelete = \"\";\n\t\ttextInsert = \"\";\n\t\twhile (pointer < diffs.length) {\n\t\t\tswitch (diffs[pointer][0]) {\n\t\t\t\tcase DIFF_INSERT:\n\t\t\t\t\tcountInsert++;\n\t\t\t\t\ttextInsert += diffs[pointer][1];\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIFF_DELETE:\n\t\t\t\t\tcountDelete++;\n\t\t\t\t\ttextDelete += diffs[pointer][1];\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIFF_EQUAL:\n\t\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\t\tif (countDelete >= 1 && countInsert >= 1) {\n\t\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\t\tdiffs.splice(pointer - countDelete - countInsert, countDelete + countInsert);\n\t\t\t\t\t\tpointer = pointer - countDelete - countInsert;\n\t\t\t\t\t\ta = this.DiffMain(textDelete, textInsert, false, deadline);\n\t\t\t\t\t\tfor (j = a.length - 1; j >= 0; j--) {\n\t\t\t\t\t\t\tdiffs.splice(pointer, 0, a[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpointer = pointer + a.length;\n\t\t\t\t\t}\n\t\t\t\t\tcountInsert = 0;\n\t\t\t\t\tcountDelete = 0;\n\t\t\t\t\ttextDelete = \"\";\n\t\t\t\t\ttextInsert = \"\";\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\n\t\treturn diffs;\n\t};\n\n\t/**\n  * Find the 'middle snake' of a diff, split the problem in two\n  * and return the recursively constructed diff.\n  * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n  * @param {string} text1 Old string to be diffed.\n  * @param {string} text2 New string to be diffed.\n  * @param {number} deadline Time at which to bail if not yet complete.\n  * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n  * @private\n  */\n\tDiffMatchPatch.prototype.diffBisect = function (text1, text2, deadline) {\n\t\tvar text1Length, text2Length, maxD, vOffset, vLength, v1, v2, x, delta, front, k1start, k1end, k2start, k2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;\n\t\t// Cache the text lengths to prevent multiple calls.\n\t\ttext1Length = text1.length;\n\t\ttext2Length = text2.length;\n\t\tmaxD = Math.ceil((text1Length + text2Length) / 2);\n\t\tvOffset = maxD;\n\t\tvLength = 2 * maxD;\n\t\tv1 = new Array(vLength);\n\t\tv2 = new Array(vLength);\n\t\t// Setting all elements to -1 is faster in Chrome & Firefox than mixing\n\t\t// integers and undefined.\n\t\tfor (x = 0; x < vLength; x++) {\n\t\t\tv1[x] = -1;\n\t\t\tv2[x] = -1;\n\t\t}\n\t\tv1[vOffset + 1] = 0;\n\t\tv2[vOffset + 1] = 0;\n\t\tdelta = text1Length - text2Length;\n\t\t// If the total number of characters is odd, then the front path will collide\n\t\t// with the reverse path.\n\t\tfront = delta % 2 !== 0;\n\t\t// Offsets for start and end of k loop.\n\t\t// Prevents mapping of space beyond the grid.\n\t\tk1start = 0;\n\t\tk1end = 0;\n\t\tk2start = 0;\n\t\tk2end = 0;\n\t\tfor (d = 0; d < maxD; d++) {\n\t\t\t// Bail out if deadline is reached.\n\t\t\tif (new Date().getTime() > deadline) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Walk the front path one step.\n\t\t\tfor (k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n\t\t\t\tk1Offset = vOffset + k1;\n\t\t\t\tif (k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1]) {\n\t\t\t\t\tx1 = v1[k1Offset + 1];\n\t\t\t\t} else {\n\t\t\t\t\tx1 = v1[k1Offset - 1] + 1;\n\t\t\t\t}\n\t\t\t\ty1 = x1 - k1;\n\t\t\t\twhile (x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1)) {\n\t\t\t\t\tx1++;\n\t\t\t\t\ty1++;\n\t\t\t\t}\n\t\t\t\tv1[k1Offset] = x1;\n\t\t\t\tif (x1 > text1Length) {\n\t\t\t\t\t// Ran off the right of the graph.\n\t\t\t\t\tk1end += 2;\n\t\t\t\t} else if (y1 > text2Length) {\n\t\t\t\t\t// Ran off the bottom of the graph.\n\t\t\t\t\tk1start += 2;\n\t\t\t\t} else if (front) {\n\t\t\t\t\tk2Offset = vOffset + delta - k1;\n\t\t\t\t\tif (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {\n\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\tx2 = text1Length - v2[k2Offset];\n\t\t\t\t\t\tif (x1 >= x2) {\n\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\treturn this.diffBisectSplit(text1, text2, x1, y1, deadline);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Walk the reverse path one step.\n\t\t\tfor (k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n\t\t\t\tk2Offset = vOffset + k2;\n\t\t\t\tif (k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1]) {\n\t\t\t\t\tx2 = v2[k2Offset + 1];\n\t\t\t\t} else {\n\t\t\t\t\tx2 = v2[k2Offset - 1] + 1;\n\t\t\t\t}\n\t\t\t\ty2 = x2 - k2;\n\t\t\t\twhile (x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1)) {\n\t\t\t\t\tx2++;\n\t\t\t\t\ty2++;\n\t\t\t\t}\n\t\t\t\tv2[k2Offset] = x2;\n\t\t\t\tif (x2 > text1Length) {\n\t\t\t\t\t// Ran off the left of the graph.\n\t\t\t\t\tk2end += 2;\n\t\t\t\t} else if (y2 > text2Length) {\n\t\t\t\t\t// Ran off the top of the graph.\n\t\t\t\t\tk2start += 2;\n\t\t\t\t} else if (!front) {\n\t\t\t\t\tk1Offset = vOffset + delta - k2;\n\t\t\t\t\tif (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {\n\t\t\t\t\t\tx1 = v1[k1Offset];\n\t\t\t\t\t\ty1 = vOffset + x1 - k1Offset;\n\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\tx2 = text1Length - x2;\n\t\t\t\t\t\tif (x1 >= x2) {\n\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\treturn this.diffBisectSplit(text1, text2, x1, y1, deadline);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Diff took too long and hit the deadline or\n\t\t// number of diffs equals number of characters, no commonality at all.\n\t\treturn [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n\t};\n\n\t/**\n  * Given the location of the 'middle snake', split the diff in two parts\n  * and recurse.\n  * @param {string} text1 Old string to be diffed.\n  * @param {string} text2 New string to be diffed.\n  * @param {number} x Index of split point in text1.\n  * @param {number} y Index of split point in text2.\n  * @param {number} deadline Time at which to bail if not yet complete.\n  * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n  * @private\n  */\n\tDiffMatchPatch.prototype.diffBisectSplit = function (text1, text2, x, y, deadline) {\n\t\tvar text1a, text1b, text2a, text2b, diffs, diffsb;\n\t\ttext1a = text1.substring(0, x);\n\t\ttext2a = text2.substring(0, y);\n\t\ttext1b = text1.substring(x);\n\t\ttext2b = text2.substring(y);\n\n\t\t// Compute both diffs serially.\n\t\tdiffs = this.DiffMain(text1a, text2a, false, deadline);\n\t\tdiffsb = this.DiffMain(text1b, text2b, false, deadline);\n\n\t\treturn diffs.concat(diffsb);\n\t};\n\n\t/**\n  * Reduce the number of edits by eliminating semantically trivial equalities.\n  * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n  */\n\tDiffMatchPatch.prototype.diffCleanupSemantic = function (diffs) {\n\t\tvar changes, equalities, equalitiesLength, lastequality, pointer, lengthInsertions2, lengthDeletions2, lengthInsertions1, lengthDeletions1, deletion, insertion, overlapLength1, overlapLength2;\n\t\tchanges = false;\n\t\tequalities = []; // Stack of indices where equalities are found.\n\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t/** @type {?string} */\n\t\tlastequality = null;\n\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\tpointer = 0; // Index of current position.\n\t\t// Number of characters that changed prior to the equality.\n\t\tlengthInsertions1 = 0;\n\t\tlengthDeletions1 = 0;\n\t\t// Number of characters that changed after the equality.\n\t\tlengthInsertions2 = 0;\n\t\tlengthDeletions2 = 0;\n\t\twhile (pointer < diffs.length) {\n\t\t\tif (diffs[pointer][0] === DIFF_EQUAL) {\n\t\t\t\t// Equality found.\n\t\t\t\tequalities[equalitiesLength++] = pointer;\n\t\t\t\tlengthInsertions1 = lengthInsertions2;\n\t\t\t\tlengthDeletions1 = lengthDeletions2;\n\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\tlastequality = diffs[pointer][1];\n\t\t\t} else {\n\t\t\t\t// An insertion or deletion.\n\t\t\t\tif (diffs[pointer][0] === DIFF_INSERT) {\n\t\t\t\t\tlengthInsertions2 += diffs[pointer][1].length;\n\t\t\t\t} else {\n\t\t\t\t\tlengthDeletions2 += diffs[pointer][1].length;\n\t\t\t\t}\n\t\t\t\t// Eliminate an equality that is smaller or equal to the edits on both\n\t\t\t\t// sides of it.\n\t\t\t\tif (lastequality && lastequality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastequality.length <= Math.max(lengthInsertions2, lengthDeletions2)) {\n\n\t\t\t\t\t// Duplicate record.\n\t\t\t\t\tdiffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastequality]);\n\n\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\tdiffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n\n\t\t\t\t\t// Throw away the equality we just deleted.\n\t\t\t\t\tequalitiesLength--;\n\n\t\t\t\t\t// Throw away the previous equality (it needs to be reevaluated).\n\t\t\t\t\tequalitiesLength--;\n\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n\n\t\t\t\t\t// Reset the counters.\n\t\t\t\t\tlengthInsertions1 = 0;\n\t\t\t\t\tlengthDeletions1 = 0;\n\t\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\t// Normalize the diff.\n\t\tif (changes) {\n\t\t\tthis.diffCleanupMerge(diffs);\n\t\t}\n\n\t\t// Find any overlaps between deletions and insertions.\n\t\t// e.g: <del>abcxxx</del><ins>xxxdef</ins>\n\t\t//   -> <del>abc</del>xxx<ins>def</ins>\n\t\t// e.g: <del>xxxabc</del><ins>defxxx</ins>\n\t\t//   -> <ins>def</ins>xxx<del>abc</del>\n\t\t// Only extract an overlap if it is as big as the edit ahead or behind it.\n\t\tpointer = 1;\n\t\twhile (pointer < diffs.length) {\n\t\t\tif (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {\n\t\t\t\tdeletion = diffs[pointer - 1][1];\n\t\t\t\tinsertion = diffs[pointer][1];\n\t\t\t\toverlapLength1 = this.diffCommonOverlap(deletion, insertion);\n\t\t\t\toverlapLength2 = this.diffCommonOverlap(insertion, deletion);\n\t\t\t\tif (overlapLength1 >= overlapLength2) {\n\t\t\t\t\tif (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) {\n\t\t\t\t\t\t// Overlap found.  Insert an equality and trim the surrounding edits.\n\t\t\t\t\t\tdiffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlapLength1)]);\n\t\t\t\t\t\tdiffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1);\n\t\t\t\t\t\tdiffs[pointer + 1][1] = insertion.substring(overlapLength1);\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) {\n\n\t\t\t\t\t\t// Reverse overlap found.\n\t\t\t\t\t\t// Insert an equality and swap and trim the surrounding edits.\n\t\t\t\t\t\tdiffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlapLength2)]);\n\n\t\t\t\t\t\tdiffs[pointer - 1][0] = DIFF_INSERT;\n\t\t\t\t\t\tdiffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2);\n\t\t\t\t\t\tdiffs[pointer + 1][0] = DIFF_DELETE;\n\t\t\t\t\t\tdiffs[pointer + 1][1] = deletion.substring(overlapLength2);\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t};\n\n\t/**\n  * Determine if the suffix of one string is the prefix of another.\n  * @param {string} text1 First string.\n  * @param {string} text2 Second string.\n  * @return {number} The number of characters common to the end of the first\n  *     string and the start of the second string.\n  * @private\n  */\n\tDiffMatchPatch.prototype.diffCommonOverlap = function (text1, text2) {\n\t\tvar text1Length, text2Length, textLength, best, length, pattern, found;\n\t\t// Cache the text lengths to prevent multiple calls.\n\t\ttext1Length = text1.length;\n\t\ttext2Length = text2.length;\n\t\t// Eliminate the null case.\n\t\tif (text1Length === 0 || text2Length === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\t// Truncate the longer string.\n\t\tif (text1Length > text2Length) {\n\t\t\ttext1 = text1.substring(text1Length - text2Length);\n\t\t} else if (text1Length < text2Length) {\n\t\t\ttext2 = text2.substring(0, text1Length);\n\t\t}\n\t\ttextLength = Math.min(text1Length, text2Length);\n\t\t// Quick check for the worst case.\n\t\tif (text1 === text2) {\n\t\t\treturn textLength;\n\t\t}\n\n\t\t// Start by looking for a single character match\n\t\t// and increase length until no match is found.\n\t\t// Performance analysis: http://neil.fraser.name/news/2010/11/04/\n\t\tbest = 0;\n\t\tlength = 1;\n\t\twhile (true) {\n\t\t\tpattern = text1.substring(textLength - length);\n\t\t\tfound = text2.indexOf(pattern);\n\t\t\tif (found === -1) {\n\t\t\t\treturn best;\n\t\t\t}\n\t\t\tlength += found;\n\t\t\tif (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) {\n\t\t\t\tbest = length;\n\t\t\t\tlength++;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n  * Split two texts into an array of strings.  Reduce the texts to a string of\n  * hashes where each Unicode character represents one line.\n  * @param {string} text1 First string.\n  * @param {string} text2 Second string.\n  * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n  *     An object containing the encoded text1, the encoded text2 and\n  *     the array of unique strings.\n  *     The zeroth element of the array of unique strings is intentionally blank.\n  * @private\n  */\n\tDiffMatchPatch.prototype.diffLinesToChars = function (text1, text2) {\n\t\tvar lineArray, lineHash, chars1, chars2;\n\t\tlineArray = []; // e.g. lineArray[4] === 'Hello\\n'\n\t\tlineHash = {}; // e.g. lineHash['Hello\\n'] === 4\n\n\t\t// '\\x00' is a valid character, but various debuggers don't like it.\n\t\t// So we'll insert a junk entry to avoid generating a null character.\n\t\tlineArray[0] = \"\";\n\n\t\t/**\n   * Split a text into an array of strings.  Reduce the texts to a string of\n   * hashes where each Unicode character represents one line.\n   * Modifies linearray and linehash through being a closure.\n   * @param {string} text String to encode.\n   * @return {string} Encoded string.\n   * @private\n   */\n\t\tfunction diffLinesToCharsMunge(text) {\n\t\t\tvar chars, lineStart, lineEnd, lineArrayLength, line;\n\t\t\tchars = \"\";\n\t\t\t// Walk the text, pulling out a substring for each line.\n\t\t\t// text.split('\\n') would would temporarily double our memory footprint.\n\t\t\t// Modifying text would create many large strings to garbage collect.\n\t\t\tlineStart = 0;\n\t\t\tlineEnd = -1;\n\t\t\t// Keeping our own length variable is faster than looking it up.\n\t\t\tlineArrayLength = lineArray.length;\n\t\t\twhile (lineEnd < text.length - 1) {\n\t\t\t\tlineEnd = text.indexOf(\"\\n\", lineStart);\n\t\t\t\tif (lineEnd === -1) {\n\t\t\t\t\tlineEnd = text.length - 1;\n\t\t\t\t}\n\t\t\t\tline = text.substring(lineStart, lineEnd + 1);\n\t\t\t\tlineStart = lineEnd + 1;\n\n\t\t\t\tif (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== undefined) {\n\t\t\t\t\tchars += String.fromCharCode(lineHash[line]);\n\t\t\t\t} else {\n\t\t\t\t\tchars += String.fromCharCode(lineArrayLength);\n\t\t\t\t\tlineHash[line] = lineArrayLength;\n\t\t\t\t\tlineArray[lineArrayLength++] = line;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn chars;\n\t\t}\n\n\t\tchars1 = diffLinesToCharsMunge(text1);\n\t\tchars2 = diffLinesToCharsMunge(text2);\n\t\treturn {\n\t\t\tchars1: chars1,\n\t\t\tchars2: chars2,\n\t\t\tlineArray: lineArray\n\t\t};\n\t};\n\n\t/**\n  * Rehydrate the text in a diff from a string of line hashes to real lines of\n  * text.\n  * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n  * @param {!Array.<string>} lineArray Array of unique strings.\n  * @private\n  */\n\tDiffMatchPatch.prototype.diffCharsToLines = function (diffs, lineArray) {\n\t\tvar x, chars, text, y;\n\t\tfor (x = 0; x < diffs.length; x++) {\n\t\t\tchars = diffs[x][1];\n\t\t\ttext = [];\n\t\t\tfor (y = 0; y < chars.length; y++) {\n\t\t\t\ttext[y] = lineArray[chars.charCodeAt(y)];\n\t\t\t}\n\t\t\tdiffs[x][1] = text.join(\"\");\n\t\t}\n\t};\n\n\t/**\n  * Reorder and merge like edit sections.  Merge equalities.\n  * Any edit section can move as long as it doesn't cross an equality.\n  * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n  */\n\tDiffMatchPatch.prototype.diffCleanupMerge = function (diffs) {\n\t\tvar pointer, countDelete, countInsert, textInsert, textDelete, commonlength, changes, diffPointer, position;\n\t\tdiffs.push([DIFF_EQUAL, \"\"]); // Add a dummy entry at the end.\n\t\tpointer = 0;\n\t\tcountDelete = 0;\n\t\tcountInsert = 0;\n\t\ttextDelete = \"\";\n\t\ttextInsert = \"\";\n\t\tcommonlength;\n\t\twhile (pointer < diffs.length) {\n\t\t\tswitch (diffs[pointer][0]) {\n\t\t\t\tcase DIFF_INSERT:\n\t\t\t\t\tcountInsert++;\n\t\t\t\t\ttextInsert += diffs[pointer][1];\n\t\t\t\t\tpointer++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIFF_DELETE:\n\t\t\t\t\tcountDelete++;\n\t\t\t\t\ttextDelete += diffs[pointer][1];\n\t\t\t\t\tpointer++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIFF_EQUAL:\n\t\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\t\tif (countDelete + countInsert > 1) {\n\t\t\t\t\t\tif (countDelete !== 0 && countInsert !== 0) {\n\t\t\t\t\t\t\t// Factor out any common prefixies.\n\t\t\t\t\t\t\tcommonlength = this.diffCommonPrefix(textInsert, textDelete);\n\t\t\t\t\t\t\tif (commonlength !== 0) {\n\t\t\t\t\t\t\t\tif (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL) {\n\t\t\t\t\t\t\t\t\tdiffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdiffs.splice(0, 0, [DIFF_EQUAL, textInsert.substring(0, commonlength)]);\n\t\t\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttextInsert = textInsert.substring(commonlength);\n\t\t\t\t\t\t\t\ttextDelete = textDelete.substring(commonlength);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Factor out any common suffixies.\n\t\t\t\t\t\t\tcommonlength = this.diffCommonSuffix(textInsert, textDelete);\n\t\t\t\t\t\t\tif (commonlength !== 0) {\n\t\t\t\t\t\t\t\tdiffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1];\n\t\t\t\t\t\t\t\ttextInsert = textInsert.substring(0, textInsert.length - commonlength);\n\t\t\t\t\t\t\t\ttextDelete = textDelete.substring(0, textDelete.length - commonlength);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\t\tif (countDelete === 0) {\n\t\t\t\t\t\t\tdiffs.splice(pointer - countInsert, countDelete + countInsert, [DIFF_INSERT, textInsert]);\n\t\t\t\t\t\t} else if (countInsert === 0) {\n\t\t\t\t\t\t\tdiffs.splice(pointer - countDelete, countDelete + countInsert, [DIFF_DELETE, textDelete]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdiffs.splice(pointer - countDelete - countInsert, countDelete + countInsert, [DIFF_DELETE, textDelete], [DIFF_INSERT, textInsert]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpointer = pointer - countDelete - countInsert + (countDelete ? 1 : 0) + (countInsert ? 1 : 0) + 1;\n\t\t\t\t\t} else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {\n\n\t\t\t\t\t\t// Merge this equality with the previous one.\n\t\t\t\t\t\tdiffs[pointer - 1][1] += diffs[pointer][1];\n\t\t\t\t\t\tdiffs.splice(pointer, 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t\tcountInsert = 0;\n\t\t\t\t\tcountDelete = 0;\n\t\t\t\t\ttextDelete = \"\";\n\t\t\t\t\ttextInsert = \"\";\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (diffs[diffs.length - 1][1] === \"\") {\n\t\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\t\t}\n\n\t\t// Second pass: look for single edits surrounded on both sides by equalities\n\t\t// which can be shifted sideways to eliminate an equality.\n\t\t// e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n\t\tchanges = false;\n\t\tpointer = 1;\n\n\t\t// Intentionally ignore the first and last element (don't need checking).\n\t\twhile (pointer < diffs.length - 1) {\n\t\t\tif (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n\n\t\t\t\tdiffPointer = diffs[pointer][1];\n\t\t\t\tposition = diffPointer.substring(diffPointer.length - diffs[pointer - 1][1].length);\n\n\t\t\t\t// This is a single edit surrounded by equalities.\n\t\t\t\tif (position === diffs[pointer - 1][1]) {\n\n\t\t\t\t\t// Shift the edit over the previous equality.\n\t\t\t\t\tdiffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);\n\t\t\t\t\tdiffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n\t\t\t\t\tdiffs.splice(pointer - 1, 1);\n\t\t\t\t\tchanges = true;\n\t\t\t\t} else if (diffPointer.substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {\n\n\t\t\t\t\t// Shift the edit over the next equality.\n\t\t\t\t\tdiffs[pointer - 1][1] += diffs[pointer + 1][1];\n\t\t\t\t\tdiffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];\n\t\t\t\t\tdiffs.splice(pointer + 1, 1);\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t\t// If shifts were made, the diff needs reordering and another shift sweep.\n\t\tif (changes) {\n\t\t\tthis.diffCleanupMerge(diffs);\n\t\t}\n\t};\n\n\treturn function (o, n) {\n\t\tvar diff, output, text;\n\t\tdiff = new DiffMatchPatch();\n\t\toutput = diff.DiffMain(o, n);\n\t\tdiff.diffCleanupEfficiency(output);\n\t\ttext = diff.diffPrettyHtml(output);\n\n\t\treturn text;\n\t};\n}();","ast":null,"map":{"version":3,"sources":["/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/diff.js"],"names":[],"mappings":"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","file":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/diff.js.map","sourcesContent":["/*\n * This file is a modified version of google-diff-match-patch's JavaScript implementation\n * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),\n * modifications are licensed as more fully set forth in LICENSE.txt.\n *\n * The original source of google-diff-match-patch is attributable and licensed as follows:\n *\n * Copyright 2006 Google Inc.\n * http://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * More Info:\n *  https://code.google.com/p/google-diff-match-patch/\n *\n * Usage: QUnit.diff(expected, actual)\n *\n */\nQUnit.diff = ( function() {\n\tfunction DiffMatchPatch() {\n\t}\n\n\t//  DIFF FUNCTIONS\n\n\t/**\n\t * The data structure representing a diff is an array of tuples:\n\t * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n\t * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n\t */\n\tvar DIFF_DELETE = -1,\n\t\tDIFF_INSERT = 1,\n\t\tDIFF_EQUAL = 0;\n\n\t/**\n\t * Find the differences between two texts.  Simplifies the problem by stripping\n\t * any common prefix or suffix off the texts before diffing.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {boolean=} optChecklines Optional speedup flag. If present and false,\n\t *     then don't run a line-level diff first to identify the changed areas.\n\t *     Defaults to true, which does a faster, slightly less optimal diff.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.DiffMain = function( text1, text2, optChecklines ) {\n\t\tvar deadline, checklines, commonlength,\n\t\t\tcommonprefix, commonsuffix, diffs;\n\n\t\t// The diff must be complete in up to 1 second.\n\t\tdeadline = ( new Date() ).getTime() + 1000;\n\n\t\t// Check for null inputs.\n\t\tif ( text1 === null || text2 === null ) {\n\t\t\tthrow new Error( \"Null input. (DiffMain)\" );\n\t\t}\n\n\t\t// Check for equality (speedup).\n\t\tif ( text1 === text2 ) {\n\t\t\tif ( text1 ) {\n\t\t\t\treturn [\n\t\t\t\t\t[ DIFF_EQUAL, text1 ]\n\t\t\t\t];\n\t\t\t}\n\t\t\treturn [];\n\t\t}\n\n\t\tif ( typeof optChecklines === \"undefined\" ) {\n\t\t\toptChecklines = true;\n\t\t}\n\n\t\tchecklines = optChecklines;\n\n\t\t// Trim off common prefix (speedup).\n\t\tcommonlength = this.diffCommonPrefix( text1, text2 );\n\t\tcommonprefix = text1.substring( 0, commonlength );\n\t\ttext1 = text1.substring( commonlength );\n\t\ttext2 = text2.substring( commonlength );\n\n\t\t// Trim off common suffix (speedup).\n\t\tcommonlength = this.diffCommonSuffix( text1, text2 );\n\t\tcommonsuffix = text1.substring( text1.length - commonlength );\n\t\ttext1 = text1.substring( 0, text1.length - commonlength );\n\t\ttext2 = text2.substring( 0, text2.length - commonlength );\n\n\t\t// Compute the diff on the middle block.\n\t\tdiffs = this.diffCompute( text1, text2, checklines, deadline );\n\n\t\t// Restore the prefix and suffix.\n\t\tif ( commonprefix ) {\n\t\t\tdiffs.unshift( [ DIFF_EQUAL, commonprefix ] );\n\t\t}\n\t\tif ( commonsuffix ) {\n\t\t\tdiffs.push( [ DIFF_EQUAL, commonsuffix ] );\n\t\t}\n\t\tthis.diffCleanupMerge( diffs );\n\t\treturn diffs;\n\t};\n\n\t/**\n\t * Reduce the number of edits by eliminating operationally trivial equalities.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupEfficiency = function( diffs ) {\n\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\tpointer, preIns, preDel, postIns, postDel;\n\t\tchanges = false;\n\t\tequalities = []; // Stack of indices where equalities are found.\n\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t/** @type {?string} */\n\t\tlastequality = null;\n\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\tpointer = 0; // Index of current position.\n\t\t// Is there an insertion operation before the last equality.\n\t\tpreIns = false;\n\t\t// Is there a deletion operation before the last equality.\n\t\tpreDel = false;\n\t\t// Is there an insertion operation after the last equality.\n\t\tpostIns = false;\n\t\t// Is there a deletion operation after the last equality.\n\t\tpostDel = false;\n\t\twhile ( pointer < diffs.length ) {\n\n\t\t\t// Equality found.\n\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) {\n\t\t\t\tif ( diffs[ pointer ][ 1 ].length < 4 && ( postIns || postDel ) ) {\n\n\t\t\t\t\t// Candidate found.\n\t\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\t\tpreIns = postIns;\n\t\t\t\t\tpreDel = postDel;\n\t\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t\t} else {\n\n\t\t\t\t\t// Not a candidate, and can never become one.\n\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t}\n\t\t\t\tpostIns = postDel = false;\n\n\t\t\t// An insertion or deletion.\n\t\t\t} else {\n\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_DELETE ) {\n\t\t\t\t\tpostDel = true;\n\t\t\t\t} else {\n\t\t\t\t\tpostIns = true;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Five types to be split:\n\t\t\t\t * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins>X<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins><del>B</del>X<ins>C</ins>\n\t\t\t\t * <ins>A</del>X<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins><del>B</del>X<del>C</del>\n\t\t\t\t */\n\t\t\t\tif ( lastequality && ( ( preIns && preDel && postIns && postDel ) ||\n\t\t\t\t\t\t( ( lastequality.length < 2 ) &&\n\t\t\t\t\t\t( preIns + preDel + postIns + postDel ) === 3 ) ) ) {\n\n\t\t\t\t\t// Duplicate record.\n\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t);\n\n\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\tequalitiesLength--; // Throw away the equality we just deleted;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t\tif ( preIns && preDel ) {\n\t\t\t\t\t\t// No changes made which could affect previous entry, keep going.\n\t\t\t\t\t\tpostIns = postDel = true;\n\t\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tequalitiesLength--; // Throw away the previous equality.\n\t\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\t\t\t\t\t\tpostIns = postDel = false;\n\t\t\t\t\t}\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\t};\n\n\t/**\n\t * Convert a diff array into a pretty HTML report.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t * @param {integer} string to be beautified.\n\t * @return {string} HTML representation.\n\t */\n\tDiffMatchPatch.prototype.diffPrettyHtml = function( diffs ) {\n\t\tvar op, data, x,\n\t\t\thtml = [];\n\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\top = diffs[ x ][ 0 ]; // Operation (insert, delete, equal)\n\t\t\tdata = diffs[ x ][ 1 ]; // Text of change.\n\t\t\tswitch ( op ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\thtml[ x ] = \"<ins>\" + data + \"</ins>\";\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\thtml[ x ] = \"<del>\" + data + \"</del>\";\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\t\t\t\thtml[ x ] = \"<span>\" + data + \"</span>\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn html.join( \"\" );\n\t};\n\n\t/**\n\t * Determine the common prefix of two strings.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the start of each\n\t *     string.\n\t */\n\tDiffMatchPatch.prototype.diffCommonPrefix = function( text1, text2 ) {\n\t\tvar pointermid, pointermax, pointermin, pointerstart;\n\t\t// Quick check for common null cases.\n\t\tif ( !text1 || !text2 || text1.charAt( 0 ) !== text2.charAt( 0 ) ) {\n\t\t\treturn 0;\n\t\t}\n\t\t// Binary search.\n\t\t// Performance analysis: http://neil.fraser.name/news/2007/10/09/\n\t\tpointermin = 0;\n\t\tpointermax = Math.min( text1.length, text2.length );\n\t\tpointermid = pointermax;\n\t\tpointerstart = 0;\n\t\twhile ( pointermin < pointermid ) {\n\t\t\tif ( text1.substring( pointerstart, pointermid ) ===\n\t\t\t\t\ttext2.substring( pointerstart, pointermid ) ) {\n\t\t\t\tpointermin = pointermid;\n\t\t\t\tpointerstart = pointermin;\n\t\t\t} else {\n\t\t\t\tpointermax = pointermid;\n\t\t\t}\n\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t}\n\t\treturn pointermid;\n\t};\n\n\t/**\n\t * Determine the common suffix of two strings.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the end of each string.\n\t */\n\tDiffMatchPatch.prototype.diffCommonSuffix = function( text1, text2 ) {\n\t\tvar pointermid, pointermax, pointermin, pointerend;\n\t\t// Quick check for common null cases.\n\t\tif ( !text1 ||\n\t\t\t\t!text2 ||\n\t\t\t\ttext1.charAt( text1.length - 1 ) !== text2.charAt( text2.length - 1 ) ) {\n\t\t\treturn 0;\n\t\t}\n\t\t// Binary search.\n\t\t// Performance analysis: http://neil.fraser.name/news/2007/10/09/\n\t\tpointermin = 0;\n\t\tpointermax = Math.min( text1.length, text2.length );\n\t\tpointermid = pointermax;\n\t\tpointerend = 0;\n\t\twhile ( pointermin < pointermid ) {\n\t\t\tif ( text1.substring( text1.length - pointermid, text1.length - pointerend ) ===\n\t\t\t\t\ttext2.substring( text2.length - pointermid, text2.length - pointerend ) ) {\n\t\t\t\tpointermin = pointermid;\n\t\t\t\tpointerend = pointermin;\n\t\t\t} else {\n\t\t\t\tpointermax = pointermid;\n\t\t\t}\n\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t}\n\t\treturn pointermid;\n\t};\n\n\t/**\n\t * Find the differences between two texts.  Assumes that the texts do not\n\t * have any common prefix or suffix.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {boolean} checklines Speedup flag.  If false, then don't run a\n\t *     line-level diff first to identify the changed areas.\n\t *     If true, then run a faster, slightly less optimal diff.\n\t * @param {number} deadline Time when the diff should be complete by.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCompute = function( text1, text2, checklines, deadline ) {\n\t\tvar diffs, longtext, shorttext, i, hm,\n\t\t\ttext1A, text2A, text1B, text2B,\n\t\t\tmidCommon, diffsA, diffsB;\n\n\t\tif ( !text1 ) {\n\t\t\t// Just add some text (speedup).\n\t\t\treturn [\n\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t];\n\t\t}\n\n\t\tif ( !text2 ) {\n\t\t\t// Just delete some text (speedup).\n\t\t\treturn [\n\t\t\t\t[ DIFF_DELETE, text1 ]\n\t\t\t];\n\t\t}\n\n\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\ti = longtext.indexOf( shorttext );\n\t\tif ( i !== -1 ) {\n\t\t\t// Shorter text is inside the longer text (speedup).\n\t\t\tdiffs = [\n\t\t\t\t[ DIFF_INSERT, longtext.substring( 0, i ) ],\n\t\t\t\t[ DIFF_EQUAL, shorttext ],\n\t\t\t\t[ DIFF_INSERT, longtext.substring( i + shorttext.length ) ]\n\t\t\t];\n\t\t\t// Swap insertions for deletions if diff is reversed.\n\t\t\tif ( text1.length > text2.length ) {\n\t\t\t\tdiffs[ 0 ][ 0 ] = diffs[ 2 ][ 0 ] = DIFF_DELETE;\n\t\t\t}\n\t\t\treturn diffs;\n\t\t}\n\n\t\tif ( shorttext.length === 1 ) {\n\t\t\t// Single character string.\n\t\t\t// After the previous speedup, the character can't be an equality.\n\t\t\treturn [\n\t\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t];\n\t\t}\n\n\t\t// Check to see if the problem can be split in two.\n\t\thm = this.diffHalfMatch( text1, text2 );\n\t\tif ( hm ) {\n\t\t\t// A half-match was found, sort out the return data.\n\t\t\ttext1A = hm[ 0 ];\n\t\t\ttext1B = hm[ 1 ];\n\t\t\ttext2A = hm[ 2 ];\n\t\t\ttext2B = hm[ 3 ];\n\t\t\tmidCommon = hm[ 4 ];\n\t\t\t// Send both pairs off for separate processing.\n\t\t\tdiffsA = this.DiffMain( text1A, text2A, checklines, deadline );\n\t\t\tdiffsB = this.DiffMain( text1B, text2B, checklines, deadline );\n\t\t\t// Merge the results.\n\t\t\treturn diffsA.concat( [\n\t\t\t\t[ DIFF_EQUAL, midCommon ]\n\t\t\t], diffsB );\n\t\t}\n\n\t\tif ( checklines && text1.length > 100 && text2.length > 100 ) {\n\t\t\treturn this.diffLineMode( text1, text2, deadline );\n\t\t}\n\n\t\treturn this.diffBisect( text1, text2, deadline );\n\t};\n\n\t/**\n\t * Do the two texts share a substring which is at least half the length of the\n\t * longer text?\n\t * This speedup can produce non-minimal diffs.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t *     text1, the suffix of text1, the prefix of text2, the suffix of\n\t *     text2 and the common middle.  Or null if there was no match.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffHalfMatch = function( text1, text2 ) {\n\t\tvar longtext, shorttext, dmp,\n\t\t\ttext1A, text2B, text2A, text1B, midCommon,\n\t\t\thm1, hm2, hm;\n\n\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\tif ( longtext.length < 4 || shorttext.length * 2 < longtext.length ) {\n\t\t\treturn null; // Pointless.\n\t\t}\n\t\tdmp = this; // 'this' becomes 'window' in a closure.\n\n\t\t/**\n\t\t * Does a substring of shorttext exist within longtext such that the substring\n\t\t * is at least half the length of longtext?\n\t\t * Closure, but does not reference any external variables.\n\t\t * @param {string} longtext Longer string.\n\t\t * @param {string} shorttext Shorter string.\n\t\t * @param {number} i Start index of quarter length substring within longtext.\n\t\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t\t *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n\t\t *     of shorttext and the common middle.  Or null if there was no match.\n\t\t * @private\n\t\t */\n\t\tfunction diffHalfMatchI( longtext, shorttext, i ) {\n\t\t\tvar seed, j, bestCommon, prefixLength, suffixLength,\n\t\t\t\tbestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;\n\t\t\t// Start with a 1/4 length substring at position i as a seed.\n\t\t\tseed = longtext.substring( i, i + Math.floor( longtext.length / 4 ) );\n\t\t\tj = -1;\n\t\t\tbestCommon = \"\";\n\t\t\twhile ( ( j = shorttext.indexOf( seed, j + 1 ) ) !== -1 ) {\n\t\t\t\tprefixLength = dmp.diffCommonPrefix( longtext.substring( i ),\n\t\t\t\t\tshorttext.substring( j ) );\n\t\t\t\tsuffixLength = dmp.diffCommonSuffix( longtext.substring( 0, i ),\n\t\t\t\t\tshorttext.substring( 0, j ) );\n\t\t\t\tif ( bestCommon.length < suffixLength + prefixLength ) {\n\t\t\t\t\tbestCommon = shorttext.substring( j - suffixLength, j ) +\n\t\t\t\t\t\tshorttext.substring( j, j + prefixLength );\n\t\t\t\t\tbestLongtextA = longtext.substring( 0, i - suffixLength );\n\t\t\t\t\tbestLongtextB = longtext.substring( i + prefixLength );\n\t\t\t\t\tbestShorttextA = shorttext.substring( 0, j - suffixLength );\n\t\t\t\t\tbestShorttextB = shorttext.substring( j + prefixLength );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( bestCommon.length * 2 >= longtext.length ) {\n\t\t\t\treturn [ bestLongtextA, bestLongtextB,\n\t\t\t\t\tbestShorttextA, bestShorttextB, bestCommon\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// First check if the second quarter is the seed for a half-match.\n\t\thm1 = diffHalfMatchI( longtext, shorttext,\n\t\t\tMath.ceil( longtext.length / 4 ) );\n\t\t// Check again based on the third quarter.\n\t\thm2 = diffHalfMatchI( longtext, shorttext,\n\t\t\tMath.ceil( longtext.length / 2 ) );\n\t\tif ( !hm1 && !hm2 ) {\n\t\t\treturn null;\n\t\t} else if ( !hm2 ) {\n\t\t\thm = hm1;\n\t\t} else if ( !hm1 ) {\n\t\t\thm = hm2;\n\t\t} else {\n\t\t\t// Both matched.  Select the longest.\n\t\t\thm = hm1[ 4 ].length > hm2[ 4 ].length ? hm1 : hm2;\n\t\t}\n\n\t\t// A half-match was found, sort out the return data.\n\t\ttext1A, text1B, text2A, text2B;\n\t\tif ( text1.length > text2.length ) {\n\t\t\ttext1A = hm[ 0 ];\n\t\t\ttext1B = hm[ 1 ];\n\t\t\ttext2A = hm[ 2 ];\n\t\t\ttext2B = hm[ 3 ];\n\t\t} else {\n\t\t\ttext2A = hm[ 0 ];\n\t\t\ttext2B = hm[ 1 ];\n\t\t\ttext1A = hm[ 2 ];\n\t\t\ttext1B = hm[ 3 ];\n\t\t}\n\t\tmidCommon = hm[ 4 ];\n\t\treturn [ text1A, text1B, text2A, text2B, midCommon ];\n\t};\n\n\t/**\n\t * Do a quick line-level diff on both strings, then rediff the parts for\n\t * greater accuracy.\n\t * This speedup can produce non-minimal diffs.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} deadline Time when the diff should be complete by.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffLineMode = function( text1, text2, deadline ) {\n\t\tvar a, diffs, linearray, pointer, countInsert,\n\t\t\tcountDelete, textInsert, textDelete, j;\n\t\t// Scan the text on a line-by-line basis first.\n\t\ta = this.diffLinesToChars( text1, text2 );\n\t\ttext1 = a.chars1;\n\t\ttext2 = a.chars2;\n\t\tlinearray = a.lineArray;\n\n\t\tdiffs = this.DiffMain( text1, text2, false, deadline );\n\n\t\t// Convert the diff back to original text.\n\t\tthis.diffCharsToLines( diffs, linearray );\n\t\t// Eliminate freak matches (e.g. blank lines)\n\t\tthis.diffCleanupSemantic( diffs );\n\n\t\t// Rediff any replacement blocks, this time character-by-character.\n\t\t// Add a dummy entry at the end.\n\t\tdiffs.push( [ DIFF_EQUAL, \"\" ] );\n\t\tpointer = 0;\n\t\tcountDelete = 0;\n\t\tcountInsert = 0;\n\t\ttextDelete = \"\";\n\t\ttextInsert = \"\";\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tcountInsert++;\n\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tcountDelete++;\n\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\tif ( countDelete >= 1 && countInsert >= 1 ) {\n\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\tdiffs.splice( pointer - countDelete - countInsert,\n\t\t\t\t\t\tcountDelete + countInsert );\n\t\t\t\t\tpointer = pointer - countDelete - countInsert;\n\t\t\t\t\ta = this.DiffMain( textDelete, textInsert, false, deadline );\n\t\t\t\t\tfor ( j = a.length - 1; j >= 0; j-- ) {\n\t\t\t\t\t\tdiffs.splice( pointer, 0, a[ j ] );\n\t\t\t\t\t}\n\t\t\t\t\tpointer = pointer + a.length;\n\t\t\t\t}\n\t\t\t\tcountInsert = 0;\n\t\t\t\tcountDelete = 0;\n\t\t\t\ttextDelete = \"\";\n\t\t\t\ttextInsert = \"\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\n\t\treturn diffs;\n\t};\n\n\t/**\n\t * Find the 'middle snake' of a diff, split the problem in two\n\t * and return the recursively constructed diff.\n\t * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} deadline Time at which to bail if not yet complete.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffBisect = function( text1, text2, deadline ) {\n\t\tvar text1Length, text2Length, maxD, vOffset, vLength,\n\t\t\tv1, v2, x, delta, front, k1start, k1end, k2start,\n\t\t\tk2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;\n\t\t// Cache the text lengths to prevent multiple calls.\n\t\ttext1Length = text1.length;\n\t\ttext2Length = text2.length;\n\t\tmaxD = Math.ceil( ( text1Length + text2Length ) / 2 );\n\t\tvOffset = maxD;\n\t\tvLength = 2 * maxD;\n\t\tv1 = new Array( vLength );\n\t\tv2 = new Array( vLength );\n\t\t// Setting all elements to -1 is faster in Chrome & Firefox than mixing\n\t\t// integers and undefined.\n\t\tfor ( x = 0; x < vLength; x++ ) {\n\t\t\tv1[ x ] = -1;\n\t\t\tv2[ x ] = -1;\n\t\t}\n\t\tv1[ vOffset + 1 ] = 0;\n\t\tv2[ vOffset + 1 ] = 0;\n\t\tdelta = text1Length - text2Length;\n\t\t// If the total number of characters is odd, then the front path will collide\n\t\t// with the reverse path.\n\t\tfront = ( delta % 2 !== 0 );\n\t\t// Offsets for start and end of k loop.\n\t\t// Prevents mapping of space beyond the grid.\n\t\tk1start = 0;\n\t\tk1end = 0;\n\t\tk2start = 0;\n\t\tk2end = 0;\n\t\tfor ( d = 0; d < maxD; d++ ) {\n\t\t\t// Bail out if deadline is reached.\n\t\t\tif ( ( new Date() ).getTime() > deadline ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Walk the front path one step.\n\t\t\tfor ( k1 = -d + k1start; k1 <= d - k1end; k1 += 2 ) {\n\t\t\t\tk1Offset = vOffset + k1;\n\t\t\t\tif ( k1 === -d || ( k1 !== d && v1[ k1Offset - 1 ] < v1[ k1Offset + 1 ] ) ) {\n\t\t\t\t\tx1 = v1[ k1Offset + 1 ];\n\t\t\t\t} else {\n\t\t\t\t\tx1 = v1[ k1Offset - 1 ] + 1;\n\t\t\t\t}\n\t\t\t\ty1 = x1 - k1;\n\t\t\t\twhile ( x1 < text1Length && y1 < text2Length &&\n\t\t\t\t\ttext1.charAt( x1 ) === text2.charAt( y1 ) ) {\n\t\t\t\t\tx1++;\n\t\t\t\t\ty1++;\n\t\t\t\t}\n\t\t\t\tv1[ k1Offset ] = x1;\n\t\t\t\tif ( x1 > text1Length ) {\n\t\t\t\t\t// Ran off the right of the graph.\n\t\t\t\t\tk1end += 2;\n\t\t\t\t} else if ( y1 > text2Length ) {\n\t\t\t\t\t// Ran off the bottom of the graph.\n\t\t\t\t\tk1start += 2;\n\t\t\t\t} else if ( front ) {\n\t\t\t\t\tk2Offset = vOffset + delta - k1;\n\t\t\t\t\tif ( k2Offset >= 0 && k2Offset < vLength && v2[ k2Offset ] !== -1 ) {\n\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\tx2 = text1Length - v2[ k2Offset ];\n\t\t\t\t\t\tif ( x1 >= x2 ) {\n\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Walk the reverse path one step.\n\t\t\tfor ( k2 = -d + k2start; k2 <= d - k2end; k2 += 2 ) {\n\t\t\t\tk2Offset = vOffset + k2;\n\t\t\t\tif ( k2 === -d || ( k2 !== d && v2[ k2Offset - 1 ] < v2[ k2Offset + 1 ] ) ) {\n\t\t\t\t\tx2 = v2[ k2Offset + 1 ];\n\t\t\t\t} else {\n\t\t\t\t\tx2 = v2[ k2Offset - 1 ] + 1;\n\t\t\t\t}\n\t\t\t\ty2 = x2 - k2;\n\t\t\t\twhile ( x2 < text1Length && y2 < text2Length &&\n\t\t\t\t\ttext1.charAt( text1Length - x2 - 1 ) ===\n\t\t\t\t\ttext2.charAt( text2Length - y2 - 1 ) ) {\n\t\t\t\t\tx2++;\n\t\t\t\t\ty2++;\n\t\t\t\t}\n\t\t\t\tv2[ k2Offset ] = x2;\n\t\t\t\tif ( x2 > text1Length ) {\n\t\t\t\t\t// Ran off the left of the graph.\n\t\t\t\t\tk2end += 2;\n\t\t\t\t} else if ( y2 > text2Length ) {\n\t\t\t\t\t// Ran off the top of the graph.\n\t\t\t\t\tk2start += 2;\n\t\t\t\t} else if ( !front ) {\n\t\t\t\t\tk1Offset = vOffset + delta - k2;\n\t\t\t\t\tif ( k1Offset >= 0 && k1Offset < vLength && v1[ k1Offset ] !== -1 ) {\n\t\t\t\t\t\tx1 = v1[ k1Offset ];\n\t\t\t\t\t\ty1 = vOffset + x1 - k1Offset;\n\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\tx2 = text1Length - x2;\n\t\t\t\t\t\tif ( x1 >= x2 ) {\n\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Diff took too long and hit the deadline or\n\t\t// number of diffs equals number of characters, no commonality at all.\n\t\treturn [\n\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t[ DIFF_INSERT, text2 ]\n\t\t];\n\t};\n\n\t/**\n\t * Given the location of the 'middle snake', split the diff in two parts\n\t * and recurse.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} x Index of split point in text1.\n\t * @param {number} y Index of split point in text2.\n\t * @param {number} deadline Time at which to bail if not yet complete.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffBisectSplit = function( text1, text2, x, y, deadline ) {\n\t\tvar text1a, text1b, text2a, text2b, diffs, diffsb;\n\t\ttext1a = text1.substring( 0, x );\n\t\ttext2a = text2.substring( 0, y );\n\t\ttext1b = text1.substring( x );\n\t\ttext2b = text2.substring( y );\n\n\t\t// Compute both diffs serially.\n\t\tdiffs = this.DiffMain( text1a, text2a, false, deadline );\n\t\tdiffsb = this.DiffMain( text1b, text2b, false, deadline );\n\n\t\treturn diffs.concat( diffsb );\n\t};\n\n\t/**\n\t * Reduce the number of edits by eliminating semantically trivial equalities.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupSemantic = function( diffs ) {\n\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\tpointer, lengthInsertions2, lengthDeletions2, lengthInsertions1,\n\t\t\tlengthDeletions1, deletion, insertion, overlapLength1, overlapLength2;\n\t\tchanges = false;\n\t\tequalities = []; // Stack of indices where equalities are found.\n\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t/** @type {?string} */\n\t\tlastequality = null;\n\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\tpointer = 0; // Index of current position.\n\t\t// Number of characters that changed prior to the equality.\n\t\tlengthInsertions1 = 0;\n\t\tlengthDeletions1 = 0;\n\t\t// Number of characters that changed after the equality.\n\t\tlengthInsertions2 = 0;\n\t\tlengthDeletions2 = 0;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) { // Equality found.\n\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\tlengthInsertions1 = lengthInsertions2;\n\t\t\t\tlengthDeletions1 = lengthDeletions2;\n\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t} else { // An insertion or deletion.\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\t\tlengthInsertions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t} else {\n\t\t\t\t\tlengthDeletions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t}\n\t\t\t\t// Eliminate an equality that is smaller or equal to the edits on both\n\t\t\t\t// sides of it.\n\t\t\t\tif ( lastequality && ( lastequality.length <=\n\t\t\t\t\t\tMath.max( lengthInsertions1, lengthDeletions1 ) ) &&\n\t\t\t\t\t\t( lastequality.length <= Math.max( lengthInsertions2,\n\t\t\t\t\t\t\tlengthDeletions2 ) ) ) {\n\n\t\t\t\t\t// Duplicate record.\n\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t);\n\n\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\n\t\t\t\t\t// Throw away the equality we just deleted.\n\t\t\t\t\tequalitiesLength--;\n\n\t\t\t\t\t// Throw away the previous equality (it needs to be reevaluated).\n\t\t\t\t\tequalitiesLength--;\n\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\n\t\t\t\t\t// Reset the counters.\n\t\t\t\t\tlengthInsertions1 = 0;\n\t\t\t\t\tlengthDeletions1 = 0;\n\t\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\t// Normalize the diff.\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\n\t\t// Find any overlaps between deletions and insertions.\n\t\t// e.g: <del>abcxxx</del><ins>xxxdef</ins>\n\t\t//   -> <del>abc</del>xxx<ins>def</ins>\n\t\t// e.g: <del>xxxabc</del><ins>defxxx</ins>\n\t\t//   -> <ins>def</ins>xxx<del>abc</del>\n\t\t// Only extract an overlap if it is as big as the edit ahead or behind it.\n\t\tpointer = 1;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_DELETE &&\n\t\t\t\t\tdiffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\tdeletion = diffs[ pointer - 1 ][ 1 ];\n\t\t\t\tinsertion = diffs[ pointer ][ 1 ];\n\t\t\t\toverlapLength1 = this.diffCommonOverlap( deletion, insertion );\n\t\t\t\toverlapLength2 = this.diffCommonOverlap( insertion, deletion );\n\t\t\t\tif ( overlapLength1 >= overlapLength2 ) {\n\t\t\t\t\tif ( overlapLength1 >= deletion.length / 2 ||\n\t\t\t\t\t\t\toverlapLength1 >= insertion.length / 2 ) {\n\t\t\t\t\t\t// Overlap found.  Insert an equality and trim the surrounding edits.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_EQUAL, insertion.substring( 0, overlapLength1 ) ]\n\t\t\t\t\t\t);\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\tdeletion.substring( 0, deletion.length - overlapLength1 );\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] = insertion.substring( overlapLength1 );\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ( overlapLength2 >= deletion.length / 2 ||\n\t\t\t\t\t\t\toverlapLength2 >= insertion.length / 2 ) {\n\n\t\t\t\t\t\t// Reverse overlap found.\n\t\t\t\t\t\t// Insert an equality and swap and trim the surrounding edits.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_EQUAL, deletion.substring( 0, overlapLength2 ) ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\tinsertion.substring( 0, insertion.length - overlapLength2 );\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] = DIFF_DELETE;\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\t\tdeletion.substring( overlapLength2 );\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t};\n\n\t/**\n\t * Determine if the suffix of one string is the prefix of another.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the end of the first\n\t *     string and the start of the second string.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCommonOverlap = function( text1, text2 ) {\n\t\tvar text1Length, text2Length, textLength,\n\t\t\tbest, length, pattern, found;\n\t\t// Cache the text lengths to prevent multiple calls.\n\t\ttext1Length = text1.length;\n\t\ttext2Length = text2.length;\n\t\t// Eliminate the null case.\n\t\tif ( text1Length === 0 || text2Length === 0 ) {\n\t\t\treturn 0;\n\t\t}\n\t\t// Truncate the longer string.\n\t\tif ( text1Length > text2Length ) {\n\t\t\ttext1 = text1.substring( text1Length - text2Length );\n\t\t} else if ( text1Length < text2Length ) {\n\t\t\ttext2 = text2.substring( 0, text1Length );\n\t\t}\n\t\ttextLength = Math.min( text1Length, text2Length );\n\t\t// Quick check for the worst case.\n\t\tif ( text1 === text2 ) {\n\t\t\treturn textLength;\n\t\t}\n\n\t\t// Start by looking for a single character match\n\t\t// and increase length until no match is found.\n\t\t// Performance analysis: http://neil.fraser.name/news/2010/11/04/\n\t\tbest = 0;\n\t\tlength = 1;\n\t\twhile ( true ) {\n\t\t\tpattern = text1.substring( textLength - length );\n\t\t\tfound = text2.indexOf( pattern );\n\t\t\tif ( found === -1 ) {\n\t\t\t\treturn best;\n\t\t\t}\n\t\t\tlength += found;\n\t\t\tif ( found === 0 || text1.substring( textLength - length ) ===\n\t\t\t\t\ttext2.substring( 0, length ) ) {\n\t\t\t\tbest = length;\n\t\t\t\tlength++;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Split two texts into an array of strings.  Reduce the texts to a string of\n\t * hashes where each Unicode character represents one line.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n\t *     An object containing the encoded text1, the encoded text2 and\n\t *     the array of unique strings.\n\t *     The zeroth element of the array of unique strings is intentionally blank.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffLinesToChars = function( text1, text2 ) {\n\t\tvar lineArray, lineHash, chars1, chars2;\n\t\tlineArray = []; // e.g. lineArray[4] === 'Hello\\n'\n\t\tlineHash = {}; // e.g. lineHash['Hello\\n'] === 4\n\n\t\t// '\\x00' is a valid character, but various debuggers don't like it.\n\t\t// So we'll insert a junk entry to avoid generating a null character.\n\t\tlineArray[ 0 ] = \"\";\n\n\t\t/**\n\t\t * Split a text into an array of strings.  Reduce the texts to a string of\n\t\t * hashes where each Unicode character represents one line.\n\t\t * Modifies linearray and linehash through being a closure.\n\t\t * @param {string} text String to encode.\n\t\t * @return {string} Encoded string.\n\t\t * @private\n\t\t */\n\t\tfunction diffLinesToCharsMunge( text ) {\n\t\t\tvar chars, lineStart, lineEnd, lineArrayLength, line;\n\t\t\tchars = \"\";\n\t\t\t// Walk the text, pulling out a substring for each line.\n\t\t\t// text.split('\\n') would would temporarily double our memory footprint.\n\t\t\t// Modifying text would create many large strings to garbage collect.\n\t\t\tlineStart = 0;\n\t\t\tlineEnd = -1;\n\t\t\t// Keeping our own length variable is faster than looking it up.\n\t\t\tlineArrayLength = lineArray.length;\n\t\t\twhile ( lineEnd < text.length - 1 ) {\n\t\t\t\tlineEnd = text.indexOf( \"\\n\", lineStart );\n\t\t\t\tif ( lineEnd === -1 ) {\n\t\t\t\t\tlineEnd = text.length - 1;\n\t\t\t\t}\n\t\t\t\tline = text.substring( lineStart, lineEnd + 1 );\n\t\t\t\tlineStart = lineEnd + 1;\n\n\t\t\t\tif ( lineHash.hasOwnProperty ? lineHash.hasOwnProperty( line ) :\n\t\t\t\t\t\t\t( lineHash[ line ] !== undefined ) ) {\n\t\t\t\t\tchars += String.fromCharCode( lineHash[ line ] );\n\t\t\t\t} else {\n\t\t\t\t\tchars += String.fromCharCode( lineArrayLength );\n\t\t\t\t\tlineHash[ line ] = lineArrayLength;\n\t\t\t\t\tlineArray[ lineArrayLength++ ] = line;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn chars;\n\t\t}\n\n\t\tchars1 = diffLinesToCharsMunge( text1 );\n\t\tchars2 = diffLinesToCharsMunge( text2 );\n\t\treturn {\n\t\t\tchars1: chars1,\n\t\t\tchars2: chars2,\n\t\t\tlineArray: lineArray\n\t\t};\n\t};\n\n\t/**\n\t * Rehydrate the text in a diff from a string of line hashes to real lines of\n\t * text.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t * @param {!Array.<string>} lineArray Array of unique strings.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCharsToLines = function( diffs, lineArray ) {\n\t\tvar x, chars, text, y;\n\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\tchars = diffs[ x ][ 1 ];\n\t\t\ttext = [];\n\t\t\tfor ( y = 0; y < chars.length; y++ ) {\n\t\t\t\ttext[ y ] = lineArray[ chars.charCodeAt( y ) ];\n\t\t\t}\n\t\t\tdiffs[ x ][ 1 ] = text.join( \"\" );\n\t\t}\n\t};\n\n\t/**\n\t * Reorder and merge like edit sections.  Merge equalities.\n\t * Any edit section can move as long as it doesn't cross an equality.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupMerge = function( diffs ) {\n\t\tvar pointer, countDelete, countInsert, textInsert, textDelete,\n\t\t\tcommonlength, changes, diffPointer, position;\n\t\tdiffs.push( [ DIFF_EQUAL, \"\" ] ); // Add a dummy entry at the end.\n\t\tpointer = 0;\n\t\tcountDelete = 0;\n\t\tcountInsert = 0;\n\t\ttextDelete = \"\";\n\t\ttextInsert = \"\";\n\t\tcommonlength;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tcountInsert++;\n\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\tpointer++;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tcountDelete++;\n\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\tpointer++;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\tif ( countDelete + countInsert > 1 ) {\n\t\t\t\t\tif ( countDelete !== 0 && countInsert !== 0 ) {\n\t\t\t\t\t\t// Factor out any common prefixies.\n\t\t\t\t\t\tcommonlength = this.diffCommonPrefix( textInsert, textDelete );\n\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\tif ( ( pointer - countDelete - countInsert ) > 0 &&\n\t\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 0 ] ===\n\t\t\t\t\t\t\t\t\tDIFF_EQUAL ) {\n\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 1 ] +=\n\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdiffs.splice( 0, 0, [ DIFF_EQUAL,\n\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength )\n\t\t\t\t\t\t\t\t] );\n\t\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttextInsert = textInsert.substring( commonlength );\n\t\t\t\t\t\t\ttextDelete = textDelete.substring( commonlength );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Factor out any common suffixies.\n\t\t\t\t\t\tcommonlength = this.diffCommonSuffix( textInsert, textDelete );\n\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\tdiffs[ pointer ][ 1 ] = textInsert.substring( textInsert.length -\n\t\t\t\t\t\t\t\t\tcommonlength ) + diffs[ pointer ][ 1 ];\n\t\t\t\t\t\t\ttextInsert = textInsert.substring( 0, textInsert.length -\n\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t\ttextDelete = textDelete.substring( 0, textDelete.length -\n\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\tif ( countDelete === 0 ) {\n\t\t\t\t\t\tdiffs.splice( pointer - countInsert,\n\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_INSERT, textInsert ] );\n\t\t\t\t\t} else if ( countInsert === 0 ) {\n\t\t\t\t\t\tdiffs.splice( pointer - countDelete,\n\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_DELETE, textDelete ] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer - countDelete - countInsert,\n\t\t\t\t\t\t\tcountDelete + countInsert,\n\t\t\t\t\t\t\t[ DIFF_DELETE, textDelete ], [ DIFF_INSERT, textInsert ]\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tpointer = pointer - countDelete - countInsert +\n\t\t\t\t\t\t( countDelete ? 1 : 0 ) + ( countInsert ? 1 : 0 ) + 1;\n\t\t\t\t} else if ( pointer !== 0 && diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL ) {\n\n\t\t\t\t\t// Merge this equality with the previous one.\n\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer, 1 );\n\t\t\t\t} else {\n\t\t\t\t\tpointer++;\n\t\t\t\t}\n\t\t\t\tcountInsert = 0;\n\t\t\t\tcountDelete = 0;\n\t\t\t\ttextDelete = \"\";\n\t\t\t\ttextInsert = \"\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( diffs[ diffs.length - 1 ][ 1 ] === \"\" ) {\n\t\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\t\t}\n\n\t\t// Second pass: look for single edits surrounded on both sides by equalities\n\t\t// which can be shifted sideways to eliminate an equality.\n\t\t// e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n\t\tchanges = false;\n\t\tpointer = 1;\n\n\t\t// Intentionally ignore the first and last element (don't need checking).\n\t\twhile ( pointer < diffs.length - 1 ) {\n\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL &&\n\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] === DIFF_EQUAL ) {\n\n\t\t\t\tdiffPointer = diffs[ pointer ][ 1 ];\n\t\t\t\tposition = diffPointer.substring(\n\t\t\t\t\tdiffPointer.length - diffs[ pointer - 1 ][ 1 ].length\n\t\t\t\t);\n\n\t\t\t\t// This is a single edit surrounded by equalities.\n\t\t\t\tif ( position === diffs[ pointer - 1 ][ 1 ] ) {\n\n\t\t\t\t\t// Shift the edit over the previous equality.\n\t\t\t\t\tdiffs[ pointer ][ 1 ] = diffs[ pointer - 1 ][ 1 ] +\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( 0, diffs[ pointer ][ 1 ].length -\n\t\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ].length );\n\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] + diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer - 1, 1 );\n\t\t\t\t\tchanges = true;\n\t\t\t\t} else if ( diffPointer.substring( 0, diffs[ pointer + 1 ][ 1 ].length ) ===\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] ) {\n\n\t\t\t\t\t// Shift the edit over the next equality.\n\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs[ pointer ][ 1 ] =\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( diffs[ pointer + 1 ][ 1 ].length ) +\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer + 1, 1 );\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t\t// If shifts were made, the diff needs reordering and another shift sweep.\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\t};\n\n\treturn function( o, n ) {\n\t\tvar diff, output, text;\n\t\tdiff = new DiffMatchPatch();\n\t\toutput = diff.DiffMain( o, n );\n\t\tdiff.diffCleanupEfficiency( output );\n\t\ttext = diff.diffPrettyHtml( output );\n\n\t\treturn text;\n\t};\n}() );\n"]},"hash":"1324a3c6f6e1817581ec8543672d42fd63ed3f26"}
