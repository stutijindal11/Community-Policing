{"metadata":{"usedHelpers":["typeof"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/foundation-sites/test/javascript/chai.js","filenameRelative":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/foundation-sites/test/javascript/chai.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/foundation-sites/test/javascript/chai.js.map","sourceFileName":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/foundation-sites/test/javascript/chai.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"chai"},"ignored":false,"code":"var _typeof;module.import('babel-runtime/helpers/typeof',{\"default\":function(v){_typeof=v}});\n\n;(function () {\n\n  /**\n   * Require the module at `name`.\n   *\n   * @param {String} name\n   * @return {Object} exports\n   * @api public\n   */\n\n  function require(name) {\n    var module = require.modules[name];\n    if (!module) throw new Error('failed to require \"' + name + '\"');\n\n    if (!('exports' in module) && typeof module.definition === 'function') {\n      module.client = module.component = true;\n      module.definition.call(this, module.exports = {}, module);\n      delete module.definition;\n    }\n\n    return module.exports;\n  }\n\n  /**\n   * Meta info, accessible in the global scope unless you use AMD option.\n   */\n\n  require.loader = 'component';\n\n  /**\n   * Internal helper object, contains a sorting function for semantiv versioning\n   */\n  require.helper = {};\n  require.helper.semVerSort = function (a, b) {\n    var aArray = a.version.split('.');\n    var bArray = b.version.split('.');\n    for (var i = 0; i < aArray.length; ++i) {\n      var aInt = parseInt(aArray[i], 10);\n      var bInt = parseInt(bArray[i], 10);\n      if (aInt === bInt) {\n        var aLex = aArray[i].substr((\"\" + aInt).length);\n        var bLex = bArray[i].substr((\"\" + bInt).length);\n        if (aLex === '' && bLex !== '') return 1;\n        if (aLex !== '' && bLex === '') return -1;\n        if (aLex !== '' && bLex !== '') return aLex > bLex ? 1 : -1;\n        continue;\n      } else if (aInt > bInt) {\n        return 1;\n      } else {\n        return -1;\n      }\n    }\n    return 0;\n  };\n\n  /**\n   * Find and require a module which name starts with the provided name.\n   * If multiple modules exists, the highest semver is used. \n   * This function can only be used for remote dependencies.\n  \n   * @param {String} name - module name: `user~repo`\n   * @param {Boolean} returnPath - returns the canonical require path if true, \n   *                               otherwise it returns the epxorted module\n   */\n  require.latest = function (name, returnPath) {\n    function showError(name) {\n      throw new Error('failed to find latest module of \"' + name + '\"');\n    }\n    // only remotes with semvers, ignore local files conataining a '/'\n    var versionRegexp = /(.*)~(.*)@v?(\\d+\\.\\d+\\.\\d+[^\\/]*)$/;\n    var remoteRegexp = /(.*)~(.*)/;\n    if (!remoteRegexp.test(name)) showError(name);\n    var moduleNames = Object.keys(require.modules);\n    var semVerCandidates = [];\n    var otherCandidates = []; // for instance: name of the git branch\n    for (var i = 0; i < moduleNames.length; i++) {\n      var moduleName = moduleNames[i];\n      if (new RegExp(name + '@').test(moduleName)) {\n        var version = moduleName.substr(name.length + 1);\n        var semVerMatch = versionRegexp.exec(moduleName);\n        if (semVerMatch != null) {\n          semVerCandidates.push({ version: version, name: moduleName });\n        } else {\n          otherCandidates.push({ version: version, name: moduleName });\n        }\n      }\n    }\n    if (semVerCandidates.concat(otherCandidates).length === 0) {\n      showError(name);\n    }\n    if (semVerCandidates.length > 0) {\n      var module = semVerCandidates.sort(require.helper.semVerSort).pop().name;\n      if (returnPath === true) {\n        return module;\n      }\n      return require(module);\n    }\n    // if the build contains more than one branch of the same module\n    // you should not use this funciton\n    var module = otherCandidates.sort(function (a, b) {\n      return a.name > b.name;\n    })[0].name;\n    if (returnPath === true) {\n      return module;\n    }\n    return require(module);\n  };\n\n  /**\n   * Registered modules.\n   */\n\n  require.modules = {};\n\n  /**\n   * Register module at `name` with callback `definition`.\n   *\n   * @param {String} name\n   * @param {Function} definition\n   * @api private\n   */\n\n  require.register = function (name, definition) {\n    require.modules[name] = {\n      definition: definition\n    };\n  };\n\n  /**\n   * Define a module's exports immediately with `exports`.\n   *\n   * @param {String} name\n   * @param {Generic} exports\n   * @api private\n   */\n\n  require.define = function (name, exports) {\n    require.modules[name] = {\n      exports: exports\n    };\n  };\n  require.register(\"chaijs~assertion-error@1.0.0\", function (exports, module) {\n    /*!\n     * assertion-error\n     * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>\n     * MIT Licensed\n     */\n\n    /*!\n     * Return a function that will copy properties from\n     * one object to another excluding any originally\n     * listed. Returned function will create a new `{}`.\n     *\n     * @param {String} excluded properties ...\n     * @return {Function}\n     */\n\n    function exclude() {\n      var excludes = [].slice.call(arguments);\n\n      function excludeProps(res, obj) {\n        Object.keys(obj).forEach(function (key) {\n          if (!~excludes.indexOf(key)) res[key] = obj[key];\n        });\n      }\n\n      return function extendExclude() {\n        var args = [].slice.call(arguments),\n            i = 0,\n            res = {};\n\n        for (; i < args.length; i++) {\n          excludeProps(res, args[i]);\n        }\n\n        return res;\n      };\n    };\n\n    /*!\n     * Primary Exports\n     */\n\n    module.exports = AssertionError;\n\n    /**\n     * ### AssertionError\n     *\n     * An extension of the JavaScript `Error` constructor for\n     * assertion and validation scenarios.\n     *\n     * @param {String} message\n     * @param {Object} properties to include (optional)\n     * @param {callee} start stack function (optional)\n     */\n\n    function AssertionError(message, _props, ssf) {\n      var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON'),\n          props = extend(_props || {});\n\n      // default values\n      this.message = message || 'Unspecified AssertionError';\n      this.showDiff = false;\n\n      // copy from properties\n      for (var key in props) {\n        this[key] = props[key];\n      }\n\n      // capture stack trace\n      ssf = ssf || arguments.callee;\n      if (ssf && Error.captureStackTrace) {\n        Error.captureStackTrace(this, ssf);\n      }\n    }\n\n    /*!\n     * Inherit from Error.prototype\n     */\n\n    AssertionError.prototype = Object.create(Error.prototype);\n\n    /*!\n     * Statically set name\n     */\n\n    AssertionError.prototype.name = 'AssertionError';\n\n    /*!\n     * Ensure correct constructor\n     */\n\n    AssertionError.prototype.constructor = AssertionError;\n\n    /**\n     * Allow errors to be converted to JSON for static transfer.\n     *\n     * @param {Boolean} include stack (default: `true`)\n     * @return {Object} object that can be `JSON.stringify`\n     */\n\n    AssertionError.prototype.toJSON = function (stack) {\n      var extend = exclude('constructor', 'toJSON', 'stack'),\n          props = extend({ name: this.name }, this);\n\n      // include stack if exists and not turned off\n      if (false !== stack && this.stack) {\n        props.stack = this.stack;\n      }\n\n      return props;\n    };\n  });\n\n  require.register(\"chaijs~type-detect@0.1.1\", function (exports, module) {\n    /*!\n     * type-detect\n     * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */\n\n    /*!\n     * Primary Exports\n     */\n\n    var exports = module.exports = getType;\n\n    /*!\n     * Detectable javascript natives\n     */\n\n    var natives = {\n      '[object Array]': 'array',\n      '[object RegExp]': 'regexp',\n      '[object Function]': 'function',\n      '[object Arguments]': 'arguments',\n      '[object Date]': 'date'\n    };\n\n    /**\n     * ### typeOf (obj)\n     *\n     * Use several different techniques to determine\n     * the type of object being tested.\n     *\n     *\n     * @param {Mixed} object\n     * @return {String} object type\n     * @api public\n     */\n\n    function getType(obj) {\n      var str = Object.prototype.toString.call(obj);\n      if (natives[str]) return natives[str];\n      if (obj === null) return 'null';\n      if (obj === undefined) return 'undefined';\n      if (obj === Object(obj)) return 'object';\n      return typeof obj === 'undefined' ? 'undefined' : _typeof(obj);\n    }\n\n    exports.Library = Library;\n\n    /**\n     * ### Library\n     *\n     * Create a repository for custom type detection.\n     *\n     * ```js\n     * var lib = new type.Library;\n     * ```\n     *\n     */\n\n    function Library() {\n      this.tests = {};\n    }\n\n    /**\n     * #### .of (obj)\n     *\n     * Expose replacement `typeof` detection to the library.\n     *\n     * ```js\n     * if ('string' === lib.of('hello world')) {\n     *   // ...\n     * }\n     * ```\n     *\n     * @param {Mixed} object to test\n     * @return {String} type\n     */\n\n    Library.prototype.of = getType;\n\n    /**\n     * #### .define (type, test)\n     *\n     * Add a test to for the `.test()` assertion.\n     *\n     * Can be defined as a regular expression:\n     *\n     * ```js\n     * lib.define('int', /^[0-9]+$/);\n     * ```\n     *\n     * ... or as a function:\n     *\n     * ```js\n     * lib.define('bln', function (obj) {\n     *   if ('boolean' === lib.of(obj)) return true;\n     *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];\n     *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();\n     *   return !! ~blns.indexOf(obj);\n     * });\n     * ```\n     *\n     * @param {String} type\n     * @param {RegExp|Function} test\n     * @api public\n     */\n\n    Library.prototype.define = function (type, test) {\n      if (arguments.length === 1) return this.tests[type];\n      this.tests[type] = test;\n      return this;\n    };\n\n    /**\n     * #### .test (obj, test)\n     *\n     * Assert that an object is of type. Will first\n     * check natives, and if that does not pass it will\n     * use the user defined custom tests.\n     *\n     * ```js\n     * assert(lib.test('1', 'int'));\n     * assert(lib.test('yes', 'bln'));\n     * ```\n     *\n     * @param {Mixed} object\n     * @param {String} type\n     * @return {Boolean} result\n     * @api public\n     */\n\n    Library.prototype.test = function (obj, type) {\n      if (type === getType(obj)) return true;\n      var test = this.tests[type];\n\n      if (test && 'regexp' === getType(test)) {\n        return test.test(obj);\n      } else if (test && 'function' === getType(test)) {\n        return test(obj);\n      } else {\n        throw new ReferenceError('Type test \"' + type + '\" not defined or invalid.');\n      }\n    };\n  });\n\n  require.register(\"chaijs~deep-eql@0.1.3\", function (exports, module) {\n    /*!\n     * deep-eql\n     * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */\n\n    /*!\n     * Module dependencies\n     */\n\n    var type = require('chaijs~type-detect@0.1.1');\n\n    /*!\n     * Buffer.isBuffer browser shim\n     */\n\n    var Buffer;\n    try {\n      Buffer = require('buffer').Buffer;\n    } catch (ex) {\n      Buffer = {};\n      Buffer.isBuffer = function () {\n        return false;\n      };\n    }\n\n    /*!\n     * Primary Export\n     */\n\n    module.exports = deepEqual;\n\n    /**\n     * Assert super-strict (egal) equality between\n     * two objects of any type.\n     *\n     * @param {Mixed} a\n     * @param {Mixed} b\n     * @param {Array} memoised (optional)\n     * @return {Boolean} equal match\n     */\n\n    function deepEqual(a, b, m) {\n      if (sameValue(a, b)) {\n        return true;\n      } else if ('date' === type(a)) {\n        return dateEqual(a, b);\n      } else if ('regexp' === type(a)) {\n        return regexpEqual(a, b);\n      } else if (Buffer.isBuffer(a)) {\n        return bufferEqual(a, b);\n      } else if ('arguments' === type(a)) {\n        return argumentsEqual(a, b, m);\n      } else if (!typeEqual(a, b)) {\n        return false;\n      } else if ('object' !== type(a) && 'object' !== type(b) && 'array' !== type(a) && 'array' !== type(b)) {\n        return sameValue(a, b);\n      } else {\n        return objectEqual(a, b, m);\n      }\n    }\n\n    /*!\n     * Strict (egal) equality test. Ensures that NaN always\n     * equals NaN and `-0` does not equal `+0`.\n     *\n     * @param {Mixed} a\n     * @param {Mixed} b\n     * @return {Boolean} equal match\n     */\n\n    function sameValue(a, b) {\n      if (a === b) return a !== 0 || 1 / a === 1 / b;\n      return a !== a && b !== b;\n    }\n\n    /*!\n     * Compare the types of two given objects and\n     * return if they are equal. Note that an Array\n     * has a type of `array` (not `object`) and arguments\n     * have a type of `arguments` (not `array`/`object`).\n     *\n     * @param {Mixed} a\n     * @param {Mixed} b\n     * @return {Boolean} result\n     */\n\n    function typeEqual(a, b) {\n      return type(a) === type(b);\n    }\n\n    /*!\n     * Compare two Date objects by asserting that\n     * the time values are equal using `saveValue`.\n     *\n     * @param {Date} a\n     * @param {Date} b\n     * @return {Boolean} result\n     */\n\n    function dateEqual(a, b) {\n      if ('date' !== type(b)) return false;\n      return sameValue(a.getTime(), b.getTime());\n    }\n\n    /*!\n     * Compare two regular expressions by converting them\n     * to string and checking for `sameValue`.\n     *\n     * @param {RegExp} a\n     * @param {RegExp} b\n     * @return {Boolean} result\n     */\n\n    function regexpEqual(a, b) {\n      if ('regexp' !== type(b)) return false;\n      return sameValue(a.toString(), b.toString());\n    }\n\n    /*!\n     * Assert deep equality of two `arguments` objects.\n     * Unfortunately, these must be sliced to arrays\n     * prior to test to ensure no bad behavior.\n     *\n     * @param {Arguments} a\n     * @param {Arguments} b\n     * @param {Array} memoize (optional)\n     * @return {Boolean} result\n     */\n\n    function argumentsEqual(a, b, m) {\n      if ('arguments' !== type(b)) return false;\n      a = [].slice.call(a);\n      b = [].slice.call(b);\n      return deepEqual(a, b, m);\n    }\n\n    /*!\n     * Get enumerable properties of a given object.\n     *\n     * @param {Object} a\n     * @return {Array} property names\n     */\n\n    function enumerable(a) {\n      var res = [];\n      for (var key in a) {\n        res.push(key);\n      }return res;\n    }\n\n    /*!\n     * Simple equality for flat iterable objects\n     * such as Arrays or Node.js buffers.\n     *\n     * @param {Iterable} a\n     * @param {Iterable} b\n     * @return {Boolean} result\n     */\n\n    function iterableEqual(a, b) {\n      if (a.length !== b.length) return false;\n\n      var i = 0;\n      var match = true;\n\n      for (; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n          match = false;\n          break;\n        }\n      }\n\n      return match;\n    }\n\n    /*!\n     * Extension to `iterableEqual` specifically\n     * for Node.js Buffers.\n     *\n     * @param {Buffer} a\n     * @param {Mixed} b\n     * @return {Boolean} result\n     */\n\n    function bufferEqual(a, b) {\n      if (!Buffer.isBuffer(b)) return false;\n      return iterableEqual(a, b);\n    }\n\n    /*!\n     * Block for `objectEqual` ensuring non-existing\n     * values don't get in.\n     *\n     * @param {Mixed} object\n     * @return {Boolean} result\n     */\n\n    function isValue(a) {\n      return a !== null && a !== undefined;\n    }\n\n    /*!\n     * Recursively check the equality of two objects.\n     * Once basic sameness has been established it will\n     * defer to `deepEqual` for each enumerable key\n     * in the object.\n     *\n     * @param {Mixed} a\n     * @param {Mixed} b\n     * @return {Boolean} result\n     */\n\n    function objectEqual(a, b, m) {\n      if (!isValue(a) || !isValue(b)) {\n        return false;\n      }\n\n      if (a.prototype !== b.prototype) {\n        return false;\n      }\n\n      var i;\n      if (m) {\n        for (i = 0; i < m.length; i++) {\n          if (m[i][0] === a && m[i][1] === b || m[i][0] === b && m[i][1] === a) {\n            return true;\n          }\n        }\n      } else {\n        m = [];\n      }\n\n      try {\n        var ka = enumerable(a);\n        var kb = enumerable(b);\n      } catch (ex) {\n        return false;\n      }\n\n      ka.sort();\n      kb.sort();\n\n      if (!iterableEqual(ka, kb)) {\n        return false;\n      }\n\n      m.push([a, b]);\n\n      var key;\n      for (i = ka.length - 1; i >= 0; i--) {\n        key = ka[i];\n        if (!deepEqual(a[key], b[key], m)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  });\n\n  require.register(\"chai\", function (exports, module) {\n    module.exports = require('chai/lib/chai.js');\n  });\n\n  require.register(\"chai/lib/chai.js\", function (exports, module) {\n    /*!\n     * chai\n     * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */\n\n    var used = [],\n        exports = module.exports = {};\n\n    /*!\n     * Chai version\n     */\n\n    exports.version = '2.1.0';\n\n    /*!\n     * Assertion Error\n     */\n\n    exports.AssertionError = require('chaijs~assertion-error@1.0.0');\n\n    /*!\n     * Utils for plugins (not exported)\n     */\n\n    var util = require('chai/lib/chai/utils/index.js');\n\n    /**\n     * # .use(function)\n     *\n     * Provides a way to extend the internals of Chai\n     *\n     * @param {Function}\n     * @returns {this} for chaining\n     * @api public\n     */\n\n    exports.use = function (fn) {\n      if (!~used.indexOf(fn)) {\n        fn(this, util);\n        used.push(fn);\n      }\n\n      return this;\n    };\n\n    /*!\n     * Utility Functions\n     */\n\n    exports.util = util;\n\n    /*!\n     * Configuration\n     */\n\n    var config = require('chai/lib/chai/config.js');\n    exports.config = config;\n\n    /*!\n     * Primary `Assertion` prototype\n     */\n\n    var assertion = require('chai/lib/chai/assertion.js');\n    exports.use(assertion);\n\n    /*!\n     * Core Assertions\n     */\n\n    var core = require('chai/lib/chai/core/assertions.js');\n    exports.use(core);\n\n    /*!\n     * Expect interface\n     */\n\n    var expect = require('chai/lib/chai/interface/expect.js');\n    exports.use(expect);\n\n    /*!\n     * Should interface\n     */\n\n    var should = require('chai/lib/chai/interface/should.js');\n    exports.use(should);\n\n    /*!\n     * Assert interface\n     */\n\n    var assert = require('chai/lib/chai/interface/assert.js');\n    exports.use(assert);\n  });\n\n  require.register(\"chai/lib/chai/assertion.js\", function (exports, module) {\n    /*!\n     * chai\n     * http://chaijs.com\n     * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */\n\n    var config = require('chai/lib/chai/config.js');\n\n    module.exports = function (_chai, util) {\n      /*!\n       * Module dependencies.\n       */\n\n      var AssertionError = _chai.AssertionError,\n          flag = util.flag;\n\n      /*!\n       * Module export.\n       */\n\n      _chai.Assertion = Assertion;\n\n      /*!\n       * Assertion Constructor\n       *\n       * Creates object for chaining.\n       *\n       * @api private\n       */\n\n      function Assertion(obj, msg, stack) {\n        flag(this, 'ssfi', stack || arguments.callee);\n        flag(this, 'object', obj);\n        flag(this, 'message', msg);\n      }\n\n      Object.defineProperty(Assertion, 'includeStack', {\n        get: function get() {\n          console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');\n          return config.includeStack;\n        },\n        set: function set(value) {\n          console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');\n          config.includeStack = value;\n        }\n      });\n\n      Object.defineProperty(Assertion, 'showDiff', {\n        get: function get() {\n          console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');\n          return config.showDiff;\n        },\n        set: function set(value) {\n          console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');\n          config.showDiff = value;\n        }\n      });\n\n      Assertion.addProperty = function (name, fn) {\n        util.addProperty(this.prototype, name, fn);\n      };\n\n      Assertion.addMethod = function (name, fn) {\n        util.addMethod(this.prototype, name, fn);\n      };\n\n      Assertion.addChainableMethod = function (name, fn, chainingBehavior) {\n        util.addChainableMethod(this.prototype, name, fn, chainingBehavior);\n      };\n\n      Assertion.overwriteProperty = function (name, fn) {\n        util.overwriteProperty(this.prototype, name, fn);\n      };\n\n      Assertion.overwriteMethod = function (name, fn) {\n        util.overwriteMethod(this.prototype, name, fn);\n      };\n\n      Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {\n        util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);\n      };\n\n      /*!\n       * ### .assert(expression, message, negateMessage, expected, actual)\n       *\n       * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.\n       *\n       * @name assert\n       * @param {Philosophical} expression to be tested\n       * @param {String or Function} message or function that returns message to display if fails\n       * @param {String or Function} negatedMessage or function that returns negatedMessage to display if negated expression fails\n       * @param {Mixed} expected value (remember to check for negation)\n       * @param {Mixed} actual (optional) will default to `this.obj`\n       * @api private\n       */\n\n      Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {\n        var ok = util.test(this, arguments);\n        if (true !== showDiff) showDiff = false;\n        if (true !== config.showDiff) showDiff = false;\n\n        if (!ok) {\n          var msg = util.getMessage(this, arguments),\n              actual = util.getActual(this, arguments);\n          throw new AssertionError(msg, {\n            actual: actual,\n            expected: expected,\n            showDiff: showDiff\n          }, config.includeStack ? this.assert : flag(this, 'ssfi'));\n        }\n      };\n\n      /*!\n       * ### ._obj\n       *\n       * Quick reference to stored `actual` value for plugin developers.\n       *\n       * @api private\n       */\n\n      Object.defineProperty(Assertion.prototype, '_obj', { get: function get() {\n          return flag(this, 'object');\n        },\n        set: function set(val) {\n          flag(this, 'object', val);\n        }\n      });\n    };\n  });\n\n  require.register(\"chai/lib/chai/config.js\", function (exports, module) {\n    module.exports = {\n\n      /**\n       * ### config.includeStack\n       *\n       * User configurable property, influences whether stack trace\n       * is included in Assertion error message. Default of false\n       * suppresses stack trace in the error message.\n       *\n       *     chai.config.includeStack = true;  // enable stack on error\n       *\n       * @param {Boolean}\n       * @api public\n       */\n\n      includeStack: false,\n\n      /**\n       * ### config.showDiff\n       *\n       * User configurable property, influences whether or not\n       * the `showDiff` flag should be included in the thrown\n       * AssertionErrors. `false` will always be `false`; `true`\n       * will be true when the assertion has requested a diff\n       * be shown.\n       *\n       * @param {Boolean}\n       * @api public\n       */\n\n      showDiff: true,\n\n      /**\n       * ### config.truncateThreshold\n       *\n       * User configurable property, sets length threshold for actual and\n       * expected values in assertion errors. If this threshold is exceeded,\n       * the value is truncated.\n       *\n       * Set it to zero if you want to disable truncating altogether.\n       *\n       *     chai.config.truncateThreshold = 0;  // disable truncating\n       *\n       * @param {Number}\n       * @api public\n       */\n\n      truncateThreshold: 40\n\n    };\n  });\n\n  require.register(\"chai/lib/chai/core/assertions.js\", function (exports, module) {\n    /*!\n     * chai\n     * http://chaijs.com\n     * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */\n\n    module.exports = function (chai, _) {\n      var Assertion = chai.Assertion,\n          toString = Object.prototype.toString,\n          flag = _.flag;\n\n      /**\n       * ### Language Chains\n       *\n       * The following are provided as chainable getters to\n       * improve the readability of your assertions. They\n       * do not provide testing capabilities unless they\n       * have been overwritten by a plugin.\n       *\n       * **Chains**\n       *\n       * - to\n       * - be\n       * - been\n       * - is\n       * - that\n       * - which\n       * - and\n       * - has\n       * - have\n       * - with\n       * - at\n       * - of\n       * - same\n       *\n       * @name language chains\n       * @api public\n       */\n\n      ['to', 'be', 'been', 'is', 'and', 'has', 'have', 'with', 'that', 'which', 'at', 'of', 'same'].forEach(function (chain) {\n        Assertion.addProperty(chain, function () {\n          return this;\n        });\n      });\n\n      /**\n       * ### .not\n       *\n       * Negates any of assertions following in the chain.\n       *\n       *     expect(foo).to.not.equal('bar');\n       *     expect(goodFn).to.not.throw(Error);\n       *     expect({ foo: 'baz' }).to.have.property('foo')\n       *       .and.not.equal('bar');\n       *\n       * @name not\n       * @api public\n       */\n\n      Assertion.addProperty('not', function () {\n        flag(this, 'negate', true);\n      });\n\n      /**\n       * ### .deep\n       *\n       * Sets the `deep` flag, later used by the `equal` and\n       * `property` assertions.\n       *\n       *     expect(foo).to.deep.equal({ bar: 'baz' });\n       *     expect({ foo: { bar: { baz: 'quux' } } })\n       *       .to.have.deep.property('foo.bar.baz', 'quux');\n       *\n       * @name deep\n       * @api public\n       */\n\n      Assertion.addProperty('deep', function () {\n        flag(this, 'deep', true);\n      });\n\n      /**\n       * ### .any\n       *\n       * Sets the `any` flag, (opposite of the `all` flag)\n       * later used in the `keys` assertion. \n       *\n       *     expect(foo).to.have.any.keys('bar', 'baz');\n       *\n       * @name any\n       * @api public\n       */\n\n      Assertion.addProperty('any', function () {\n        flag(this, 'any', true);\n        flag(this, 'all', false);\n      });\n\n      /**\n       * ### .all\n       *\n       * Sets the `all` flag (opposite of the `any` flag) \n       * later used by the `keys` assertion.\n       *\n       *     expect(foo).to.have.all.keys('bar', 'baz');\n       *\n       * @name all\n       * @api public\n       */\n\n      Assertion.addProperty('all', function () {\n        flag(this, 'all', true);\n        flag(this, 'any', false);\n      });\n\n      /**\n       * ### .a(type)\n       *\n       * The `a` and `an` assertions are aliases that can be\n       * used either as language chains or to assert a value's\n       * type.\n       *\n       *     // typeof\n       *     expect('test').to.be.a('string');\n       *     expect({ foo: 'bar' }).to.be.an('object');\n       *     expect(null).to.be.a('null');\n       *     expect(undefined).to.be.an('undefined');\n       *\n       *     // language chain\n       *     expect(foo).to.be.an.instanceof(Foo);\n       *\n       * @name a\n       * @alias an\n       * @param {String} type\n       * @param {String} message _optional_\n       * @api public\n       */\n\n      function an(type, msg) {\n        if (msg) flag(this, 'message', msg);\n        type = type.toLowerCase();\n        var obj = flag(this, 'object'),\n            article = ~['a', 'e', 'i', 'o', 'u'].indexOf(type.charAt(0)) ? 'an ' : 'a ';\n\n        this.assert(type === _.type(obj), 'expected #{this} to be ' + article + type, 'expected #{this} not to be ' + article + type);\n      }\n\n      Assertion.addChainableMethod('an', an);\n      Assertion.addChainableMethod('a', an);\n\n      /**\n       * ### .include(value)\n       *\n       * The `include` and `contain` assertions can be used as either property\n       * based language chains or as methods to assert the inclusion of an object\n       * in an array or a substring in a string. When used as language chains,\n       * they toggle the `contains` flag for the `keys` assertion.\n       *\n       *     expect([1,2,3]).to.include(2);\n       *     expect('foobar').to.contain('foo');\n       *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');\n       *\n       * @name include\n       * @alias contain\n       * @alias includes\n       * @alias contains\n       * @param {Object|String|Number} obj\n       * @param {String} message _optional_\n       * @api public\n       */\n\n      function includeChainingBehavior() {\n        flag(this, 'contains', true);\n      }\n\n      function include(val, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object');\n        var expected = false;\n        if (_.type(obj) === 'array' && _.type(val) === 'object') {\n          for (var i in obj) {\n            if (_.eql(obj[i], val)) {\n              expected = true;\n              break;\n            }\n          }\n        } else if (_.type(val) === 'object') {\n          if (!flag(this, 'negate')) {\n            for (var k in val) {\n              new Assertion(obj).property(k, val[k]);\n            }return;\n          }\n          var subset = {};\n          for (var k in val) {\n            subset[k] = obj[k];\n          }expected = _.eql(subset, val);\n        } else {\n          expected = obj && ~obj.indexOf(val);\n        }\n        this.assert(expected, 'expected #{this} to include ' + _.inspect(val), 'expected #{this} to not include ' + _.inspect(val));\n      }\n\n      Assertion.addChainableMethod('include', include, includeChainingBehavior);\n      Assertion.addChainableMethod('contain', include, includeChainingBehavior);\n      Assertion.addChainableMethod('contains', include, includeChainingBehavior);\n      Assertion.addChainableMethod('includes', include, includeChainingBehavior);\n\n      /**\n       * ### .ok\n       *\n       * Asserts that the target is truthy.\n       *\n       *     expect('everthing').to.be.ok;\n       *     expect(1).to.be.ok;\n       *     expect(false).to.not.be.ok;\n       *     expect(undefined).to.not.be.ok;\n       *     expect(null).to.not.be.ok;\n       *\n       * @name ok\n       * @api public\n       */\n\n      Assertion.addProperty('ok', function () {\n        this.assert(flag(this, 'object'), 'expected #{this} to be truthy', 'expected #{this} to be falsy');\n      });\n\n      /**\n       * ### .true\n       *\n       * Asserts that the target is `true`.\n       *\n       *     expect(true).to.be.true;\n       *     expect(1).to.not.be.true;\n       *\n       * @name true\n       * @api public\n       */\n\n      Assertion.addProperty('true', function () {\n        this.assert(true === flag(this, 'object'), 'expected #{this} to be true', 'expected #{this} to be false', this.negate ? false : true);\n      });\n\n      /**\n       * ### .false\n       *\n       * Asserts that the target is `false`.\n       *\n       *     expect(false).to.be.false;\n       *     expect(0).to.not.be.false;\n       *\n       * @name false\n       * @api public\n       */\n\n      Assertion.addProperty('false', function () {\n        this.assert(false === flag(this, 'object'), 'expected #{this} to be false', 'expected #{this} to be true', this.negate ? true : false);\n      });\n\n      /**\n       * ### .null\n       *\n       * Asserts that the target is `null`.\n       *\n       *     expect(null).to.be.null;\n       *     expect(undefined).not.to.be.null;\n       *\n       * @name null\n       * @api public\n       */\n\n      Assertion.addProperty('null', function () {\n        this.assert(null === flag(this, 'object'), 'expected #{this} to be null', 'expected #{this} not to be null');\n      });\n\n      /**\n       * ### .undefined\n       *\n       * Asserts that the target is `undefined`.\n       *\n       *     expect(undefined).to.be.undefined;\n       *     expect(null).to.not.be.undefined;\n       *\n       * @name undefined\n       * @api public\n       */\n\n      Assertion.addProperty('undefined', function () {\n        this.assert(undefined === flag(this, 'object'), 'expected #{this} to be undefined', 'expected #{this} not to be undefined');\n      });\n\n      /**\n       * ### .exist\n       *\n       * Asserts that the target is neither `null` nor `undefined`.\n       *\n       *     var foo = 'hi'\n       *       , bar = null\n       *       , baz;\n       *\n       *     expect(foo).to.exist;\n       *     expect(bar).to.not.exist;\n       *     expect(baz).to.not.exist;\n       *\n       * @name exist\n       * @api public\n       */\n\n      Assertion.addProperty('exist', function () {\n        this.assert(null != flag(this, 'object'), 'expected #{this} to exist', 'expected #{this} to not exist');\n      });\n\n      /**\n       * ### .empty\n       *\n       * Asserts that the target's length is `0`. For arrays, it checks\n       * the `length` property. For objects, it gets the count of\n       * enumerable keys.\n       *\n       *     expect([]).to.be.empty;\n       *     expect('').to.be.empty;\n       *     expect({}).to.be.empty;\n       *\n       * @name empty\n       * @api public\n       */\n\n      Assertion.addProperty('empty', function () {\n        var obj = flag(this, 'object'),\n            expected = obj;\n\n        if (Array.isArray(obj) || 'string' === typeof object) {\n          expected = obj.length;\n        } else if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {\n          expected = Object.keys(obj).length;\n        }\n\n        this.assert(!expected, 'expected #{this} to be empty', 'expected #{this} not to be empty');\n      });\n\n      /**\n       * ### .arguments\n       *\n       * Asserts that the target is an arguments object.\n       *\n       *     function test () {\n       *       expect(arguments).to.be.arguments;\n       *     }\n       *\n       * @name arguments\n       * @alias Arguments\n       * @api public\n       */\n\n      function checkArguments() {\n        var obj = flag(this, 'object'),\n            type = Object.prototype.toString.call(obj);\n        this.assert('[object Arguments]' === type, 'expected #{this} to be arguments but got ' + type, 'expected #{this} to not be arguments');\n      }\n\n      Assertion.addProperty('arguments', checkArguments);\n      Assertion.addProperty('Arguments', checkArguments);\n\n      /**\n       * ### .equal(value)\n       *\n       * Asserts that the target is strictly equal (`===`) to `value`.\n       * Alternately, if the `deep` flag is set, asserts that\n       * the target is deeply equal to `value`.\n       *\n       *     expect('hello').to.equal('hello');\n       *     expect(42).to.equal(42);\n       *     expect(1).to.not.equal(true);\n       *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });\n       *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });\n       *\n       * @name equal\n       * @alias equals\n       * @alias eq\n       * @alias deep.equal\n       * @param {Mixed} value\n       * @param {String} message _optional_\n       * @api public\n       */\n\n      function assertEqual(val, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object');\n        if (flag(this, 'deep')) {\n          return this.eql(val);\n        } else {\n          this.assert(val === obj, 'expected #{this} to equal #{exp}', 'expected #{this} to not equal #{exp}', val, this._obj, true);\n        }\n      }\n\n      Assertion.addMethod('equal', assertEqual);\n      Assertion.addMethod('equals', assertEqual);\n      Assertion.addMethod('eq', assertEqual);\n\n      /**\n       * ### .eql(value)\n       *\n       * Asserts that the target is deeply equal to `value`.\n       *\n       *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });\n       *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);\n       *\n       * @name eql\n       * @alias eqls\n       * @param {Mixed} value\n       * @param {String} message _optional_\n       * @api public\n       */\n\n      function assertEql(obj, msg) {\n        if (msg) flag(this, 'message', msg);\n        this.assert(_.eql(obj, flag(this, 'object')), 'expected #{this} to deeply equal #{exp}', 'expected #{this} to not deeply equal #{exp}', obj, this._obj, true);\n      }\n\n      Assertion.addMethod('eql', assertEql);\n      Assertion.addMethod('eqls', assertEql);\n\n      /**\n       * ### .above(value)\n       *\n       * Asserts that the target is greater than `value`.\n       *\n       *     expect(10).to.be.above(5);\n       *\n       * Can also be used in conjunction with `length` to\n       * assert a minimum length. The benefit being a\n       * more informative error message than if the length\n       * was supplied directly.\n       *\n       *     expect('foo').to.have.length.above(2);\n       *     expect([ 1, 2, 3 ]).to.have.length.above(2);\n       *\n       * @name above\n       * @alias gt\n       * @alias greaterThan\n       * @param {Number} value\n       * @param {String} message _optional_\n       * @api public\n       */\n\n      function assertAbove(n, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object');\n        if (flag(this, 'doLength')) {\n          new Assertion(obj, msg).to.have.property('length');\n          var len = obj.length;\n          this.assert(len > n, 'expected #{this} to have a length above #{exp} but got #{act}', 'expected #{this} to not have a length above #{exp}', n, len);\n        } else {\n          this.assert(obj > n, 'expected #{this} to be above ' + n, 'expected #{this} to be at most ' + n);\n        }\n      }\n\n      Assertion.addMethod('above', assertAbove);\n      Assertion.addMethod('gt', assertAbove);\n      Assertion.addMethod('greaterThan', assertAbove);\n\n      /**\n       * ### .least(value)\n       *\n       * Asserts that the target is greater than or equal to `value`.\n       *\n       *     expect(10).to.be.at.least(10);\n       *\n       * Can also be used in conjunction with `length` to\n       * assert a minimum length. The benefit being a\n       * more informative error message than if the length\n       * was supplied directly.\n       *\n       *     expect('foo').to.have.length.of.at.least(2);\n       *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);\n       *\n       * @name least\n       * @alias gte\n       * @param {Number} value\n       * @param {String} message _optional_\n       * @api public\n       */\n\n      function assertLeast(n, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object');\n        if (flag(this, 'doLength')) {\n          new Assertion(obj, msg).to.have.property('length');\n          var len = obj.length;\n          this.assert(len >= n, 'expected #{this} to have a length at least #{exp} but got #{act}', 'expected #{this} to have a length below #{exp}', n, len);\n        } else {\n          this.assert(obj >= n, 'expected #{this} to be at least ' + n, 'expected #{this} to be below ' + n);\n        }\n      }\n\n      Assertion.addMethod('least', assertLeast);\n      Assertion.addMethod('gte', assertLeast);\n\n      /**\n       * ### .below(value)\n       *\n       * Asserts that the target is less than `value`.\n       *\n       *     expect(5).to.be.below(10);\n       *\n       * Can also be used in conjunction with `length` to\n       * assert a maximum length. The benefit being a\n       * more informative error message than if the length\n       * was supplied directly.\n       *\n       *     expect('foo').to.have.length.below(4);\n       *     expect([ 1, 2, 3 ]).to.have.length.below(4);\n       *\n       * @name below\n       * @alias lt\n       * @alias lessThan\n       * @param {Number} value\n       * @param {String} message _optional_\n       * @api public\n       */\n\n      function assertBelow(n, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object');\n        if (flag(this, 'doLength')) {\n          new Assertion(obj, msg).to.have.property('length');\n          var len = obj.length;\n          this.assert(len < n, 'expected #{this} to have a length below #{exp} but got #{act}', 'expected #{this} to not have a length below #{exp}', n, len);\n        } else {\n          this.assert(obj < n, 'expected #{this} to be below ' + n, 'expected #{this} to be at least ' + n);\n        }\n      }\n\n      Assertion.addMethod('below', assertBelow);\n      Assertion.addMethod('lt', assertBelow);\n      Assertion.addMethod('lessThan', assertBelow);\n\n      /**\n       * ### .most(value)\n       *\n       * Asserts that the target is less than or equal to `value`.\n       *\n       *     expect(5).to.be.at.most(5);\n       *\n       * Can also be used in conjunction with `length` to\n       * assert a maximum length. The benefit being a\n       * more informative error message than if the length\n       * was supplied directly.\n       *\n       *     expect('foo').to.have.length.of.at.most(4);\n       *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);\n       *\n       * @name most\n       * @alias lte\n       * @param {Number} value\n       * @param {String} message _optional_\n       * @api public\n       */\n\n      function assertMost(n, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object');\n        if (flag(this, 'doLength')) {\n          new Assertion(obj, msg).to.have.property('length');\n          var len = obj.length;\n          this.assert(len <= n, 'expected #{this} to have a length at most #{exp} but got #{act}', 'expected #{this} to have a length above #{exp}', n, len);\n        } else {\n          this.assert(obj <= n, 'expected #{this} to be at most ' + n, 'expected #{this} to be above ' + n);\n        }\n      }\n\n      Assertion.addMethod('most', assertMost);\n      Assertion.addMethod('lte', assertMost);\n\n      /**\n       * ### .within(start, finish)\n       *\n       * Asserts that the target is within a range.\n       *\n       *     expect(7).to.be.within(5,10);\n       *\n       * Can also be used in conjunction with `length` to\n       * assert a length range. The benefit being a\n       * more informative error message than if the length\n       * was supplied directly.\n       *\n       *     expect('foo').to.have.length.within(2,4);\n       *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);\n       *\n       * @name within\n       * @param {Number} start lowerbound inclusive\n       * @param {Number} finish upperbound inclusive\n       * @param {String} message _optional_\n       * @api public\n       */\n\n      Assertion.addMethod('within', function (start, finish, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object'),\n            range = start + '..' + finish;\n        if (flag(this, 'doLength')) {\n          new Assertion(obj, msg).to.have.property('length');\n          var len = obj.length;\n          this.assert(len >= start && len <= finish, 'expected #{this} to have a length within ' + range, 'expected #{this} to not have a length within ' + range);\n        } else {\n          this.assert(obj >= start && obj <= finish, 'expected #{this} to be within ' + range, 'expected #{this} to not be within ' + range);\n        }\n      });\n\n      /**\n       * ### .instanceof(constructor)\n       *\n       * Asserts that the target is an instance of `constructor`.\n       *\n       *     var Tea = function (name) { this.name = name; }\n       *       , Chai = new Tea('chai');\n       *\n       *     expect(Chai).to.be.an.instanceof(Tea);\n       *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);\n       *\n       * @name instanceof\n       * @param {Constructor} constructor\n       * @param {String} message _optional_\n       * @alias instanceOf\n       * @api public\n       */\n\n      function assertInstanceOf(constructor, msg) {\n        if (msg) flag(this, 'message', msg);\n        var name = _.getName(constructor);\n        this.assert(flag(this, 'object') instanceof constructor, 'expected #{this} to be an instance of ' + name, 'expected #{this} to not be an instance of ' + name);\n      };\n\n      Assertion.addMethod('instanceof', assertInstanceOf);\n      Assertion.addMethod('instanceOf', assertInstanceOf);\n\n      /**\n       * ### .property(name, [value])\n       *\n       * Asserts that the target has a property `name`, optionally asserting that\n       * the value of that property is strictly equal to  `value`.\n       * If the `deep` flag is set, you can use dot- and bracket-notation for deep\n       * references into objects and arrays.\n       *\n       *     // simple referencing\n       *     var obj = { foo: 'bar' };\n       *     expect(obj).to.have.property('foo');\n       *     expect(obj).to.have.property('foo', 'bar');\n       *\n       *     // deep referencing\n       *     var deepObj = {\n       *         green: { tea: 'matcha' }\n       *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]\n       *     };\n        *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');\n       *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');\n       *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');\n       *\n       * You can also use an array as the starting point of a `deep.property`\n       * assertion, or traverse nested arrays.\n       *\n       *     var arr = [\n       *         [ 'chai', 'matcha', 'konacha' ]\n       *       , [ { tea: 'chai' }\n       *         , { tea: 'matcha' }\n       *         , { tea: 'konacha' } ]\n       *     ];\n       *\n       *     expect(arr).to.have.deep.property('[0][1]', 'matcha');\n       *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');\n       *\n       * Furthermore, `property` changes the subject of the assertion\n       * to be the value of that property from the original object. This\n       * permits for further chainable assertions on that property.\n       *\n       *     expect(obj).to.have.property('foo')\n       *       .that.is.a('string');\n       *     expect(deepObj).to.have.property('green')\n       *       .that.is.an('object')\n       *       .that.deep.equals({ tea: 'matcha' });\n       *     expect(deepObj).to.have.property('teas')\n       *       .that.is.an('array')\n       *       .with.deep.property('[2]')\n       *         .that.deep.equals({ tea: 'konacha' });\n       *\n       * @name property\n       * @alias deep.property\n       * @param {String} name\n       * @param {Mixed} value (optional)\n       * @param {String} message _optional_\n       * @returns value of property for chaining\n       * @api public\n       */\n\n      Assertion.addMethod('property', function (name, val, msg) {\n        if (msg) flag(this, 'message', msg);\n\n        var isDeep = !!flag(this, 'deep'),\n            descriptor = isDeep ? 'deep property ' : 'property ',\n            negate = flag(this, 'negate'),\n            obj = flag(this, 'object'),\n            pathInfo = isDeep ? _.getPathInfo(name, obj) : null,\n            hasProperty = isDeep ? pathInfo.exists : _.hasProperty(name, obj),\n            value = isDeep ? pathInfo.value : obj[name];\n\n        if (negate && undefined !== val) {\n          if (undefined === value) {\n            msg = msg != null ? msg + ': ' : '';\n            throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name));\n          }\n        } else {\n          this.assert(hasProperty, 'expected #{this} to have a ' + descriptor + _.inspect(name), 'expected #{this} to not have ' + descriptor + _.inspect(name));\n        }\n\n        if (undefined !== val) {\n          this.assert(val === value, 'expected #{this} to have a ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}', 'expected #{this} to not have a ' + descriptor + _.inspect(name) + ' of #{act}', val, value);\n        }\n\n        flag(this, 'object', value);\n      });\n\n      /**\n       * ### .ownProperty(name)\n       *\n       * Asserts that the target has an own property `name`.\n       *\n       *     expect('test').to.have.ownProperty('length');\n       *\n       * @name ownProperty\n       * @alias haveOwnProperty\n       * @param {String} name\n       * @param {String} message _optional_\n       * @api public\n       */\n\n      function assertOwnProperty(name, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object');\n        this.assert(obj.hasOwnProperty(name), 'expected #{this} to have own property ' + _.inspect(name), 'expected #{this} to not have own property ' + _.inspect(name));\n      }\n\n      Assertion.addMethod('ownProperty', assertOwnProperty);\n      Assertion.addMethod('haveOwnProperty', assertOwnProperty);\n\n      /**\n       * ### .length(value)\n       *\n       * Asserts that the target's `length` property has\n       * the expected value.\n       *\n       *     expect([ 1, 2, 3]).to.have.length(3);\n       *     expect('foobar').to.have.length(6);\n       *\n       * Can also be used as a chain precursor to a value\n       * comparison for the length property.\n       *\n       *     expect('foo').to.have.length.above(2);\n       *     expect([ 1, 2, 3 ]).to.have.length.above(2);\n       *     expect('foo').to.have.length.below(4);\n       *     expect([ 1, 2, 3 ]).to.have.length.below(4);\n       *     expect('foo').to.have.length.within(2,4);\n       *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);\n       *\n       * @name length\n       * @alias lengthOf\n       * @param {Number} length\n       * @param {String} message _optional_\n       * @api public\n       */\n\n      function assertLengthChain() {\n        flag(this, 'doLength', true);\n      }\n\n      function assertLength(n, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object');\n        new Assertion(obj, msg).to.have.property('length');\n        var len = obj.length;\n\n        this.assert(len == n, 'expected #{this} to have a length of #{exp} but got #{act}', 'expected #{this} to not have a length of #{act}', n, len);\n      }\n\n      Assertion.addChainableMethod('length', assertLength, assertLengthChain);\n      Assertion.addMethod('lengthOf', assertLength);\n\n      /**\n       * ### .match(regexp)\n       *\n       * Asserts that the target matches a regular expression.\n       *\n       *     expect('foobar').to.match(/^foo/);\n       *\n       * @name match\n       * @param {RegExp} RegularExpression\n       * @param {String} message _optional_\n       * @api public\n       */\n\n      Assertion.addMethod('match', function (re, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object');\n        this.assert(re.exec(obj), 'expected #{this} to match ' + re, 'expected #{this} not to match ' + re);\n      });\n\n      /**\n       * ### .string(string)\n       *\n       * Asserts that the string target contains another string.\n       *\n       *     expect('foobar').to.have.string('bar');\n       *\n       * @name string\n       * @param {String} string\n       * @param {String} message _optional_\n       * @api public\n       */\n\n      Assertion.addMethod('string', function (str, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object');\n        new Assertion(obj, msg).is.a('string');\n\n        this.assert(~obj.indexOf(str), 'expected #{this} to contain ' + _.inspect(str), 'expected #{this} to not contain ' + _.inspect(str));\n      });\n\n      /**\n       * ### .keys(key1, [key2], [...])\n       *\n       * Asserts that the target contains any or all of the passed-in keys.\n       * Use in combination with `any`, `all`, `contains`, or `have` will affect \n       * what will pass.\n       * \n       * When used in conjunction with `any`, at least one key that is passed \n       * in must exist in the target object. This is regardless whether or not \n       * the `have` or `contain` qualifiers are used. Note, either `any` or `all`\n       * should be used in the assertion. If neither are used, the assertion is\n       * defaulted to `all`.\n       * \n       * When both `all` and `contain` are used, the target object must have at \n       * least all of the passed-in keys but may have more keys not listed.\n       * \n       * When both `all` and `have` are used, the target object must both contain\n       * all of the passed-in keys AND the number of keys in the target object must\n       * match the number of keys passed in (in other words, a target object must \n       * have all and only all of the passed-in keys).\n       * \n       *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo', 'baz');\n       *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo');\n       *     expect({ foo: 1, bar: 2 }).to.contain.any.keys('bar', 'baz');\n       *     expect({ foo: 1, bar: 2 }).to.contain.any.keys(['foo']);\n       *     expect({ foo: 1, bar: 2 }).to.contain.any.keys({'foo': 6});\n       *     expect({ foo: 1, bar: 2 }).to.have.all.keys(['bar', 'foo']);\n       *     expect({ foo: 1, bar: 2 }).to.have.all.keys({'bar': 6, 'foo', 7});\n       *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys(['bar', 'foo']);\n       *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys([{'bar': 6}}]);\n       *\n       *\n       * @name keys\n       * @alias key\n       * @param {String...|Array|Object} keys\n       * @api public\n       */\n\n      function assertKeys(keys) {\n        var obj = flag(this, 'object'),\n            str,\n            ok = true,\n            mixedArgsMsg = 'keys must be given single argument of Array|Object|String, or multiple String arguments';\n\n        switch (_.type(keys)) {\n          case \"array\":\n            if (arguments.length > 1) throw new Error(mixedArgsMsg);\n            break;\n          case \"object\":\n            if (arguments.length > 1) throw new Error(mixedArgsMsg);\n            keys = Object.keys(keys);\n            break;\n          default:\n            keys = Array.prototype.slice.call(arguments);\n        }\n\n        if (!keys.length) throw new Error('keys required');\n\n        var actual = Object.keys(obj),\n            expected = keys,\n            len = keys.length,\n            any = flag(this, 'any'),\n            all = flag(this, 'all');\n\n        if (!any && !all) {\n          all = true;\n        }\n\n        // Has any\n        if (any) {\n          var intersection = expected.filter(function (key) {\n            return ~actual.indexOf(key);\n          });\n          ok = intersection.length > 0;\n        }\n\n        // Has all\n        if (all) {\n          ok = keys.every(function (key) {\n            return ~actual.indexOf(key);\n          });\n          if (!flag(this, 'negate') && !flag(this, 'contains')) {\n            ok = ok && keys.length == actual.length;\n          }\n        }\n\n        // Key string\n        if (len > 1) {\n          keys = keys.map(function (key) {\n            return _.inspect(key);\n          });\n          var last = keys.pop();\n          if (all) {\n            str = keys.join(', ') + ', and ' + last;\n          }\n          if (any) {\n            str = keys.join(', ') + ', or ' + last;\n          }\n        } else {\n          str = _.inspect(keys[0]);\n        }\n\n        // Form\n        str = (len > 1 ? 'keys ' : 'key ') + str;\n\n        // Have / include\n        str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;\n\n        // Assertion\n        this.assert(ok, 'expected #{this} to ' + str, 'expected #{this} to not ' + str, expected.slice(0).sort(), actual.sort(), true);\n      }\n\n      Assertion.addMethod('keys', assertKeys);\n      Assertion.addMethod('key', assertKeys);\n\n      /**\n       * ### .throw(constructor)\n       *\n       * Asserts that the function target will throw a specific error, or specific type of error\n       * (as determined using `instanceof`), optionally with a RegExp or string inclusion test\n       * for the error's message.\n       *\n       *     var err = new ReferenceError('This is a bad function.');\n       *     var fn = function () { throw err; }\n       *     expect(fn).to.throw(ReferenceError);\n       *     expect(fn).to.throw(Error);\n       *     expect(fn).to.throw(/bad function/);\n       *     expect(fn).to.not.throw('good function');\n       *     expect(fn).to.throw(ReferenceError, /bad function/);\n       *     expect(fn).to.throw(err);\n       *     expect(fn).to.not.throw(new RangeError('Out of range.'));\n       *\n       * Please note that when a throw expectation is negated, it will check each\n       * parameter independently, starting with error constructor type. The appropriate way\n       * to check for the existence of a type of error but for a message that does not match\n       * is to use `and`.\n       *\n       *     expect(fn).to.throw(ReferenceError)\n       *        .and.not.throw(/good function/);\n       *\n       * @name throw\n       * @alias throws\n       * @alias Throw\n       * @param {ErrorConstructor} constructor\n       * @param {String|RegExp} expected error message\n       * @param {String} message _optional_\n       * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n       * @returns error for chaining (null if no error)\n       * @api public\n       */\n\n      function assertThrows(constructor, errMsg, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object');\n        new Assertion(obj, msg).is.a('function');\n\n        var thrown = false,\n            desiredError = null,\n            name = null,\n            thrownError = null;\n\n        if (arguments.length === 0) {\n          errMsg = null;\n          constructor = null;\n        } else if (constructor && (constructor instanceof RegExp || 'string' === typeof constructor)) {\n          errMsg = constructor;\n          constructor = null;\n        } else if (constructor && constructor instanceof Error) {\n          desiredError = constructor;\n          constructor = null;\n          errMsg = null;\n        } else if (typeof constructor === 'function') {\n          name = constructor.prototype.name || constructor.name;\n          if (name === 'Error' && constructor !== Error) {\n            name = new constructor().name;\n          }\n        } else {\n          constructor = null;\n        }\n\n        try {\n          obj();\n        } catch (err) {\n          // first, check desired error\n          if (desiredError) {\n            this.assert(err === desiredError, 'expected #{this} to throw #{exp} but #{act} was thrown', 'expected #{this} to not throw #{exp}', desiredError instanceof Error ? desiredError.toString() : desiredError, err instanceof Error ? err.toString() : err);\n\n            flag(this, 'object', err);\n            return this;\n          }\n\n          // next, check constructor\n          if (constructor) {\n            this.assert(err instanceof constructor, 'expected #{this} to throw #{exp} but #{act} was thrown', 'expected #{this} to not throw #{exp} but #{act} was thrown', name, err instanceof Error ? err.toString() : err);\n\n            if (!errMsg) {\n              flag(this, 'object', err);\n              return this;\n            }\n          }\n\n          // next, check message\n          var message = 'object' === _.type(err) && \"message\" in err ? err.message : '' + err;\n\n          if (message != null && errMsg && errMsg instanceof RegExp) {\n            this.assert(errMsg.exec(message), 'expected #{this} to throw error matching #{exp} but got #{act}', 'expected #{this} to throw error not matching #{exp}', errMsg, message);\n\n            flag(this, 'object', err);\n            return this;\n          } else if (message != null && errMsg && 'string' === typeof errMsg) {\n            this.assert(~message.indexOf(errMsg), 'expected #{this} to throw error including #{exp} but got #{act}', 'expected #{this} to throw error not including #{act}', errMsg, message);\n\n            flag(this, 'object', err);\n            return this;\n          } else {\n            thrown = true;\n            thrownError = err;\n          }\n        }\n\n        var actuallyGot = '',\n            expectedThrown = name !== null ? name : desiredError ? '#{exp}' //_.inspect(desiredError)\n        : 'an error';\n\n        if (thrown) {\n          actuallyGot = ' but #{act} was thrown';\n        }\n\n        this.assert(thrown === true, 'expected #{this} to throw ' + expectedThrown + actuallyGot, 'expected #{this} to not throw ' + expectedThrown + actuallyGot, desiredError instanceof Error ? desiredError.toString() : desiredError, thrownError instanceof Error ? thrownError.toString() : thrownError);\n\n        flag(this, 'object', thrownError);\n      };\n\n      Assertion.addMethod('throw', assertThrows);\n      Assertion.addMethod('throws', assertThrows);\n      Assertion.addMethod('Throw', assertThrows);\n\n      /**\n       * ### .respondTo(method)\n       *\n       * Asserts that the object or class target will respond to a method.\n       *\n       *     Klass.prototype.bar = function(){};\n       *     expect(Klass).to.respondTo('bar');\n       *     expect(obj).to.respondTo('bar');\n       *\n       * To check if a constructor will respond to a static function,\n       * set the `itself` flag.\n       *\n       *     Klass.baz = function(){};\n       *     expect(Klass).itself.to.respondTo('baz');\n       *\n       * @name respondTo\n       * @param {String} method\n       * @param {String} message _optional_\n       * @api public\n       */\n\n      Assertion.addMethod('respondTo', function (method, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object'),\n            itself = flag(this, 'itself'),\n            context = 'function' === _.type(obj) && !itself ? obj.prototype[method] : obj[method];\n\n        this.assert('function' === typeof context, 'expected #{this} to respond to ' + _.inspect(method), 'expected #{this} to not respond to ' + _.inspect(method));\n      });\n\n      /**\n       * ### .itself\n       *\n       * Sets the `itself` flag, later used by the `respondTo` assertion.\n       *\n       *     function Foo() {}\n       *     Foo.bar = function() {}\n       *     Foo.prototype.baz = function() {}\n       *\n       *     expect(Foo).itself.to.respondTo('bar');\n       *     expect(Foo).itself.not.to.respondTo('baz');\n       *\n       * @name itself\n       * @api public\n       */\n\n      Assertion.addProperty('itself', function () {\n        flag(this, 'itself', true);\n      });\n\n      /**\n       * ### .satisfy(method)\n       *\n       * Asserts that the target passes a given truth test.\n       *\n       *     expect(1).to.satisfy(function(num) { return num > 0; });\n       *\n       * @name satisfy\n       * @param {Function} matcher\n       * @param {String} message _optional_\n       * @api public\n       */\n\n      Assertion.addMethod('satisfy', function (matcher, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object');\n        var result = matcher(obj);\n        this.assert(result, 'expected #{this} to satisfy ' + _.objDisplay(matcher), 'expected #{this} to not satisfy' + _.objDisplay(matcher), this.negate ? false : true, result);\n      });\n\n      /**\n       * ### .closeTo(expected, delta)\n       *\n       * Asserts that the target is equal `expected`, to within a +/- `delta` range.\n       *\n       *     expect(1.5).to.be.closeTo(1, 0.5);\n       *\n       * @name closeTo\n       * @param {Number} expected\n       * @param {Number} delta\n       * @param {String} message _optional_\n       * @api public\n       */\n\n      Assertion.addMethod('closeTo', function (expected, delta, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object');\n\n        new Assertion(obj, msg).is.a('number');\n        if (_.type(expected) !== 'number' || _.type(delta) !== 'number') {\n          throw new Error('the arguments to closeTo must be numbers');\n        }\n\n        this.assert(Math.abs(obj - expected) <= delta, 'expected #{this} to be close to ' + expected + ' +/- ' + delta, 'expected #{this} not to be close to ' + expected + ' +/- ' + delta);\n      });\n\n      function isSubsetOf(subset, superset, cmp) {\n        return subset.every(function (elem) {\n          if (!cmp) return superset.indexOf(elem) !== -1;\n\n          return superset.some(function (elem2) {\n            return cmp(elem, elem2);\n          });\n        });\n      }\n\n      /**\n       * ### .members(set)\n       *\n       * Asserts that the target is a superset of `set`,\n       * or that the target and `set` have the same strictly-equal (===) members.\n       * Alternately, if the `deep` flag is set, set members are compared for deep\n       * equality.\n       *\n       *     expect([1, 2, 3]).to.include.members([3, 2]);\n       *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);\n       *\n       *     expect([4, 2]).to.have.members([2, 4]);\n       *     expect([5, 2]).to.not.have.members([5, 2, 1]);\n       *\n       *     expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);\n       *\n       * @name members\n       * @param {Array} set\n       * @param {String} message _optional_\n       * @api public\n       */\n\n      Assertion.addMethod('members', function (subset, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object');\n\n        new Assertion(obj).to.be.an('array');\n        new Assertion(subset).to.be.an('array');\n\n        var cmp = flag(this, 'deep') ? _.eql : undefined;\n\n        if (flag(this, 'contains')) {\n          return this.assert(isSubsetOf(subset, obj, cmp), 'expected #{this} to be a superset of #{act}', 'expected #{this} to not be a superset of #{act}', obj, subset);\n        }\n\n        this.assert(isSubsetOf(obj, subset, cmp) && isSubsetOf(subset, obj, cmp), 'expected #{this} to have the same members as #{act}', 'expected #{this} to not have the same members as #{act}', obj, subset);\n      });\n\n      /**\n       * ### .change(function)\n       *\n       * Asserts that a function changes an object property\n       *\n       *     var obj = { val: 10 };\n       *     var fn = function() { obj.val += 3 };\n       *     var noChangeFn = function() { return 'foo' + 'bar'; }\n       *     expect(fn).to.change(obj, 'val');\n       *     expect(noChangFn).to.not.change(obj, 'val')\n       *\n       * @name change\n       * @alias changes\n       * @alias Change\n       * @param {String} object\n       * @param {String} property name\n       * @param {String} message _optional_\n       * @api public\n       */\n\n      function assertChanges(object, prop, msg) {\n        if (msg) flag(this, 'message', msg);\n        var fn = flag(this, 'object');\n        new Assertion(object, msg).to.have.property(prop);\n        new Assertion(fn).is.a('function');\n\n        var initial = object[prop];\n        fn();\n\n        this.assert(initial !== object[prop], 'expected .' + prop + ' to change', 'expected .' + prop + ' to not change');\n      }\n\n      Assertion.addChainableMethod('change', assertChanges);\n      Assertion.addChainableMethod('changes', assertChanges);\n\n      /**\n       * ### .increase(function)\n       *\n       * Asserts that a function increases an object property\n       *\n       *     var obj = { val: 10 };\n       *     var fn = function() { obj.val = 15 };\n       *     expect(fn).to.increase(obj, 'val');\n       *\n       * @name increase\n       * @alias increases\n       * @alias Increase\n       * @param {String} object\n       * @param {String} property name\n       * @param {String} message _optional_\n       * @api public\n       */\n\n      function assertIncreases(object, prop, msg) {\n        if (msg) flag(this, 'message', msg);\n        var fn = flag(this, 'object');\n        new Assertion(object, msg).to.have.property(prop);\n        new Assertion(fn).is.a('function');\n\n        var initial = object[prop];\n        fn();\n\n        this.assert(object[prop] - initial > 0, 'expected .' + prop + ' to increase', 'expected .' + prop + ' to not increase');\n      }\n\n      Assertion.addChainableMethod('increase', assertIncreases);\n      Assertion.addChainableMethod('increases', assertIncreases);\n\n      /**\n       * ### .decrease(function)\n       *\n       * Asserts that a function decreases an object property\n       *\n       *     var obj = { val: 10 };\n       *     var fn = function() { obj.val = 5 };\n       *     expect(fn).to.decrease(obj, 'val');\n       *\n       * @name decrease\n       * @alias decreases\n       * @alias Decrease\n       * @param {String} object\n       * @param {String} property name\n       * @param {String} message _optional_\n       * @api public\n       */\n\n      function assertDecreases(object, prop, msg) {\n        if (msg) flag(this, 'message', msg);\n        var fn = flag(this, 'object');\n        new Assertion(object, msg).to.have.property(prop);\n        new Assertion(fn).is.a('function');\n\n        var initial = object[prop];\n        fn();\n\n        this.assert(object[prop] - initial < 0, 'expected .' + prop + ' to decrease', 'expected .' + prop + ' to not decrease');\n      }\n\n      Assertion.addChainableMethod('decrease', assertDecreases);\n      Assertion.addChainableMethod('decreases', assertDecreases);\n    };\n  });\n\n  require.register(\"chai/lib/chai/interface/assert.js\", function (exports, module) {\n    /*!\n     * chai\n     * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */\n\n    module.exports = function (chai, util) {\n\n      /*!\n       * Chai dependencies.\n       */\n\n      var Assertion = chai.Assertion,\n          flag = util.flag;\n\n      /*!\n       * Module export.\n       */\n\n      /**\n       * ### assert(expression, message)\n       *\n       * Write your own test expressions.\n       *\n       *     assert('foo' !== 'bar', 'foo is not bar');\n       *     assert(Array.isArray([]), 'empty arrays are arrays');\n       *\n       * @param {Mixed} expression to test for truthiness\n       * @param {String} message to display on error\n       * @name assert\n       * @api public\n       */\n\n      var assert = chai.assert = function (express, errmsg) {\n        var test = new Assertion(null, null, chai.assert);\n        test.assert(express, errmsg, '[ negation message unavailable ]');\n      };\n\n      /**\n       * ### .fail(actual, expected, [message], [operator])\n       *\n       * Throw a failure. Node.js `assert` module-compatible.\n       *\n       * @name fail\n       * @param {Mixed} actual\n       * @param {Mixed} expected\n       * @param {String} message\n       * @param {String} operator\n       * @api public\n       */\n\n      assert.fail = function (actual, expected, message, operator) {\n        message = message || 'assert.fail()';\n        throw new chai.AssertionError(message, {\n          actual: actual,\n          expected: expected,\n          operator: operator\n        }, assert.fail);\n      };\n\n      /**\n       * ### .ok(object, [message])\n       *\n       * Asserts that `object` is truthy.\n       *\n       *     assert.ok('everything', 'everything is ok');\n       *     assert.ok(false, 'this will fail');\n       *\n       * @name ok\n       * @param {Mixed} object to test\n       * @param {String} message\n       * @api public\n       */\n\n      assert.ok = function (val, msg) {\n        new Assertion(val, msg).is.ok;\n      };\n\n      /**\n       * ### .notOk(object, [message])\n       *\n       * Asserts that `object` is falsy.\n       *\n       *     assert.notOk('everything', 'this will fail');\n       *     assert.notOk(false, 'this will pass');\n       *\n       * @name notOk\n       * @param {Mixed} object to test\n       * @param {String} message\n       * @api public\n       */\n\n      assert.notOk = function (val, msg) {\n        new Assertion(val, msg).is.not.ok;\n      };\n\n      /**\n       * ### .equal(actual, expected, [message])\n       *\n       * Asserts non-strict equality (`==`) of `actual` and `expected`.\n       *\n       *     assert.equal(3, '3', '== coerces values to strings');\n       *\n       * @name equal\n       * @param {Mixed} actual\n       * @param {Mixed} expected\n       * @param {String} message\n       * @api public\n       */\n\n      assert.equal = function (act, exp, msg) {\n        var test = new Assertion(act, msg, assert.equal);\n\n        test.assert(exp == flag(test, 'object'), 'expected #{this} to equal #{exp}', 'expected #{this} to not equal #{act}', exp, act);\n      };\n\n      /**\n       * ### .notEqual(actual, expected, [message])\n       *\n       * Asserts non-strict inequality (`!=`) of `actual` and `expected`.\n       *\n       *     assert.notEqual(3, 4, 'these numbers are not equal');\n       *\n       * @name notEqual\n       * @param {Mixed} actual\n       * @param {Mixed} expected\n       * @param {String} message\n       * @api public\n       */\n\n      assert.notEqual = function (act, exp, msg) {\n        var test = new Assertion(act, msg, assert.notEqual);\n\n        test.assert(exp != flag(test, 'object'), 'expected #{this} to not equal #{exp}', 'expected #{this} to equal #{act}', exp, act);\n      };\n\n      /**\n       * ### .strictEqual(actual, expected, [message])\n       *\n       * Asserts strict equality (`===`) of `actual` and `expected`.\n       *\n       *     assert.strictEqual(true, true, 'these booleans are strictly equal');\n       *\n       * @name strictEqual\n       * @param {Mixed} actual\n       * @param {Mixed} expected\n       * @param {String} message\n       * @api public\n       */\n\n      assert.strictEqual = function (act, exp, msg) {\n        new Assertion(act, msg).to.equal(exp);\n      };\n\n      /**\n       * ### .notStrictEqual(actual, expected, [message])\n       *\n       * Asserts strict inequality (`!==`) of `actual` and `expected`.\n       *\n       *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');\n       *\n       * @name notStrictEqual\n       * @param {Mixed} actual\n       * @param {Mixed} expected\n       * @param {String} message\n       * @api public\n       */\n\n      assert.notStrictEqual = function (act, exp, msg) {\n        new Assertion(act, msg).to.not.equal(exp);\n      };\n\n      /**\n       * ### .deepEqual(actual, expected, [message])\n       *\n       * Asserts that `actual` is deeply equal to `expected`.\n       *\n       *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });\n       *\n       * @name deepEqual\n       * @param {Mixed} actual\n       * @param {Mixed} expected\n       * @param {String} message\n       * @api public\n       */\n\n      assert.deepEqual = function (act, exp, msg) {\n        new Assertion(act, msg).to.eql(exp);\n      };\n\n      /**\n       * ### .notDeepEqual(actual, expected, [message])\n       *\n       * Assert that `actual` is not deeply equal to `expected`.\n       *\n       *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });\n       *\n       * @name notDeepEqual\n       * @param {Mixed} actual\n       * @param {Mixed} expected\n       * @param {String} message\n       * @api public\n       */\n\n      assert.notDeepEqual = function (act, exp, msg) {\n        new Assertion(act, msg).to.not.eql(exp);\n      };\n\n      /**\n       * ### .isTrue(value, [message])\n       *\n       * Asserts that `value` is true.\n       *\n       *     var teaServed = true;\n       *     assert.isTrue(teaServed, 'the tea has been served');\n       *\n       * @name isTrue\n       * @param {Mixed} value\n       * @param {String} message\n       * @api public\n       */\n\n      assert.isAbove = function (val, abv, msg) {\n        new Assertion(val, msg).to.be.above(abv);\n      };\n\n      /**\n      * ### .isAbove(valueToCheck, valueToBeAbove, [message])\n      *\n      * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`\n      *\n      *     assert.isAbove(5, 2, '5 is strictly greater than 2');\n      *\n      * @name isAbove\n      * @param {Mixed} valueToCheck\n      * @param {Mixed} valueToBeAbove\n      * @param {String} message\n      * @api public\n      */\n\n      assert.isBelow = function (val, blw, msg) {\n        new Assertion(val, msg).to.be.below(blw);\n      };\n\n      /**\n      * ### .isBelow(valueToCheck, valueToBeBelow, [message])\n      *\n      * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`\n      *\n      *     assert.isBelow(3, 6, '3 is strictly less than 6');\n      *\n      * @name isBelow\n      * @param {Mixed} valueToCheck\n      * @param {Mixed} valueToBeBelow\n      * @param {String} message\n      * @api public\n      */\n\n      assert.isTrue = function (val, msg) {\n        new Assertion(val, msg).is['true'];\n      };\n\n      /**\n       * ### .isFalse(value, [message])\n       *\n       * Asserts that `value` is false.\n       *\n       *     var teaServed = false;\n       *     assert.isFalse(teaServed, 'no tea yet? hmm...');\n       *\n       * @name isFalse\n       * @param {Mixed} value\n       * @param {String} message\n       * @api public\n       */\n\n      assert.isFalse = function (val, msg) {\n        new Assertion(val, msg).is['false'];\n      };\n\n      /**\n       * ### .isNull(value, [message])\n       *\n       * Asserts that `value` is null.\n       *\n       *     assert.isNull(err, 'there was no error');\n       *\n       * @name isNull\n       * @param {Mixed} value\n       * @param {String} message\n       * @api public\n       */\n\n      assert.isNull = function (val, msg) {\n        new Assertion(val, msg).to.equal(null);\n      };\n\n      /**\n       * ### .isNotNull(value, [message])\n       *\n       * Asserts that `value` is not null.\n       *\n       *     var tea = 'tasty chai';\n       *     assert.isNotNull(tea, 'great, time for tea!');\n       *\n       * @name isNotNull\n       * @param {Mixed} value\n       * @param {String} message\n       * @api public\n       */\n\n      assert.isNotNull = function (val, msg) {\n        new Assertion(val, msg).to.not.equal(null);\n      };\n\n      /**\n       * ### .isUndefined(value, [message])\n       *\n       * Asserts that `value` is `undefined`.\n       *\n       *     var tea;\n       *     assert.isUndefined(tea, 'no tea defined');\n       *\n       * @name isUndefined\n       * @param {Mixed} value\n       * @param {String} message\n       * @api public\n       */\n\n      assert.isUndefined = function (val, msg) {\n        new Assertion(val, msg).to.equal(undefined);\n      };\n\n      /**\n       * ### .isDefined(value, [message])\n       *\n       * Asserts that `value` is not `undefined`.\n       *\n       *     var tea = 'cup of chai';\n       *     assert.isDefined(tea, 'tea has been defined');\n       *\n       * @name isDefined\n       * @param {Mixed} value\n       * @param {String} message\n       * @api public\n       */\n\n      assert.isDefined = function (val, msg) {\n        new Assertion(val, msg).to.not.equal(undefined);\n      };\n\n      /**\n       * ### .isFunction(value, [message])\n       *\n       * Asserts that `value` is a function.\n       *\n       *     function serveTea() { return 'cup of tea'; };\n       *     assert.isFunction(serveTea, 'great, we can have tea now');\n       *\n       * @name isFunction\n       * @param {Mixed} value\n       * @param {String} message\n       * @api public\n       */\n\n      assert.isFunction = function (val, msg) {\n        new Assertion(val, msg).to.be.a('function');\n      };\n\n      /**\n       * ### .isNotFunction(value, [message])\n       *\n       * Asserts that `value` is _not_ a function.\n       *\n       *     var serveTea = [ 'heat', 'pour', 'sip' ];\n       *     assert.isNotFunction(serveTea, 'great, we have listed the steps');\n       *\n       * @name isNotFunction\n       * @param {Mixed} value\n       * @param {String} message\n       * @api public\n       */\n\n      assert.isNotFunction = function (val, msg) {\n        new Assertion(val, msg).to.not.be.a('function');\n      };\n\n      /**\n       * ### .isObject(value, [message])\n       *\n       * Asserts that `value` is an object (as revealed by\n       * `Object.prototype.toString`).\n       *\n       *     var selection = { name: 'Chai', serve: 'with spices' };\n       *     assert.isObject(selection, 'tea selection is an object');\n       *\n       * @name isObject\n       * @param {Mixed} value\n       * @param {String} message\n       * @api public\n       */\n\n      assert.isObject = function (val, msg) {\n        new Assertion(val, msg).to.be.a('object');\n      };\n\n      /**\n       * ### .isNotObject(value, [message])\n       *\n       * Asserts that `value` is _not_ an object.\n       *\n       *     var selection = 'chai'\n       *     assert.isNotObject(selection, 'tea selection is not an object');\n       *     assert.isNotObject(null, 'null is not an object');\n       *\n       * @name isNotObject\n       * @param {Mixed} value\n       * @param {String} message\n       * @api public\n       */\n\n      assert.isNotObject = function (val, msg) {\n        new Assertion(val, msg).to.not.be.a('object');\n      };\n\n      /**\n       * ### .isArray(value, [message])\n       *\n       * Asserts that `value` is an array.\n       *\n       *     var menu = [ 'green', 'chai', 'oolong' ];\n       *     assert.isArray(menu, 'what kind of tea do we want?');\n       *\n       * @name isArray\n       * @param {Mixed} value\n       * @param {String} message\n       * @api public\n       */\n\n      assert.isArray = function (val, msg) {\n        new Assertion(val, msg).to.be.an('array');\n      };\n\n      /**\n       * ### .isNotArray(value, [message])\n       *\n       * Asserts that `value` is _not_ an array.\n       *\n       *     var menu = 'green|chai|oolong';\n       *     assert.isNotArray(menu, 'what kind of tea do we want?');\n       *\n       * @name isNotArray\n       * @param {Mixed} value\n       * @param {String} message\n       * @api public\n       */\n\n      assert.isNotArray = function (val, msg) {\n        new Assertion(val, msg).to.not.be.an('array');\n      };\n\n      /**\n       * ### .isString(value, [message])\n       *\n       * Asserts that `value` is a string.\n       *\n       *     var teaOrder = 'chai';\n       *     assert.isString(teaOrder, 'order placed');\n       *\n       * @name isString\n       * @param {Mixed} value\n       * @param {String} message\n       * @api public\n       */\n\n      assert.isString = function (val, msg) {\n        new Assertion(val, msg).to.be.a('string');\n      };\n\n      /**\n       * ### .isNotString(value, [message])\n       *\n       * Asserts that `value` is _not_ a string.\n       *\n       *     var teaOrder = 4;\n       *     assert.isNotString(teaOrder, 'order placed');\n       *\n       * @name isNotString\n       * @param {Mixed} value\n       * @param {String} message\n       * @api public\n       */\n\n      assert.isNotString = function (val, msg) {\n        new Assertion(val, msg).to.not.be.a('string');\n      };\n\n      /**\n       * ### .isNumber(value, [message])\n       *\n       * Asserts that `value` is a number.\n       *\n       *     var cups = 2;\n       *     assert.isNumber(cups, 'how many cups');\n       *\n       * @name isNumber\n       * @param {Number} value\n       * @param {String} message\n       * @api public\n       */\n\n      assert.isNumber = function (val, msg) {\n        new Assertion(val, msg).to.be.a('number');\n      };\n\n      /**\n       * ### .isNotNumber(value, [message])\n       *\n       * Asserts that `value` is _not_ a number.\n       *\n       *     var cups = '2 cups please';\n       *     assert.isNotNumber(cups, 'how many cups');\n       *\n       * @name isNotNumber\n       * @param {Mixed} value\n       * @param {String} message\n       * @api public\n       */\n\n      assert.isNotNumber = function (val, msg) {\n        new Assertion(val, msg).to.not.be.a('number');\n      };\n\n      /**\n       * ### .isBoolean(value, [message])\n       *\n       * Asserts that `value` is a boolean.\n       *\n       *     var teaReady = true\n       *       , teaServed = false;\n       *\n       *     assert.isBoolean(teaReady, 'is the tea ready');\n       *     assert.isBoolean(teaServed, 'has tea been served');\n       *\n       * @name isBoolean\n       * @param {Mixed} value\n       * @param {String} message\n       * @api public\n       */\n\n      assert.isBoolean = function (val, msg) {\n        new Assertion(val, msg).to.be.a('boolean');\n      };\n\n      /**\n       * ### .isNotBoolean(value, [message])\n       *\n       * Asserts that `value` is _not_ a boolean.\n       *\n       *     var teaReady = 'yep'\n       *       , teaServed = 'nope';\n       *\n       *     assert.isNotBoolean(teaReady, 'is the tea ready');\n       *     assert.isNotBoolean(teaServed, 'has tea been served');\n       *\n       * @name isNotBoolean\n       * @param {Mixed} value\n       * @param {String} message\n       * @api public\n       */\n\n      assert.isNotBoolean = function (val, msg) {\n        new Assertion(val, msg).to.not.be.a('boolean');\n      };\n\n      /**\n       * ### .typeOf(value, name, [message])\n       *\n       * Asserts that `value`'s type is `name`, as determined by\n       * `Object.prototype.toString`.\n       *\n       *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');\n       *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');\n       *     assert.typeOf('tea', 'string', 'we have a string');\n       *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');\n       *     assert.typeOf(null, 'null', 'we have a null');\n       *     assert.typeOf(undefined, 'undefined', 'we have an undefined');\n       *\n       * @name typeOf\n       * @param {Mixed} value\n       * @param {String} name\n       * @param {String} message\n       * @api public\n       */\n\n      assert.typeOf = function (val, type, msg) {\n        new Assertion(val, msg).to.be.a(type);\n      };\n\n      /**\n       * ### .notTypeOf(value, name, [message])\n       *\n       * Asserts that `value`'s type is _not_ `name`, as determined by\n       * `Object.prototype.toString`.\n       *\n       *     assert.notTypeOf('tea', 'number', 'strings are not numbers');\n       *\n       * @name notTypeOf\n       * @param {Mixed} value\n       * @param {String} typeof name\n       * @param {String} message\n       * @api public\n       */\n\n      assert.notTypeOf = function (val, type, msg) {\n        new Assertion(val, msg).to.not.be.a(type);\n      };\n\n      /**\n       * ### .instanceOf(object, constructor, [message])\n       *\n       * Asserts that `value` is an instance of `constructor`.\n       *\n       *     var Tea = function (name) { this.name = name; }\n       *       , chai = new Tea('chai');\n       *\n       *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');\n       *\n       * @name instanceOf\n       * @param {Object} object\n       * @param {Constructor} constructor\n       * @param {String} message\n       * @api public\n       */\n\n      assert.instanceOf = function (val, type, msg) {\n        new Assertion(val, msg).to.be.instanceOf(type);\n      };\n\n      /**\n       * ### .notInstanceOf(object, constructor, [message])\n       *\n       * Asserts `value` is not an instance of `constructor`.\n       *\n       *     var Tea = function (name) { this.name = name; }\n       *       , chai = new String('chai');\n       *\n       *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');\n       *\n       * @name notInstanceOf\n       * @param {Object} object\n       * @param {Constructor} constructor\n       * @param {String} message\n       * @api public\n       */\n\n      assert.notInstanceOf = function (val, type, msg) {\n        new Assertion(val, msg).to.not.be.instanceOf(type);\n      };\n\n      /**\n       * ### .include(haystack, needle, [message])\n       *\n       * Asserts that `haystack` includes `needle`. Works\n       * for strings and arrays.\n       *\n       *     assert.include('foobar', 'bar', 'foobar contains string \"bar\"');\n       *     assert.include([ 1, 2, 3 ], 3, 'array contains value');\n       *\n       * @name include\n       * @param {Array|String} haystack\n       * @param {Mixed} needle\n       * @param {String} message\n       * @api public\n       */\n\n      assert.include = function (exp, inc, msg) {\n        new Assertion(exp, msg, assert.include).include(inc);\n      };\n\n      /**\n       * ### .notInclude(haystack, needle, [message])\n       *\n       * Asserts that `haystack` does not include `needle`. Works\n       * for strings and arrays.\n       *i\n       *     assert.notInclude('foobar', 'baz', 'string not include substring');\n       *     assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');\n       *\n       * @name notInclude\n       * @param {Array|String} haystack\n       * @param {Mixed} needle\n       * @param {String} message\n       * @api public\n       */\n\n      assert.notInclude = function (exp, inc, msg) {\n        new Assertion(exp, msg, assert.notInclude).not.include(inc);\n      };\n\n      /**\n       * ### .match(value, regexp, [message])\n       *\n       * Asserts that `value` matches the regular expression `regexp`.\n       *\n       *     assert.match('foobar', /^foo/, 'regexp matches');\n       *\n       * @name match\n       * @param {Mixed} value\n       * @param {RegExp} regexp\n       * @param {String} message\n       * @api public\n       */\n\n      assert.match = function (exp, re, msg) {\n        new Assertion(exp, msg).to.match(re);\n      };\n\n      /**\n       * ### .notMatch(value, regexp, [message])\n       *\n       * Asserts that `value` does not match the regular expression `regexp`.\n       *\n       *     assert.notMatch('foobar', /^foo/, 'regexp does not match');\n       *\n       * @name notMatch\n       * @param {Mixed} value\n       * @param {RegExp} regexp\n       * @param {String} message\n       * @api public\n       */\n\n      assert.notMatch = function (exp, re, msg) {\n        new Assertion(exp, msg).to.not.match(re);\n      };\n\n      /**\n       * ### .property(object, property, [message])\n       *\n       * Asserts that `object` has a property named by `property`.\n       *\n       *     assert.property({ tea: { green: 'matcha' }}, 'tea');\n       *\n       * @name property\n       * @param {Object} object\n       * @param {String} property\n       * @param {String} message\n       * @api public\n       */\n\n      assert.property = function (obj, prop, msg) {\n        new Assertion(obj, msg).to.have.property(prop);\n      };\n\n      /**\n       * ### .notProperty(object, property, [message])\n       *\n       * Asserts that `object` does _not_ have a property named by `property`.\n       *\n       *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');\n       *\n       * @name notProperty\n       * @param {Object} object\n       * @param {String} property\n       * @param {String} message\n       * @api public\n       */\n\n      assert.notProperty = function (obj, prop, msg) {\n        new Assertion(obj, msg).to.not.have.property(prop);\n      };\n\n      /**\n       * ### .deepProperty(object, property, [message])\n       *\n       * Asserts that `object` has a property named by `property`, which can be a\n       * string using dot- and bracket-notation for deep reference.\n       *\n       *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');\n       *\n       * @name deepProperty\n       * @param {Object} object\n       * @param {String} property\n       * @param {String} message\n       * @api public\n       */\n\n      assert.deepProperty = function (obj, prop, msg) {\n        new Assertion(obj, msg).to.have.deep.property(prop);\n      };\n\n      /**\n       * ### .notDeepProperty(object, property, [message])\n       *\n       * Asserts that `object` does _not_ have a property named by `property`, which\n       * can be a string using dot- and bracket-notation for deep reference.\n       *\n       *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');\n       *\n       * @name notDeepProperty\n       * @param {Object} object\n       * @param {String} property\n       * @param {String} message\n       * @api public\n       */\n\n      assert.notDeepProperty = function (obj, prop, msg) {\n        new Assertion(obj, msg).to.not.have.deep.property(prop);\n      };\n\n      /**\n       * ### .propertyVal(object, property, value, [message])\n       *\n       * Asserts that `object` has a property named by `property` with value given\n       * by `value`.\n       *\n       *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');\n       *\n       * @name propertyVal\n       * @param {Object} object\n       * @param {String} property\n       * @param {Mixed} value\n       * @param {String} message\n       * @api public\n       */\n\n      assert.propertyVal = function (obj, prop, val, msg) {\n        new Assertion(obj, msg).to.have.property(prop, val);\n      };\n\n      /**\n       * ### .propertyNotVal(object, property, value, [message])\n       *\n       * Asserts that `object` has a property named by `property`, but with a value\n       * different from that given by `value`.\n       *\n       *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');\n       *\n       * @name propertyNotVal\n       * @param {Object} object\n       * @param {String} property\n       * @param {Mixed} value\n       * @param {String} message\n       * @api public\n       */\n\n      assert.propertyNotVal = function (obj, prop, val, msg) {\n        new Assertion(obj, msg).to.not.have.property(prop, val);\n      };\n\n      /**\n       * ### .deepPropertyVal(object, property, value, [message])\n       *\n       * Asserts that `object` has a property named by `property` with value given\n       * by `value`. `property` can use dot- and bracket-notation for deep\n       * reference.\n       *\n       *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');\n       *\n       * @name deepPropertyVal\n       * @param {Object} object\n       * @param {String} property\n       * @param {Mixed} value\n       * @param {String} message\n       * @api public\n       */\n\n      assert.deepPropertyVal = function (obj, prop, val, msg) {\n        new Assertion(obj, msg).to.have.deep.property(prop, val);\n      };\n\n      /**\n       * ### .deepPropertyNotVal(object, property, value, [message])\n       *\n       * Asserts that `object` has a property named by `property`, but with a value\n       * different from that given by `value`. `property` can use dot- and\n       * bracket-notation for deep reference.\n       *\n       *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');\n       *\n       * @name deepPropertyNotVal\n       * @param {Object} object\n       * @param {String} property\n       * @param {Mixed} value\n       * @param {String} message\n       * @api public\n       */\n\n      assert.deepPropertyNotVal = function (obj, prop, val, msg) {\n        new Assertion(obj, msg).to.not.have.deep.property(prop, val);\n      };\n\n      /**\n       * ### .lengthOf(object, length, [message])\n       *\n       * Asserts that `object` has a `length` property with the expected value.\n       *\n       *     assert.lengthOf([1,2,3], 3, 'array has length of 3');\n       *     assert.lengthOf('foobar', 5, 'string has length of 6');\n       *\n       * @name lengthOf\n       * @param {Mixed} object\n       * @param {Number} length\n       * @param {String} message\n       * @api public\n       */\n\n      assert.lengthOf = function (exp, len, msg) {\n        new Assertion(exp, msg).to.have.length(len);\n      };\n\n      /**\n       * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])\n       *\n       * Asserts that `function` will throw an error that is an instance of\n       * `constructor`, or alternately that it will throw an error with message\n       * matching `regexp`.\n       *\n       *     assert.throw(fn, 'function throws a reference error');\n       *     assert.throw(fn, /function throws a reference error/);\n       *     assert.throw(fn, ReferenceError);\n       *     assert.throw(fn, ReferenceError, 'function throws a reference error');\n       *     assert.throw(fn, ReferenceError, /function throws a reference error/);\n       *\n       * @name throws\n       * @alias throw\n       * @alias Throw\n       * @param {Function} function\n       * @param {ErrorConstructor} constructor\n       * @param {RegExp} regexp\n       * @param {String} message\n       * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n       * @api public\n       */\n\n      assert.Throw = function (fn, errt, errs, msg) {\n        if ('string' === typeof errt || errt instanceof RegExp) {\n          errs = errt;\n          errt = null;\n        }\n\n        var assertErr = new Assertion(fn, msg).to.Throw(errt, errs);\n        return flag(assertErr, 'object');\n      };\n\n      /**\n       * ### .doesNotThrow(function, [constructor/regexp], [message])\n       *\n       * Asserts that `function` will _not_ throw an error that is an instance of\n       * `constructor`, or alternately that it will not throw an error with message\n       * matching `regexp`.\n       *\n       *     assert.doesNotThrow(fn, Error, 'function does not throw');\n       *\n       * @name doesNotThrow\n       * @param {Function} function\n       * @param {ErrorConstructor} constructor\n       * @param {RegExp} regexp\n       * @param {String} message\n       * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n       * @api public\n       */\n\n      assert.doesNotThrow = function (fn, type, msg) {\n        if ('string' === typeof type) {\n          msg = type;\n          type = null;\n        }\n\n        new Assertion(fn, msg).to.not.Throw(type);\n      };\n\n      /**\n       * ### .operator(val1, operator, val2, [message])\n       *\n       * Compares two values using `operator`.\n       *\n       *     assert.operator(1, '<', 2, 'everything is ok');\n       *     assert.operator(1, '>', 2, 'this will fail');\n       *\n       * @name operator\n       * @param {Mixed} val1\n       * @param {String} operator\n       * @param {Mixed} val2\n       * @param {String} message\n       * @api public\n       */\n\n      assert.operator = function (val, operator, val2, msg) {\n        if (!~['==', '===', '>', '>=', '<', '<=', '!=', '!=='].indexOf(operator)) {\n          throw new Error('Invalid operator \"' + operator + '\"');\n        }\n        var test = new Assertion(module.runModuleSetters(eval(val + operator + val2)), msg);\n        test.assert(true === flag(test, 'object'), 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2), 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2));\n      };\n\n      /**\n       * ### .closeTo(actual, expected, delta, [message])\n       *\n       * Asserts that the target is equal `expected`, to within a +/- `delta` range.\n       *\n       *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');\n       *\n       * @name closeTo\n       * @param {Number} actual\n       * @param {Number} expected\n       * @param {Number} delta\n       * @param {String} message\n       * @api public\n       */\n\n      assert.closeTo = function (act, exp, delta, msg) {\n        new Assertion(act, msg).to.be.closeTo(exp, delta);\n      };\n\n      /**\n       * ### .sameMembers(set1, set2, [message])\n       *\n       * Asserts that `set1` and `set2` have the same members.\n       * Order is not taken into account.\n       *\n       *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');\n       *\n       * @name sameMembers\n       * @param {Array} set1\n       * @param {Array} set2\n       * @param {String} message\n       * @api public\n       */\n\n      assert.sameMembers = function (set1, set2, msg) {\n        new Assertion(set1, msg).to.have.same.members(set2);\n      };\n\n      /**\n       * ### .sameDeepMembers(set1, set2, [message])\n       *\n       * Asserts that `set1` and `set2` have the same members - using a deep equality checking.\n       * Order is not taken into account.\n       *\n       *     assert.sameDeepMembers([ {b: 3}, {a: 2}, {c: 5} ], [ {c: 5}, {b: 3}, {a: 2} ], 'same deep members');\n       *\n       * @name sameDeepMembers\n       * @param {Array} set1\n       * @param {Array} set2\n       * @param {String} message\n       * @api public\n       */\n\n      assert.sameDeepMembers = function (set1, set2, msg) {\n        new Assertion(set1, msg).to.have.same.deep.members(set2);\n      };\n\n      /**\n       * ### .includeMembers(superset, subset, [message])\n       *\n       * Asserts that `subset` is included in `superset`.\n       * Order is not taken into account.\n       *\n       *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');\n       *\n       * @name includeMembers\n       * @param {Array} superset\n       * @param {Array} subset\n       * @param {String} message\n       * @api public\n       */\n\n      assert.includeMembers = function (superset, subset, msg) {\n        new Assertion(superset, msg).to.include.members(subset);\n      };\n\n      /**\n      * ### .changes(function, object, property)\n      *\n      * Asserts that a function changes the value of a property\n      *\n      *     var obj = { val: 10 };\n      *     var fn = function() { obj.val = 22 };\n      *     assert.changes(fn, obj, 'val');\n      *\n      * @name changes\n      * @param {Function} modifier function\n      * @param {Object} object\n      * @param {String} property name\n      * @param {String} message _optional_\n      * @api public\n      */\n\n      assert.changes = function (fn, obj, prop) {\n        new Assertion(fn).to.change(obj, prop);\n      };\n\n      /**\n      * ### .doesNotChange(function, object, property)\n      *\n      * Asserts that a function does not changes the value of a property\n      *\n      *     var obj = { val: 10 };\n      *     var fn = function() { console.log('foo'); };\n      *     assert.doesNotChange(fn, obj, 'val');\n      *\n      * @name doesNotChange\n      * @param {Function} modifier function\n      * @param {Object} object\n      * @param {String} property name\n      * @param {String} message _optional_\n      * @api public\n      */\n\n      assert.doesNotChange = function (fn, obj, prop) {\n        new Assertion(fn).to.not.change(obj, prop);\n      };\n\n      /**\n      * ### .increases(function, object, property)\n      *\n      * Asserts that a function increases an object property\n      *\n      *     var obj = { val: 10 };\n      *     var fn = function() { obj.val = 13 };\n      *     assert.increases(fn, obj, 'val');\n      *\n      * @name increases\n      * @param {Function} modifier function\n      * @param {Object} object\n      * @param {String} property name\n      * @param {String} message _optional_\n      * @api public\n      */\n\n      assert.increases = function (fn, obj, prop) {\n        new Assertion(fn).to.increase(obj, prop);\n      };\n\n      /**\n      * ### .doesNotIncrease(function, object, property)\n      *\n      * Asserts that a function does not increase object property\n      *\n      *     var obj = { val: 10 };\n      *     var fn = function() { obj.val = 8 };\n      *     assert.doesNotIncrease(fn, obj, 'val');\n      *\n      * @name doesNotIncrease\n      * @param {Function} modifier function\n      * @param {Object} object\n      * @param {String} property name\n      * @param {String} message _optional_\n      * @api public\n      */\n\n      assert.doesNotIncrease = function (fn, obj, prop) {\n        new Assertion(fn).to.not.increase(obj, prop);\n      };\n\n      /**\n      * ### .decreases(function, object, property)\n      *\n      * Asserts that a function decreases an object property\n      *\n      *     var obj = { val: 10 };\n      *     var fn = function() { obj.val = 5 };\n      *     assert.decreases(fn, obj, 'val');\n      *\n      * @name decreases\n      * @param {Function} modifier function\n      * @param {Object} object\n      * @param {String} property name\n      * @param {String} message _optional_\n      * @api public\n      */\n\n      assert.decreases = function (fn, obj, prop) {\n        new Assertion(fn).to.decrease(obj, prop);\n      };\n\n      /**\n      * ### .doesNotDecrease(function, object, property)\n      *\n      * Asserts that a function does not decreases an object property\n      *\n      *     var obj = { val: 10 };\n      *     var fn = function() { obj.val = 15 };\n      *     assert.doesNotDecrease(fn, obj, 'val');\n      *\n      * @name doesNotDecrease\n      * @param {Function} modifier function\n      * @param {Object} object\n      * @param {String} property name\n      * @param {String} message _optional_\n      * @api public\n      */\n\n      assert.doesNotDecrease = function (fn, obj, prop) {\n        new Assertion(fn).to.not.decrease(obj, prop);\n      };\n\n      /*!\n       * Undocumented / untested\n       */\n\n      assert.ifError = function (val, msg) {\n        new Assertion(val, msg).to.not.be.ok;\n      };\n\n      /*!\n       * Aliases.\n       */\n\n      (function alias(name, as) {\n        assert[as] = assert[name];\n        return alias;\n      })('Throw', 'throw')('Throw', 'throws');\n    };\n  });\n\n  require.register(\"chai/lib/chai/interface/expect.js\", function (exports, module) {\n    /*!\n     * chai\n     * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */\n\n    module.exports = function (chai, util) {\n      chai.expect = function (val, message) {\n        return new chai.Assertion(val, message);\n      };\n\n      /**\n       * ### .fail(actual, expected, [message], [operator])\n       *\n       * Throw a failure.\n       *\n       * @name fail\n       * @param {Mixed} actual\n       * @param {Mixed} expected\n       * @param {String} message\n       * @param {String} operator\n       * @api public\n       */\n\n      chai.expect.fail = function (actual, expected, message, operator) {\n        message = message || 'expect.fail()';\n        throw new chai.AssertionError(message, {\n          actual: actual,\n          expected: expected,\n          operator: operator\n        }, chai.expect.fail);\n      };\n    };\n  });\n\n  require.register(\"chai/lib/chai/interface/should.js\", function (exports, module) {\n    /*!\n     * chai\n     * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */\n\n    module.exports = function (chai, util) {\n      var Assertion = chai.Assertion;\n\n      function loadShould() {\n        // explicitly define this method as function as to have it's name to include as `ssfi`\n        function shouldGetter() {\n          if (this instanceof String || this instanceof Number) {\n            return new Assertion(this.constructor(this), null, shouldGetter);\n          } else if (this instanceof Boolean) {\n            return new Assertion(this == true, null, shouldGetter);\n          }\n          return new Assertion(this, null, shouldGetter);\n        }\n        function shouldSetter(value) {\n          // See https://github.com/chaijs/chai/issues/86: this makes\n          // `whatever.should = someValue` actually set `someValue`, which is\n          // especially useful for `global.should = require('chai').should()`.\n          //\n          // Note that we have to use [[DefineProperty]] instead of [[Put]]\n          // since otherwise we would trigger this very setter!\n          Object.defineProperty(this, 'should', {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n          });\n        }\n        // modify Object.prototype to have `should`\n        Object.defineProperty(Object.prototype, 'should', {\n          set: shouldSetter,\n          get: shouldGetter,\n          configurable: true\n        });\n\n        var should = {};\n\n        /**\n         * ### .fail(actual, expected, [message], [operator])\n         *\n         * Throw a failure.\n         *\n         * @name fail\n         * @param {Mixed} actual\n         * @param {Mixed} expected\n         * @param {String} message\n         * @param {String} operator\n         * @api public\n         */\n\n        should.fail = function (actual, expected, message, operator) {\n          message = message || 'should.fail()';\n          throw new chai.AssertionError(message, {\n            actual: actual,\n            expected: expected,\n            operator: operator\n          }, should.fail);\n        };\n\n        should.equal = function (val1, val2, msg) {\n          new Assertion(val1, msg).to.equal(val2);\n        };\n\n        should.Throw = function (fn, errt, errs, msg) {\n          new Assertion(fn, msg).to.Throw(errt, errs);\n        };\n\n        should.exist = function (val, msg) {\n          new Assertion(val, msg).to.exist;\n        };\n\n        // negation\n        should.not = {};\n\n        should.not.equal = function (val1, val2, msg) {\n          new Assertion(val1, msg).to.not.equal(val2);\n        };\n\n        should.not.Throw = function (fn, errt, errs, msg) {\n          new Assertion(fn, msg).to.not.Throw(errt, errs);\n        };\n\n        should.not.exist = function (val, msg) {\n          new Assertion(val, msg).to.not.exist;\n        };\n\n        should['throw'] = should['Throw'];\n        should.not['throw'] = should.not['Throw'];\n\n        return should;\n      };\n\n      chai.should = loadShould;\n      chai.Should = loadShould;\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/addChainableMethod.js\", function (exports, module) {\n    /*!\n     * Chai - addChainingMethod utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */\n\n    /*!\n     * Module dependencies\n     */\n\n    var transferFlags = require('chai/lib/chai/utils/transferFlags.js');\n    var flag = require('chai/lib/chai/utils/flag.js');\n    var config = require('chai/lib/chai/config.js');\n\n    /*!\n     * Module variables\n     */\n\n    // Check whether `__proto__` is supported\n    var hasProtoSupport = '__proto__' in Object;\n\n    // Without `__proto__` support, this module will need to add properties to a function.\n    // However, some Function.prototype methods cannot be overwritten,\n    // and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).\n    var excludeNames = /^(?:length|name|arguments|caller)$/;\n\n    // Cache `Function` properties\n    var call = Function.prototype.call,\n        apply = Function.prototype.apply;\n\n    /**\n     * ### addChainableMethod (ctx, name, method, chainingBehavior)\n     *\n     * Adds a method to an object, such that the method can also be chained.\n     *\n     *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {\n     *       var obj = utils.flag(this, 'object');\n     *       new chai.Assertion(obj).to.be.equal(str);\n     *     });\n     *\n     * Can also be accessed directly from `chai.Assertion`.\n     *\n     *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);\n     *\n     * The result can then be used as both a method assertion, executing both `method` and\n     * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.\n     *\n     *     expect(fooStr).to.be.foo('bar');\n     *     expect(fooStr).to.be.foo.equal('foo');\n     *\n     * @param {Object} ctx object to which the method is added\n     * @param {String} name of method to add\n     * @param {Function} method function to be used for `name`, when called\n     * @param {Function} chainingBehavior function to be called every time the property is accessed\n     * @name addChainableMethod\n     * @api public\n     */\n\n    module.exports = function (ctx, name, method, chainingBehavior) {\n      if (typeof chainingBehavior !== 'function') {\n        chainingBehavior = function chainingBehavior() {};\n      }\n\n      var chainableBehavior = {\n        method: method,\n        chainingBehavior: chainingBehavior\n      };\n\n      // save the methods so we can overwrite them later, if we need to.\n      if (!ctx.__methods) {\n        ctx.__methods = {};\n      }\n      ctx.__methods[name] = chainableBehavior;\n\n      Object.defineProperty(ctx, name, { get: function get() {\n          chainableBehavior.chainingBehavior.call(this);\n\n          var assert = function assert() {\n            var old_ssfi = flag(this, 'ssfi');\n            if (old_ssfi && config.includeStack === false) flag(this, 'ssfi', assert);\n            var result = chainableBehavior.method.apply(this, arguments);\n            return result === undefined ? this : result;\n          };\n\n          // Use `__proto__` if available\n          if (hasProtoSupport) {\n            // Inherit all properties from the object by replacing the `Function` prototype\n            var prototype = assert.__proto__ = Object.create(this);\n            // Restore the `call` and `apply` methods from `Function`\n            prototype.call = call;\n            prototype.apply = apply;\n          }\n          // Otherwise, redefine all properties (slow!)\n          else {\n              var asserterNames = Object.getOwnPropertyNames(ctx);\n              asserterNames.forEach(function (asserterName) {\n                if (!excludeNames.test(asserterName)) {\n                  var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);\n                  Object.defineProperty(assert, asserterName, pd);\n                }\n              });\n            }\n\n          transferFlags(this, assert);\n          return assert;\n        },\n        configurable: true\n      });\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/addMethod.js\", function (exports, module) {\n    /*!\n     * Chai - addMethod utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */\n\n    var config = require('chai/lib/chai/config.js');\n\n    /**\n     * ### .addMethod (ctx, name, method)\n     *\n     * Adds a method to the prototype of an object.\n     *\n     *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {\n     *       var obj = utils.flag(this, 'object');\n     *       new chai.Assertion(obj).to.be.equal(str);\n     *     });\n     *\n     * Can also be accessed directly from `chai.Assertion`.\n     *\n     *     chai.Assertion.addMethod('foo', fn);\n     *\n     * Then can be used as any other assertion.\n     *\n     *     expect(fooStr).to.be.foo('bar');\n     *\n     * @param {Object} ctx object to which the method is added\n     * @param {String} name of method to add\n     * @param {Function} method function to be used for name\n     * @name addMethod\n     * @api public\n     */\n    var flag = require('chai/lib/chai/utils/flag.js');\n\n    module.exports = function (ctx, name, method) {\n      ctx[name] = function () {\n        var old_ssfi = flag(this, 'ssfi');\n        if (old_ssfi && config.includeStack === false) flag(this, 'ssfi', ctx[name]);\n        var result = method.apply(this, arguments);\n        return result === undefined ? this : result;\n      };\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/addProperty.js\", function (exports, module) {\n    /*!\n     * Chai - addProperty utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */\n\n    /**\n     * ### addProperty (ctx, name, getter)\n     *\n     * Adds a property to the prototype of an object.\n     *\n     *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {\n     *       var obj = utils.flag(this, 'object');\n     *       new chai.Assertion(obj).to.be.instanceof(Foo);\n     *     });\n     *\n     * Can also be accessed directly from `chai.Assertion`.\n     *\n     *     chai.Assertion.addProperty('foo', fn);\n     *\n     * Then can be used as any other assertion.\n     *\n     *     expect(myFoo).to.be.foo;\n     *\n     * @param {Object} ctx object to which the property is added\n     * @param {String} name of property to add\n     * @param {Function} getter function to be used for name\n     * @name addProperty\n     * @api public\n     */\n\n    module.exports = function (ctx, name, getter) {\n      Object.defineProperty(ctx, name, { get: function get() {\n          var result = getter.call(this);\n          return result === undefined ? this : result;\n        },\n        configurable: true\n      });\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/flag.js\", function (exports, module) {\n    /*!\n     * Chai - flag utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */\n\n    /**\n     * ### flag(object, key, [value])\n     *\n     * Get or set a flag value on an object. If a\n     * value is provided it will be set, else it will\n     * return the currently set value or `undefined` if\n     * the value is not set.\n     *\n     *     utils.flag(this, 'foo', 'bar'); // setter\n     *     utils.flag(this, 'foo'); // getter, returns `bar`\n     *\n     * @param {Object} object constructed Assertion\n     * @param {String} key\n     * @param {Mixed} value (optional)\n     * @name flag\n     * @api private\n     */\n\n    module.exports = function (obj, key, value) {\n      var flags = obj.__flags || (obj.__flags = Object.create(null));\n      if (arguments.length === 3) {\n        flags[key] = value;\n      } else {\n        return flags[key];\n      }\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/getActual.js\", function (exports, module) {\n    /*!\n     * Chai - getActual utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */\n\n    /**\n     * # getActual(object, [actual])\n     *\n     * Returns the `actual` value for an Assertion\n     *\n     * @param {Object} object (constructed Assertion)\n     * @param {Arguments} chai.Assertion.prototype.assert arguments\n     */\n\n    module.exports = function (obj, args) {\n      return args.length > 4 ? args[4] : obj._obj;\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/getEnumerableProperties.js\", function (exports, module) {\n    /*!\n     * Chai - getEnumerableProperties utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */\n\n    /**\n     * ### .getEnumerableProperties(object)\n     *\n     * This allows the retrieval of enumerable property names of an object,\n     * inherited or not.\n     *\n     * @param {Object} object\n     * @returns {Array}\n     * @name getEnumerableProperties\n     * @api public\n     */\n\n    module.exports = function getEnumerableProperties(object) {\n      var result = [];\n      for (var name in object) {\n        result.push(name);\n      }\n      return result;\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/getMessage.js\", function (exports, module) {\n    /*!\n     * Chai - message composition utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */\n\n    /*!\n     * Module dependancies\n     */\n\n    var flag = require('chai/lib/chai/utils/flag.js'),\n        getActual = require('chai/lib/chai/utils/getActual.js'),\n        inspect = require('chai/lib/chai/utils/inspect.js'),\n        objDisplay = require('chai/lib/chai/utils/objDisplay.js');\n\n    /**\n     * ### .getMessage(object, message, negateMessage)\n     *\n     * Construct the error message based on flags\n     * and template tags. Template tags will return\n     * a stringified inspection of the object referenced.\n     *\n     * Message template tags:\n     * - `#{this}` current asserted object\n     * - `#{act}` actual value\n     * - `#{exp}` expected value\n     *\n     * @param {Object} object (constructed Assertion)\n     * @param {Arguments} chai.Assertion.prototype.assert arguments\n     * @name getMessage\n     * @api public\n     */\n\n    module.exports = function (obj, args) {\n      var negate = flag(obj, 'negate'),\n          val = flag(obj, 'object'),\n          expected = args[3],\n          actual = getActual(obj, args),\n          msg = negate ? args[2] : args[1],\n          flagMsg = flag(obj, 'message');\n\n      if (typeof msg === \"function\") msg = msg();\n      msg = msg || '';\n      msg = msg.replace(/#{this}/g, objDisplay(val)).replace(/#{act}/g, objDisplay(actual)).replace(/#{exp}/g, objDisplay(expected));\n\n      return flagMsg ? flagMsg + ': ' + msg : msg;\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/getName.js\", function (exports, module) {\n    /*!\n     * Chai - getName utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */\n\n    /**\n     * # getName(func)\n     *\n     * Gets the name of a function, in a cross-browser way.\n     *\n     * @param {Function} a function (usually a constructor)\n     */\n\n    module.exports = function (func) {\n      if (func.name) return func.name;\n\n      var match = /^\\s?function ([^(]*)\\(/.exec(func);\n      return match && match[1] ? match[1] : \"\";\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/getPathValue.js\", function (exports, module) {\n    /*!\n     * Chai - getPathValue utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * @see https://github.com/logicalparadox/filtr\n     * MIT Licensed\n     */\n\n    var getPathInfo = require('chai/lib/chai/utils/getPathInfo.js');\n\n    /**\n     * ### .getPathValue(path, object)\n     *\n     * This allows the retrieval of values in an\n     * object given a string path.\n     *\n     *     var obj = {\n     *         prop1: {\n     *             arr: ['a', 'b', 'c']\n     *           , str: 'Hello'\n     *         }\n     *       , prop2: {\n     *             arr: [ { nested: 'Universe' } ]\n     *           , str: 'Hello again!'\n     *         }\n     *     }\n     *\n     * The following would be the results.\n     *\n     *     getPathValue('prop1.str', obj); // Hello\n     *     getPathValue('prop1.att[2]', obj); // b\n     *     getPathValue('prop2.arr[0].nested', obj); // Universe\n     *\n     * @param {String} path\n     * @param {Object} object\n     * @returns {Object} value or `undefined`\n     * @name getPathValue\n     * @api public\n     */\n    module.exports = function (path, obj) {\n      var info = getPathInfo(path, obj);\n      return info.value;\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/getPathInfo.js\", function (exports, module) {\n    /*!\n     * Chai - getPathInfo utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */\n\n    var hasProperty = require('chai/lib/chai/utils/hasProperty.js');\n\n    /**\n     * ### .getPathInfo(path, object)\n     *\n     * This allows the retrieval of property info in an\n     * object given a string path.\n     *\n     * The path info consists of an object with the\n     * following properties:\n     *\n     * * parent - The parent object of the property referenced by `path`\n     * * name - The name of the final property, a number if it was an array indexer\n     * * value - The value of the property, if it exists, otherwise `undefined`\n     * * exists - Whether the property exists or not\n     *\n     * @param {String} path\n     * @param {Object} object\n     * @returns {Object} info\n     * @name getPathInfo\n     * @api public\n     */\n\n    module.exports = function getPathInfo(path, obj) {\n      var parsed = parsePath(path),\n          last = parsed[parsed.length - 1];\n\n      var info = {\n        parent: _getPathValue(parsed, obj, parsed.length - 1),\n        name: last.p || last.i,\n        value: _getPathValue(parsed, obj)\n      };\n      info.exists = hasProperty(info.name, info.parent);\n\n      return info;\n    };\n\n    /*!\n     * ## parsePath(path)\n     *\n     * Helper function used to parse string object\n     * paths. Use in conjunction with `_getPathValue`.\n     *\n     *      var parsed = parsePath('myobject.property.subprop');\n     *\n     * ### Paths:\n     *\n     * * Can be as near infinitely deep and nested\n     * * Arrays are also valid using the formal `myobject.document[3].property`.\n     *\n     * @param {String} path\n     * @returns {Object} parsed\n     * @api private\n     */\n\n    function parsePath(path) {\n      var str = path.replace(/\\[/g, '.['),\n          parts = str.match(/(\\\\\\.|[^.]+?)+/g);\n      return parts.map(function (value) {\n        var re = /\\[(\\d+)\\]$/,\n            mArr = re.exec(value);\n        if (mArr) return { i: parseFloat(mArr[1]) };else return { p: value };\n      });\n    }\n\n    /*!\n     * ## _getPathValue(parsed, obj)\n     *\n     * Helper companion function for `.parsePath` that returns\n     * the value located at the parsed address.\n     *\n     *      var value = getPathValue(parsed, obj);\n     *\n     * @param {Object} parsed definition from `parsePath`.\n     * @param {Object} object to search against\n     * @param {Number} object to search against\n     * @returns {Object|Undefined} value\n     * @api private\n     */\n\n    function _getPathValue(parsed, obj, index) {\n      var tmp = obj,\n          res;\n\n      index = index === undefined ? parsed.length : index;\n\n      for (var i = 0, l = index; i < l; i++) {\n        var part = parsed[i];\n        if (tmp) {\n          if ('undefined' !== typeof part.p) tmp = tmp[part.p];else if ('undefined' !== typeof part.i) tmp = tmp[part.i];\n          if (i == l - 1) res = tmp;\n        } else {\n          res = undefined;\n        }\n      }\n      return res;\n    }\n  });\n\n  require.register(\"chai/lib/chai/utils/hasProperty.js\", function (exports, module) {\n    /*!\n     * Chai - hasProperty utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */\n\n    var type = require('chai/lib/chai/utils/type.js');\n\n    /**\n     * ### .hasProperty(object, name)\n     *\n     * This allows checking whether an object has\n     * named property or numeric array index.\n     *\n     * Basically does the same thing as the `in`\n     * operator but works properly with natives\n     * and null/undefined values.\n     *\n     *     var obj = {\n     *         arr: ['a', 'b', 'c']\n     *       , str: 'Hello'\n     *     }\n     *\n     * The following would be the results.\n     *\n     *     hasProperty('str', obj);  // true\n     *     hasProperty('constructor', obj);  // true\n     *     hasProperty('bar', obj);  // false\n     *     \n     *     hasProperty('length', obj.str); // true\n     *     hasProperty(1, obj.str);  // true\n     *     hasProperty(5, obj.str);  // false\n     *\n     *     hasProperty('length', obj.arr);  // true\n     *     hasProperty(2, obj.arr);  // true\n     *     hasProperty(3, obj.arr);  // false\n     *\n     * @param {Objuect} object\n     * @param {String|Number} name\n     * @returns {Boolean} whether it exists\n     * @name getPathInfo\n     * @api public\n     */\n\n    var literals = {\n      'number': Number,\n      'string': String\n    };\n\n    module.exports = function hasProperty(name, obj) {\n      var ot = type(obj);\n\n      // Bad Object, obviously no props at all\n      if (ot === 'null' || ot === 'undefined') return false;\n\n      // The `in` operator does not work with certain literals\n      // box these before the check\n      if (literals[ot] && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') obj = new literals[ot](obj);\n\n      return name in obj;\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/getProperties.js\", function (exports, module) {\n    /*!\n     * Chai - getProperties utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */\n\n    /**\n     * ### .getProperties(object)\n     *\n     * This allows the retrieval of property names of an object, enumerable or not,\n     * inherited or not.\n     *\n     * @param {Object} object\n     * @returns {Array}\n     * @name getProperties\n     * @api public\n     */\n\n    module.exports = function getProperties(object) {\n      var result = Object.getOwnPropertyNames(subject);\n\n      function addProperty(property) {\n        if (result.indexOf(property) === -1) {\n          result.push(property);\n        }\n      }\n\n      var proto = Object.getPrototypeOf(subject);\n      while (proto !== null) {\n        Object.getOwnPropertyNames(proto).forEach(addProperty);\n        proto = Object.getPrototypeOf(proto);\n      }\n\n      return result;\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/index.js\", function (exports, module) {\n    /*!\n     * chai\n     * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */\n\n    /*!\n     * Main exports\n     */\n\n    var exports = module.exports = {};\n\n    /*!\n     * test utility\n     */\n\n    exports.test = require('chai/lib/chai/utils/test.js');\n\n    /*!\n     * type utility\n     */\n\n    exports.type = require('chai/lib/chai/utils/type.js');\n\n    /*!\n     * message utility\n     */\n\n    exports.getMessage = require('chai/lib/chai/utils/getMessage.js');\n\n    /*!\n     * actual utility\n     */\n\n    exports.getActual = require('chai/lib/chai/utils/getActual.js');\n\n    /*!\n     * Inspect util\n     */\n\n    exports.inspect = require('chai/lib/chai/utils/inspect.js');\n\n    /*!\n     * Object Display util\n     */\n\n    exports.objDisplay = require('chai/lib/chai/utils/objDisplay.js');\n\n    /*!\n     * Flag utility\n     */\n\n    exports.flag = require('chai/lib/chai/utils/flag.js');\n\n    /*!\n     * Flag transferring utility\n     */\n\n    exports.transferFlags = require('chai/lib/chai/utils/transferFlags.js');\n\n    /*!\n     * Deep equal utility\n     */\n\n    exports.eql = require('chaijs~deep-eql@0.1.3');\n\n    /*!\n     * Deep path value\n     */\n\n    exports.getPathValue = require('chai/lib/chai/utils/getPathValue.js');\n\n    /*!\n     * Deep path info\n     */\n\n    exports.getPathInfo = require('chai/lib/chai/utils/getPathInfo.js');\n\n    /*!\n     * Check if a property exists\n     */\n\n    exports.hasProperty = require('chai/lib/chai/utils/hasProperty.js');\n\n    /*!\n     * Function name\n     */\n\n    exports.getName = require('chai/lib/chai/utils/getName.js');\n\n    /*!\n     * add Property\n     */\n\n    exports.addProperty = require('chai/lib/chai/utils/addProperty.js');\n\n    /*!\n     * add Method\n     */\n\n    exports.addMethod = require('chai/lib/chai/utils/addMethod.js');\n\n    /*!\n     * overwrite Property\n     */\n\n    exports.overwriteProperty = require('chai/lib/chai/utils/overwriteProperty.js');\n\n    /*!\n     * overwrite Method\n     */\n\n    exports.overwriteMethod = require('chai/lib/chai/utils/overwriteMethod.js');\n\n    /*!\n     * Add a chainable method\n     */\n\n    exports.addChainableMethod = require('chai/lib/chai/utils/addChainableMethod.js');\n\n    /*!\n     * Overwrite chainable method\n     */\n\n    exports.overwriteChainableMethod = require('chai/lib/chai/utils/overwriteChainableMethod.js');\n  });\n\n  require.register(\"chai/lib/chai/utils/inspect.js\", function (exports, module) {\n    // This is (almost) directly from Node.js utils\n    // https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js\n\n    var getName = require('chai/lib/chai/utils/getName.js');\n    var getProperties = require('chai/lib/chai/utils/getProperties.js');\n    var getEnumerableProperties = require('chai/lib/chai/utils/getEnumerableProperties.js');\n\n    module.exports = inspect;\n\n    /**\n     * Echos the value of a value. Trys to print the value out\n     * in the best way possible given the different types.\n     *\n     * @param {Object} obj The object to print out.\n     * @param {Boolean} showHidden Flag that shows hidden (not enumerable)\n     *    properties of objects.\n     * @param {Number} depth Depth in which to descend in object. Default is 2.\n     * @param {Boolean} colors Flag to turn on ANSI escape codes to color the\n     *    output. Default is false (no coloring).\n     */\n    function inspect(obj, showHidden, depth, colors) {\n      var ctx = {\n        showHidden: showHidden,\n        seen: [],\n        stylize: function stylize(str) {\n          return str;\n        }\n      };\n      return formatValue(ctx, obj, typeof depth === 'undefined' ? 2 : depth);\n    }\n\n    // Returns true if object is a DOM element.\n    var isDOMElement = function isDOMElement(object) {\n      if ((typeof HTMLElement === 'undefined' ? 'undefined' : _typeof(HTMLElement)) === 'object') {\n        return object instanceof HTMLElement;\n      } else {\n        return object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object.nodeType === 1 && typeof object.nodeName === 'string';\n      }\n    };\n\n    function formatValue(ctx, value, recurseTimes) {\n      // Provide a hook for user-specified inspect functions.\n      // Check that value is an object with an inspect function on it\n      if (value && typeof value.inspect === 'function' &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n        var ret = value.inspect(recurseTimes);\n        if (typeof ret !== 'string') {\n          ret = formatValue(ctx, ret, recurseTimes);\n        }\n        return ret;\n      }\n\n      // Primitive types cannot have properties\n      var primitive = formatPrimitive(ctx, value);\n      if (primitive) {\n        return primitive;\n      }\n\n      // If this is a DOM element, try to get the outer HTML.\n      if (isDOMElement(value)) {\n        if ('outerHTML' in value) {\n          return value.outerHTML;\n          // This value does not have an outerHTML attribute,\n          //   it could still be an XML element\n        } else {\n            // Attempt to serialize it\n            try {\n              if (document.xmlVersion) {\n                var xmlSerializer = new XMLSerializer();\n                return xmlSerializer.serializeToString(value);\n              } else {\n                // Firefox 11- do not support outerHTML\n                //   It does, however, support innerHTML\n                //   Use the following to render the element\n                var ns = \"http://www.w3.org/1999/xhtml\";\n                var container = document.createElementNS(ns, '_');\n\n                container.appendChild(value.cloneNode(false));\n                html = container.innerHTML.replace('><', '>' + value.innerHTML + '<');\n                container.innerHTML = '';\n                return html;\n              }\n            } catch (err) {\n              // This could be a non-native DOM implementation,\n              //   continue with the normal flow:\n              //   printing the element as if it is an object.\n            }\n          }\n      }\n\n      // Look up the keys of the object.\n      var visibleKeys = getEnumerableProperties(value);\n      var keys = ctx.showHidden ? getProperties(value) : visibleKeys;\n\n      // Some type of object without properties can be shortcutted.\n      // In IE, errors have a single `stack` property, or if they are vanilla `Error`,\n      // a `stack` plus `description` property; ignore those for consistency.\n      if (keys.length === 0 || isError(value) && (keys.length === 1 && keys[0] === 'stack' || keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')) {\n        if (typeof value === 'function') {\n          var name = getName(value);\n          var nameSuffix = name ? ': ' + name : '';\n          return ctx.stylize('[Function' + nameSuffix + ']', 'special');\n        }\n        if (isRegExp(value)) {\n          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n        }\n        if (isDate(value)) {\n          return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');\n        }\n        if (isError(value)) {\n          return formatError(value);\n        }\n      }\n\n      var base = '',\n          array = false,\n          braces = ['{', '}'];\n\n      // Make Array say that they are Array\n      if (isArray(value)) {\n        array = true;\n        braces = ['[', ']'];\n      }\n\n      // Make functions say that they are functions\n      if (typeof value === 'function') {\n        var name = getName(value);\n        var nameSuffix = name ? ': ' + name : '';\n        base = ' [Function' + nameSuffix + ']';\n      }\n\n      // Make RegExps say that they are RegExps\n      if (isRegExp(value)) {\n        base = ' ' + RegExp.prototype.toString.call(value);\n      }\n\n      // Make dates with properties first say the date\n      if (isDate(value)) {\n        base = ' ' + Date.prototype.toUTCString.call(value);\n      }\n\n      // Make error with message first say the error\n      if (isError(value)) {\n        return formatError(value);\n      }\n\n      if (keys.length === 0 && (!array || value.length == 0)) {\n        return braces[0] + base + braces[1];\n      }\n\n      if (recurseTimes < 0) {\n        if (isRegExp(value)) {\n          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n        } else {\n          return ctx.stylize('[Object]', 'special');\n        }\n      }\n\n      ctx.seen.push(value);\n\n      var output;\n      if (array) {\n        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n      } else {\n        output = keys.map(function (key) {\n          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n        });\n      }\n\n      ctx.seen.pop();\n\n      return reduceToSingleString(output, base, braces);\n    }\n\n    function formatPrimitive(ctx, value) {\n      switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {\n        case 'undefined':\n          return ctx.stylize('undefined', 'undefined');\n\n        case 'string':\n          var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '').replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + '\\'';\n          return ctx.stylize(simple, 'string');\n\n        case 'number':\n          if (value === 0 && 1 / value === -Infinity) {\n            return ctx.stylize('-0', 'number');\n          }\n          return ctx.stylize('' + value, 'number');\n\n        case 'boolean':\n          return ctx.stylize('' + value, 'boolean');\n      }\n      // For some reason typeof null is \"object\", so special case here.\n      if (value === null) {\n        return ctx.stylize('null', 'null');\n      }\n    }\n\n    function formatError(value) {\n      return '[' + Error.prototype.toString.call(value) + ']';\n    }\n\n    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n      var output = [];\n      for (var i = 0, l = value.length; i < l; ++i) {\n        if (Object.prototype.hasOwnProperty.call(value, String(i))) {\n          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));\n        } else {\n          output.push('');\n        }\n      }\n      keys.forEach(function (key) {\n        if (!key.match(/^\\d+$/)) {\n          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));\n        }\n      });\n      return output;\n    }\n\n    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n      var name, str;\n      if (value.__lookupGetter__) {\n        if (value.__lookupGetter__(key)) {\n          if (value.__lookupSetter__(key)) {\n            str = ctx.stylize('[Getter/Setter]', 'special');\n          } else {\n            str = ctx.stylize('[Getter]', 'special');\n          }\n        } else {\n          if (value.__lookupSetter__(key)) {\n            str = ctx.stylize('[Setter]', 'special');\n          }\n        }\n      }\n      if (visibleKeys.indexOf(key) < 0) {\n        name = '[' + key + ']';\n      }\n      if (!str) {\n        if (ctx.seen.indexOf(value[key]) < 0) {\n          if (recurseTimes === null) {\n            str = formatValue(ctx, value[key], null);\n          } else {\n            str = formatValue(ctx, value[key], recurseTimes - 1);\n          }\n          if (str.indexOf('\\n') > -1) {\n            if (array) {\n              str = str.split('\\n').map(function (line) {\n                return '  ' + line;\n              }).join('\\n').substr(2);\n            } else {\n              str = '\\n' + str.split('\\n').map(function (line) {\n                return '   ' + line;\n              }).join('\\n');\n            }\n          }\n        } else {\n          str = ctx.stylize('[Circular]', 'special');\n        }\n      }\n      if (typeof name === 'undefined') {\n        if (array && key.match(/^\\d+$/)) {\n          return str;\n        }\n        name = JSON.stringify('' + key);\n        if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n          name = name.substr(1, name.length - 2);\n          name = ctx.stylize(name, 'name');\n        } else {\n          name = name.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\");\n          name = ctx.stylize(name, 'string');\n        }\n      }\n\n      return name + ': ' + str;\n    }\n\n    function reduceToSingleString(output, base, braces) {\n      var numLinesEst = 0;\n      var length = output.reduce(function (prev, cur) {\n        numLinesEst++;\n        if (cur.indexOf('\\n') >= 0) numLinesEst++;\n        return prev + cur.length + 1;\n      }, 0);\n\n      if (length > 60) {\n        return braces[0] + (base === '' ? '' : base + '\\n ') + ' ' + output.join(',\\n  ') + ' ' + braces[1];\n      }\n\n      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n    }\n\n    function isArray(ar) {\n      return Array.isArray(ar) || (typeof ar === 'undefined' ? 'undefined' : _typeof(ar)) === 'object' && objectToString(ar) === '[object Array]';\n    }\n\n    function isRegExp(re) {\n      return (typeof re === 'undefined' ? 'undefined' : _typeof(re)) === 'object' && objectToString(re) === '[object RegExp]';\n    }\n\n    function isDate(d) {\n      return (typeof d === 'undefined' ? 'undefined' : _typeof(d)) === 'object' && objectToString(d) === '[object Date]';\n    }\n\n    function isError(e) {\n      return (typeof e === 'undefined' ? 'undefined' : _typeof(e)) === 'object' && objectToString(e) === '[object Error]';\n    }\n\n    function objectToString(o) {\n      return Object.prototype.toString.call(o);\n    }\n  });\n\n  require.register(\"chai/lib/chai/utils/objDisplay.js\", function (exports, module) {\n    /*!\n     * Chai - flag utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */\n\n    /*!\n     * Module dependancies\n     */\n\n    var inspect = require('chai/lib/chai/utils/inspect.js');\n    var config = require('chai/lib/chai/config.js');\n\n    /**\n     * ### .objDisplay (object)\n     *\n     * Determines if an object or an array matches\n     * criteria to be inspected in-line for error\n     * messages or should be truncated.\n     *\n     * @param {Mixed} javascript object to inspect\n     * @name objDisplay\n     * @api public\n     */\n\n    module.exports = function (obj) {\n      var str = inspect(obj),\n          type = Object.prototype.toString.call(obj);\n\n      if (config.truncateThreshold && str.length >= config.truncateThreshold) {\n        if (type === '[object Function]') {\n          return !obj.name || obj.name === '' ? '[Function]' : '[Function: ' + obj.name + ']';\n        } else if (type === '[object Array]') {\n          return '[ Array(' + obj.length + ') ]';\n        } else if (type === '[object Object]') {\n          var keys = Object.keys(obj),\n              kstr = keys.length > 2 ? keys.splice(0, 2).join(', ') + ', ...' : keys.join(', ');\n          return '{ Object (' + kstr + ') }';\n        } else {\n          return str;\n        }\n      } else {\n        return str;\n      }\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/overwriteMethod.js\", function (exports, module) {\n    /*!\n     * Chai - overwriteMethod utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */\n\n    /**\n     * ### overwriteMethod (ctx, name, fn)\n     *\n     * Overwites an already existing method and provides\n     * access to previous function. Must return function\n     * to be used for name.\n     *\n     *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {\n     *       return function (str) {\n     *         var obj = utils.flag(this, 'object');\n     *         if (obj instanceof Foo) {\n     *           new chai.Assertion(obj.value).to.equal(str);\n     *         } else {\n     *           _super.apply(this, arguments);\n     *         }\n     *       }\n     *     });\n     *\n     * Can also be accessed directly from `chai.Assertion`.\n     *\n     *     chai.Assertion.overwriteMethod('foo', fn);\n     *\n     * Then can be used as any other assertion.\n     *\n     *     expect(myFoo).to.equal('bar');\n     *\n     * @param {Object} ctx object whose method is to be overwritten\n     * @param {String} name of method to overwrite\n     * @param {Function} method function that returns a function to be used for name\n     * @name overwriteMethod\n     * @api public\n     */\n\n    module.exports = function (ctx, name, method) {\n      var _method = ctx[name],\n          _super = function _super() {\n        return this;\n      };\n\n      if (_method && 'function' === typeof _method) _super = _method;\n\n      ctx[name] = function () {\n        var result = method(_super).apply(this, arguments);\n        return result === undefined ? this : result;\n      };\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/overwriteProperty.js\", function (exports, module) {\n    /*!\n     * Chai - overwriteProperty utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */\n\n    /**\n     * ### overwriteProperty (ctx, name, fn)\n     *\n     * Overwites an already existing property getter and provides\n     * access to previous value. Must return function to use as getter.\n     *\n     *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {\n     *       return function () {\n     *         var obj = utils.flag(this, 'object');\n     *         if (obj instanceof Foo) {\n     *           new chai.Assertion(obj.name).to.equal('bar');\n     *         } else {\n     *           _super.call(this);\n     *         }\n     *       }\n     *     });\n     *\n     *\n     * Can also be accessed directly from `chai.Assertion`.\n     *\n     *     chai.Assertion.overwriteProperty('foo', fn);\n     *\n     * Then can be used as any other assertion.\n     *\n     *     expect(myFoo).to.be.ok;\n     *\n     * @param {Object} ctx object whose property is to be overwritten\n     * @param {String} name of property to overwrite\n     * @param {Function} getter function that returns a getter function to be used for name\n     * @name overwriteProperty\n     * @api public\n     */\n\n    module.exports = function (ctx, name, getter) {\n      var _get = Object.getOwnPropertyDescriptor(ctx, name),\n          _super = function _super() {};\n\n      if (_get && 'function' === typeof _get.get) _super = _get.get;\n\n      Object.defineProperty(ctx, name, { get: function get() {\n          var result = getter(_super).call(this);\n          return result === undefined ? this : result;\n        },\n        configurable: true\n      });\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/overwriteChainableMethod.js\", function (exports, module) {\n    /*!\n     * Chai - overwriteChainableMethod utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */\n\n    /**\n     * ### overwriteChainableMethod (ctx, name, method, chainingBehavior)\n     *\n     * Overwites an already existing chainable method\n     * and provides access to the previous function or\n     * property.  Must return functions to be used for\n     * name.\n     *\n     *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'length',\n     *       function (_super) {\n     *       }\n     *     , function (_super) {\n     *       }\n     *     );\n     *\n     * Can also be accessed directly from `chai.Assertion`.\n     *\n     *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);\n     *\n     * Then can be used as any other assertion.\n     *\n     *     expect(myFoo).to.have.length(3);\n     *     expect(myFoo).to.have.length.above(3);\n     *\n     * @param {Object} ctx object whose method / property is to be overwritten\n     * @param {String} name of method / property to overwrite\n     * @param {Function} method function that returns a function to be used for name\n     * @param {Function} chainingBehavior function that returns a function to be used for property\n     * @name overwriteChainableMethod\n     * @api public\n     */\n\n    module.exports = function (ctx, name, method, chainingBehavior) {\n      var chainableBehavior = ctx.__methods[name];\n\n      var _chainingBehavior = chainableBehavior.chainingBehavior;\n      chainableBehavior.chainingBehavior = function () {\n        var result = chainingBehavior(_chainingBehavior).call(this);\n        return result === undefined ? this : result;\n      };\n\n      var _method = chainableBehavior.method;\n      chainableBehavior.method = function () {\n        var result = method(_method).apply(this, arguments);\n        return result === undefined ? this : result;\n      };\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/test.js\", function (exports, module) {\n    /*!\n     * Chai - test utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */\n\n    /*!\n     * Module dependancies\n     */\n\n    var flag = require('chai/lib/chai/utils/flag.js');\n\n    /**\n     * # test(object, expression)\n     *\n     * Test and object for expression.\n     *\n     * @param {Object} object (constructed Assertion)\n     * @param {Arguments} chai.Assertion.prototype.assert arguments\n     */\n\n    module.exports = function (obj, args) {\n      var negate = flag(obj, 'negate'),\n          expr = args[0];\n      return negate ? !expr : expr;\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/transferFlags.js\", function (exports, module) {\n    /*!\n     * Chai - transferFlags utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */\n\n    /**\n     * ### transferFlags(assertion, object, includeAll = true)\n     *\n     * Transfer all the flags for `assertion` to `object`. If\n     * `includeAll` is set to `false`, then the base Chai\n     * assertion flags (namely `object`, `ssfi`, and `message`)\n     * will not be transferred.\n     *\n     *\n     *     var newAssertion = new Assertion();\n     *     utils.transferFlags(assertion, newAssertion);\n     *\n     *     var anotherAsseriton = new Assertion(myObj);\n     *     utils.transferFlags(assertion, anotherAssertion, false);\n     *\n     * @param {Assertion} assertion the assertion to transfer the flags from\n     * @param {Object} object the object to transfer the flags to; usually a new assertion\n     * @param {Boolean} includeAll\n     * @name transferFlags\n     * @api private\n     */\n\n    module.exports = function (assertion, object, includeAll) {\n      var flags = assertion.__flags || (assertion.__flags = Object.create(null));\n\n      if (!object.__flags) {\n        object.__flags = Object.create(null);\n      }\n\n      includeAll = arguments.length === 3 ? includeAll : true;\n\n      for (var flag in flags) {\n        if (includeAll || flag !== 'object' && flag !== 'ssfi' && flag != 'message') {\n          object.__flags[flag] = flags[flag];\n        }\n      }\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/type.js\", function (exports, module) {\n    /*!\n     * Chai - type utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */\n\n    /*!\n     * Detectable javascript natives\n     */\n\n    var natives = {\n      '[object Arguments]': 'arguments',\n      '[object Array]': 'array',\n      '[object Date]': 'date',\n      '[object Function]': 'function',\n      '[object Number]': 'number',\n      '[object RegExp]': 'regexp',\n      '[object String]': 'string'\n    };\n\n    /**\n     * ### type(object)\n     *\n     * Better implementation of `typeof` detection that can\n     * be used cross-browser. Handles the inconsistencies of\n     * Array, `null`, and `undefined` detection.\n     *\n     *     utils.type({}) // 'object'\n     *     utils.type(null) // `null'\n     *     utils.type(undefined) // `undefined`\n     *     utils.type([]) // `array`\n     *\n     * @param {Mixed} object to detect type of\n     * @name type\n     * @api private\n     */\n\n    module.exports = function (obj) {\n      var str = Object.prototype.toString.call(obj);\n      if (natives[str]) return natives[str];\n      if (obj === null) return 'null';\n      if (obj === undefined) return 'undefined';\n      if (obj === Object(obj)) return 'object';\n      return typeof obj === 'undefined' ? 'undefined' : _typeof(obj);\n    };\n  });\n\n  if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) == \"object\") {\n    module.exports = require(\"chai\");\n  } else if (typeof define == \"function\" && define.amd) {\n    define(\"chai\", [], function () {\n      return require(\"chai\");\n    });\n  } else {\n    (this || window)[\"chai\"] = require(\"chai\");\n  }\n})();","ast":null,"map":{"version":3,"sources":["/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/foundation-sites/test/javascript/chai.js"],"names":[],"mappings":"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","file":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/foundation-sites/test/javascript/chai.js.map","sourcesContent":["\n;(function(){\n\n/**\n * Require the module at `name`.\n *\n * @param {String} name\n * @return {Object} exports\n * @api public\n */\n\nfunction require(name) {\n  var module = require.modules[name];\n  if (!module) throw new Error('failed to require \"' + name + '\"');\n\n  if (!('exports' in module) && typeof module.definition === 'function') {\n    module.client = module.component = true;\n    module.definition.call(this, module.exports = {}, module);\n    delete module.definition;\n  }\n\n  return module.exports;\n}\n\n/**\n * Meta info, accessible in the global scope unless you use AMD option.\n */\n\nrequire.loader = 'component';\n\n/**\n * Internal helper object, contains a sorting function for semantiv versioning\n */\nrequire.helper = {};\nrequire.helper.semVerSort = function(a, b) {\n  var aArray = a.version.split('.');\n  var bArray = b.version.split('.');\n  for (var i=0; i<aArray.length; ++i) {\n    var aInt = parseInt(aArray[i], 10);\n    var bInt = parseInt(bArray[i], 10);\n    if (aInt === bInt) {\n      var aLex = aArray[i].substr((\"\"+aInt).length);\n      var bLex = bArray[i].substr((\"\"+bInt).length);\n      if (aLex === '' && bLex !== '') return 1;\n      if (aLex !== '' && bLex === '') return -1;\n      if (aLex !== '' && bLex !== '') return aLex > bLex ? 1 : -1;\n      continue;\n    } else if (aInt > bInt) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n  return 0;\n}\n\n/**\n * Find and require a module which name starts with the provided name.\n * If multiple modules exists, the highest semver is used. \n * This function can only be used for remote dependencies.\n\n * @param {String} name - module name: `user~repo`\n * @param {Boolean} returnPath - returns the canonical require path if true, \n *                               otherwise it returns the epxorted module\n */\nrequire.latest = function (name, returnPath) {\n  function showError(name) {\n    throw new Error('failed to find latest module of \"' + name + '\"');\n  }\n  // only remotes with semvers, ignore local files conataining a '/'\n  var versionRegexp = /(.*)~(.*)@v?(\\d+\\.\\d+\\.\\d+[^\\/]*)$/;\n  var remoteRegexp = /(.*)~(.*)/;\n  if (!remoteRegexp.test(name)) showError(name);\n  var moduleNames = Object.keys(require.modules);\n  var semVerCandidates = [];\n  var otherCandidates = []; // for instance: name of the git branch\n  for (var i=0; i<moduleNames.length; i++) {\n    var moduleName = moduleNames[i];\n    if (new RegExp(name + '@').test(moduleName)) {\n        var version = moduleName.substr(name.length+1);\n        var semVerMatch = versionRegexp.exec(moduleName);\n        if (semVerMatch != null) {\n          semVerCandidates.push({version: version, name: moduleName});\n        } else {\n          otherCandidates.push({version: version, name: moduleName});\n        } \n    }\n  }\n  if (semVerCandidates.concat(otherCandidates).length === 0) {\n    showError(name);\n  }\n  if (semVerCandidates.length > 0) {\n    var module = semVerCandidates.sort(require.helper.semVerSort).pop().name;\n    if (returnPath === true) {\n      return module;\n    }\n    return require(module);\n  }\n  // if the build contains more than one branch of the same module\n  // you should not use this funciton\n  var module = otherCandidates.sort(function(a, b) {return a.name > b.name})[0].name;\n  if (returnPath === true) {\n    return module;\n  }\n  return require(module);\n}\n\n/**\n * Registered modules.\n */\n\nrequire.modules = {};\n\n/**\n * Register module at `name` with callback `definition`.\n *\n * @param {String} name\n * @param {Function} definition\n * @api private\n */\n\nrequire.register = function (name, definition) {\n  require.modules[name] = {\n    definition: definition\n  };\n};\n\n/**\n * Define a module's exports immediately with `exports`.\n *\n * @param {String} name\n * @param {Generic} exports\n * @api private\n */\n\nrequire.define = function (name, exports) {\n  require.modules[name] = {\n    exports: exports\n  };\n};\nrequire.register(\"chaijs~assertion-error@1.0.0\", function (exports, module) {\n/*!\n * assertion-error\n * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>\n * MIT Licensed\n */\n\n/*!\n * Return a function that will copy properties from\n * one object to another excluding any originally\n * listed. Returned function will create a new `{}`.\n *\n * @param {String} excluded properties ...\n * @return {Function}\n */\n\nfunction exclude () {\n  var excludes = [].slice.call(arguments);\n\n  function excludeProps (res, obj) {\n    Object.keys(obj).forEach(function (key) {\n      if (!~excludes.indexOf(key)) res[key] = obj[key];\n    });\n  }\n\n  return function extendExclude () {\n    var args = [].slice.call(arguments)\n      , i = 0\n      , res = {};\n\n    for (; i < args.length; i++) {\n      excludeProps(res, args[i]);\n    }\n\n    return res;\n  };\n};\n\n/*!\n * Primary Exports\n */\n\nmodule.exports = AssertionError;\n\n/**\n * ### AssertionError\n *\n * An extension of the JavaScript `Error` constructor for\n * assertion and validation scenarios.\n *\n * @param {String} message\n * @param {Object} properties to include (optional)\n * @param {callee} start stack function (optional)\n */\n\nfunction AssertionError (message, _props, ssf) {\n  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')\n    , props = extend(_props || {});\n\n  // default values\n  this.message = message || 'Unspecified AssertionError';\n  this.showDiff = false;\n\n  // copy from properties\n  for (var key in props) {\n    this[key] = props[key];\n  }\n\n  // capture stack trace\n  ssf = ssf || arguments.callee;\n  if (ssf && Error.captureStackTrace) {\n    Error.captureStackTrace(this, ssf);\n  }\n}\n\n/*!\n * Inherit from Error.prototype\n */\n\nAssertionError.prototype = Object.create(Error.prototype);\n\n/*!\n * Statically set name\n */\n\nAssertionError.prototype.name = 'AssertionError';\n\n/*!\n * Ensure correct constructor\n */\n\nAssertionError.prototype.constructor = AssertionError;\n\n/**\n * Allow errors to be converted to JSON for static transfer.\n *\n * @param {Boolean} include stack (default: `true`)\n * @return {Object} object that can be `JSON.stringify`\n */\n\nAssertionError.prototype.toJSON = function (stack) {\n  var extend = exclude('constructor', 'toJSON', 'stack')\n    , props = extend({ name: this.name }, this);\n\n  // include stack if exists and not turned off\n  if (false !== stack && this.stack) {\n    props.stack = this.stack;\n  }\n\n  return props;\n};\n\n});\n\nrequire.register(\"chaijs~type-detect@0.1.1\", function (exports, module) {\n/*!\n * type-detect\n * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Primary Exports\n */\n\nvar exports = module.exports = getType;\n\n/*!\n * Detectable javascript natives\n */\n\nvar natives = {\n    '[object Array]': 'array'\n  , '[object RegExp]': 'regexp'\n  , '[object Function]': 'function'\n  , '[object Arguments]': 'arguments'\n  , '[object Date]': 'date'\n};\n\n/**\n * ### typeOf (obj)\n *\n * Use several different techniques to determine\n * the type of object being tested.\n *\n *\n * @param {Mixed} object\n * @return {String} object type\n * @api public\n */\n\nfunction getType (obj) {\n  var str = Object.prototype.toString.call(obj);\n  if (natives[str]) return natives[str];\n  if (obj === null) return 'null';\n  if (obj === undefined) return 'undefined';\n  if (obj === Object(obj)) return 'object';\n  return typeof obj;\n}\n\nexports.Library = Library;\n\n/**\n * ### Library\n *\n * Create a repository for custom type detection.\n *\n * ```js\n * var lib = new type.Library;\n * ```\n *\n */\n\nfunction Library () {\n  this.tests = {};\n}\n\n/**\n * #### .of (obj)\n *\n * Expose replacement `typeof` detection to the library.\n *\n * ```js\n * if ('string' === lib.of('hello world')) {\n *   // ...\n * }\n * ```\n *\n * @param {Mixed} object to test\n * @return {String} type\n */\n\nLibrary.prototype.of = getType;\n\n/**\n * #### .define (type, test)\n *\n * Add a test to for the `.test()` assertion.\n *\n * Can be defined as a regular expression:\n *\n * ```js\n * lib.define('int', /^[0-9]+$/);\n * ```\n *\n * ... or as a function:\n *\n * ```js\n * lib.define('bln', function (obj) {\n *   if ('boolean' === lib.of(obj)) return true;\n *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];\n *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();\n *   return !! ~blns.indexOf(obj);\n * });\n * ```\n *\n * @param {String} type\n * @param {RegExp|Function} test\n * @api public\n */\n\nLibrary.prototype.define = function (type, test) {\n  if (arguments.length === 1) return this.tests[type];\n  this.tests[type] = test;\n  return this;\n};\n\n/**\n * #### .test (obj, test)\n *\n * Assert that an object is of type. Will first\n * check natives, and if that does not pass it will\n * use the user defined custom tests.\n *\n * ```js\n * assert(lib.test('1', 'int'));\n * assert(lib.test('yes', 'bln'));\n * ```\n *\n * @param {Mixed} object\n * @param {String} type\n * @return {Boolean} result\n * @api public\n */\n\nLibrary.prototype.test = function (obj, type) {\n  if (type === getType(obj)) return true;\n  var test = this.tests[type];\n\n  if (test && 'regexp' === getType(test)) {\n    return test.test(obj);\n  } else if (test && 'function' === getType(test)) {\n    return test(obj);\n  } else {\n    throw new ReferenceError('Type test \"' + type + '\" not defined or invalid.');\n  }\n};\n\n});\n\nrequire.register(\"chaijs~deep-eql@0.1.3\", function (exports, module) {\n/*!\n * deep-eql\n * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar type = require('chaijs~type-detect@0.1.1');\n\n/*!\n * Buffer.isBuffer browser shim\n */\n\nvar Buffer;\ntry { Buffer = require('buffer').Buffer; }\ncatch(ex) {\n  Buffer = {};\n  Buffer.isBuffer = function() { return false; }\n}\n\n/*!\n * Primary Export\n */\n\nmodule.exports = deepEqual;\n\n/**\n * Assert super-strict (egal) equality between\n * two objects of any type.\n *\n * @param {Mixed} a\n * @param {Mixed} b\n * @param {Array} memoised (optional)\n * @return {Boolean} equal match\n */\n\nfunction deepEqual(a, b, m) {\n  if (sameValue(a, b)) {\n    return true;\n  } else if ('date' === type(a)) {\n    return dateEqual(a, b);\n  } else if ('regexp' === type(a)) {\n    return regexpEqual(a, b);\n  } else if (Buffer.isBuffer(a)) {\n    return bufferEqual(a, b);\n  } else if ('arguments' === type(a)) {\n    return argumentsEqual(a, b, m);\n  } else if (!typeEqual(a, b)) {\n    return false;\n  } else if (('object' !== type(a) && 'object' !== type(b))\n  && ('array' !== type(a) && 'array' !== type(b))) {\n    return sameValue(a, b);\n  } else {\n    return objectEqual(a, b, m);\n  }\n}\n\n/*!\n * Strict (egal) equality test. Ensures that NaN always\n * equals NaN and `-0` does not equal `+0`.\n *\n * @param {Mixed} a\n * @param {Mixed} b\n * @return {Boolean} equal match\n */\n\nfunction sameValue(a, b) {\n  if (a === b) return a !== 0 || 1 / a === 1 / b;\n  return a !== a && b !== b;\n}\n\n/*!\n * Compare the types of two given objects and\n * return if they are equal. Note that an Array\n * has a type of `array` (not `object`) and arguments\n * have a type of `arguments` (not `array`/`object`).\n *\n * @param {Mixed} a\n * @param {Mixed} b\n * @return {Boolean} result\n */\n\nfunction typeEqual(a, b) {\n  return type(a) === type(b);\n}\n\n/*!\n * Compare two Date objects by asserting that\n * the time values are equal using `saveValue`.\n *\n * @param {Date} a\n * @param {Date} b\n * @return {Boolean} result\n */\n\nfunction dateEqual(a, b) {\n  if ('date' !== type(b)) return false;\n  return sameValue(a.getTime(), b.getTime());\n}\n\n/*!\n * Compare two regular expressions by converting them\n * to string and checking for `sameValue`.\n *\n * @param {RegExp} a\n * @param {RegExp} b\n * @return {Boolean} result\n */\n\nfunction regexpEqual(a, b) {\n  if ('regexp' !== type(b)) return false;\n  return sameValue(a.toString(), b.toString());\n}\n\n/*!\n * Assert deep equality of two `arguments` objects.\n * Unfortunately, these must be sliced to arrays\n * prior to test to ensure no bad behavior.\n *\n * @param {Arguments} a\n * @param {Arguments} b\n * @param {Array} memoize (optional)\n * @return {Boolean} result\n */\n\nfunction argumentsEqual(a, b, m) {\n  if ('arguments' !== type(b)) return false;\n  a = [].slice.call(a);\n  b = [].slice.call(b);\n  return deepEqual(a, b, m);\n}\n\n/*!\n * Get enumerable properties of a given object.\n *\n * @param {Object} a\n * @return {Array} property names\n */\n\nfunction enumerable(a) {\n  var res = [];\n  for (var key in a) res.push(key);\n  return res;\n}\n\n/*!\n * Simple equality for flat iterable objects\n * such as Arrays or Node.js buffers.\n *\n * @param {Iterable} a\n * @param {Iterable} b\n * @return {Boolean} result\n */\n\nfunction iterableEqual(a, b) {\n  if (a.length !==  b.length) return false;\n\n  var i = 0;\n  var match = true;\n\n  for (; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      match = false;\n      break;\n    }\n  }\n\n  return match;\n}\n\n/*!\n * Extension to `iterableEqual` specifically\n * for Node.js Buffers.\n *\n * @param {Buffer} a\n * @param {Mixed} b\n * @return {Boolean} result\n */\n\nfunction bufferEqual(a, b) {\n  if (!Buffer.isBuffer(b)) return false;\n  return iterableEqual(a, b);\n}\n\n/*!\n * Block for `objectEqual` ensuring non-existing\n * values don't get in.\n *\n * @param {Mixed} object\n * @return {Boolean} result\n */\n\nfunction isValue(a) {\n  return a !== null && a !== undefined;\n}\n\n/*!\n * Recursively check the equality of two objects.\n * Once basic sameness has been established it will\n * defer to `deepEqual` for each enumerable key\n * in the object.\n *\n * @param {Mixed} a\n * @param {Mixed} b\n * @return {Boolean} result\n */\n\nfunction objectEqual(a, b, m) {\n  if (!isValue(a) || !isValue(b)) {\n    return false;\n  }\n\n  if (a.prototype !== b.prototype) {\n    return false;\n  }\n\n  var i;\n  if (m) {\n    for (i = 0; i < m.length; i++) {\n      if ((m[i][0] === a && m[i][1] === b)\n      ||  (m[i][0] === b && m[i][1] === a)) {\n        return true;\n      }\n    }\n  } else {\n    m = [];\n  }\n\n  try {\n    var ka = enumerable(a);\n    var kb = enumerable(b);\n  } catch (ex) {\n    return false;\n  }\n\n  ka.sort();\n  kb.sort();\n\n  if (!iterableEqual(ka, kb)) {\n    return false;\n  }\n\n  m.push([ a, b ]);\n\n  var key;\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], m)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n});\n\nrequire.register(\"chai\", function (exports, module) {\nmodule.exports = require('chai/lib/chai.js');\n\n});\n\nrequire.register(\"chai/lib/chai.js\", function (exports, module) {\n/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar used = []\n  , exports = module.exports = {};\n\n/*!\n * Chai version\n */\n\nexports.version = '2.1.0';\n\n/*!\n * Assertion Error\n */\n\nexports.AssertionError = require('chaijs~assertion-error@1.0.0');\n\n/*!\n * Utils for plugins (not exported)\n */\n\nvar util = require('chai/lib/chai/utils/index.js');\n\n/**\n * # .use(function)\n *\n * Provides a way to extend the internals of Chai\n *\n * @param {Function}\n * @returns {this} for chaining\n * @api public\n */\n\nexports.use = function (fn) {\n  if (!~used.indexOf(fn)) {\n    fn(this, util);\n    used.push(fn);\n  }\n\n  return this;\n};\n\n/*!\n * Utility Functions\n */\n\nexports.util = util;\n\n/*!\n * Configuration\n */\n\nvar config = require('chai/lib/chai/config.js');\nexports.config = config;\n\n/*!\n * Primary `Assertion` prototype\n */\n\nvar assertion = require('chai/lib/chai/assertion.js');\nexports.use(assertion);\n\n/*!\n * Core Assertions\n */\n\nvar core = require('chai/lib/chai/core/assertions.js');\nexports.use(core);\n\n/*!\n * Expect interface\n */\n\nvar expect = require('chai/lib/chai/interface/expect.js');\nexports.use(expect);\n\n/*!\n * Should interface\n */\n\nvar should = require('chai/lib/chai/interface/should.js');\nexports.use(should);\n\n/*!\n * Assert interface\n */\n\nvar assert = require('chai/lib/chai/interface/assert.js');\nexports.use(assert);\n\n});\n\nrequire.register(\"chai/lib/chai/assertion.js\", function (exports, module) {\n/*!\n * chai\n * http://chaijs.com\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar config = require('chai/lib/chai/config.js');\n\nmodule.exports = function (_chai, util) {\n  /*!\n   * Module dependencies.\n   */\n\n  var AssertionError = _chai.AssertionError\n    , flag = util.flag;\n\n  /*!\n   * Module export.\n   */\n\n  _chai.Assertion = Assertion;\n\n  /*!\n   * Assertion Constructor\n   *\n   * Creates object for chaining.\n   *\n   * @api private\n   */\n\n  function Assertion (obj, msg, stack) {\n    flag(this, 'ssfi', stack || arguments.callee);\n    flag(this, 'object', obj);\n    flag(this, 'message', msg);\n  }\n\n  Object.defineProperty(Assertion, 'includeStack', {\n    get: function() {\n      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');\n      return config.includeStack;\n    },\n    set: function(value) {\n      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');\n      config.includeStack = value;\n    }\n  });\n\n  Object.defineProperty(Assertion, 'showDiff', {\n    get: function() {\n      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');\n      return config.showDiff;\n    },\n    set: function(value) {\n      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');\n      config.showDiff = value;\n    }\n  });\n\n  Assertion.addProperty = function (name, fn) {\n    util.addProperty(this.prototype, name, fn);\n  };\n\n  Assertion.addMethod = function (name, fn) {\n    util.addMethod(this.prototype, name, fn);\n  };\n\n  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {\n    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);\n  };\n\n  Assertion.overwriteProperty = function (name, fn) {\n    util.overwriteProperty(this.prototype, name, fn);\n  };\n\n  Assertion.overwriteMethod = function (name, fn) {\n    util.overwriteMethod(this.prototype, name, fn);\n  };\n\n  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {\n    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);\n  };\n\n  /*!\n   * ### .assert(expression, message, negateMessage, expected, actual)\n   *\n   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.\n   *\n   * @name assert\n   * @param {Philosophical} expression to be tested\n   * @param {String or Function} message or function that returns message to display if fails\n   * @param {String or Function} negatedMessage or function that returns negatedMessage to display if negated expression fails\n   * @param {Mixed} expected value (remember to check for negation)\n   * @param {Mixed} actual (optional) will default to `this.obj`\n   * @api private\n   */\n\n  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {\n    var ok = util.test(this, arguments);\n    if (true !== showDiff) showDiff = false;\n    if (true !== config.showDiff) showDiff = false;\n\n    if (!ok) {\n      var msg = util.getMessage(this, arguments)\n        , actual = util.getActual(this, arguments);\n      throw new AssertionError(msg, {\n          actual: actual\n        , expected: expected\n        , showDiff: showDiff\n      }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));\n    }\n  };\n\n  /*!\n   * ### ._obj\n   *\n   * Quick reference to stored `actual` value for plugin developers.\n   *\n   * @api private\n   */\n\n  Object.defineProperty(Assertion.prototype, '_obj',\n    { get: function () {\n        return flag(this, 'object');\n      }\n    , set: function (val) {\n        flag(this, 'object', val);\n      }\n  });\n};\n\n});\n\nrequire.register(\"chai/lib/chai/config.js\", function (exports, module) {\nmodule.exports = {\n\n  /**\n   * ### config.includeStack\n   *\n   * User configurable property, influences whether stack trace\n   * is included in Assertion error message. Default of false\n   * suppresses stack trace in the error message.\n   *\n   *     chai.config.includeStack = true;  // enable stack on error\n   *\n   * @param {Boolean}\n   * @api public\n   */\n\n   includeStack: false,\n\n  /**\n   * ### config.showDiff\n   *\n   * User configurable property, influences whether or not\n   * the `showDiff` flag should be included in the thrown\n   * AssertionErrors. `false` will always be `false`; `true`\n   * will be true when the assertion has requested a diff\n   * be shown.\n   *\n   * @param {Boolean}\n   * @api public\n   */\n\n  showDiff: true,\n\n  /**\n   * ### config.truncateThreshold\n   *\n   * User configurable property, sets length threshold for actual and\n   * expected values in assertion errors. If this threshold is exceeded,\n   * the value is truncated.\n   *\n   * Set it to zero if you want to disable truncating altogether.\n   *\n   *     chai.config.truncateThreshold = 0;  // disable truncating\n   *\n   * @param {Number}\n   * @api public\n   */\n\n  truncateThreshold: 40\n\n};\n\n});\n\nrequire.register(\"chai/lib/chai/core/assertions.js\", function (exports, module) {\n/*!\n * chai\n * http://chaijs.com\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nmodule.exports = function (chai, _) {\n  var Assertion = chai.Assertion\n    , toString = Object.prototype.toString\n    , flag = _.flag;\n\n  /**\n   * ### Language Chains\n   *\n   * The following are provided as chainable getters to\n   * improve the readability of your assertions. They\n   * do not provide testing capabilities unless they\n   * have been overwritten by a plugin.\n   *\n   * **Chains**\n   *\n   * - to\n   * - be\n   * - been\n   * - is\n   * - that\n   * - which\n   * - and\n   * - has\n   * - have\n   * - with\n   * - at\n   * - of\n   * - same\n   *\n   * @name language chains\n   * @api public\n   */\n\n  [ 'to', 'be', 'been'\n  , 'is', 'and', 'has', 'have'\n  , 'with', 'that', 'which', 'at'\n  , 'of', 'same' ].forEach(function (chain) {\n    Assertion.addProperty(chain, function () {\n      return this;\n    });\n  });\n\n  /**\n   * ### .not\n   *\n   * Negates any of assertions following in the chain.\n   *\n   *     expect(foo).to.not.equal('bar');\n   *     expect(goodFn).to.not.throw(Error);\n   *     expect({ foo: 'baz' }).to.have.property('foo')\n   *       .and.not.equal('bar');\n   *\n   * @name not\n   * @api public\n   */\n\n  Assertion.addProperty('not', function () {\n    flag(this, 'negate', true);\n  });\n\n  /**\n   * ### .deep\n   *\n   * Sets the `deep` flag, later used by the `equal` and\n   * `property` assertions.\n   *\n   *     expect(foo).to.deep.equal({ bar: 'baz' });\n   *     expect({ foo: { bar: { baz: 'quux' } } })\n   *       .to.have.deep.property('foo.bar.baz', 'quux');\n   *\n   * @name deep\n   * @api public\n   */\n\n  Assertion.addProperty('deep', function () {\n    flag(this, 'deep', true);\n  });\n\n  /**\n   * ### .any\n   *\n   * Sets the `any` flag, (opposite of the `all` flag)\n   * later used in the `keys` assertion. \n   *\n   *     expect(foo).to.have.any.keys('bar', 'baz');\n   *\n   * @name any\n   * @api public\n   */\n\n  Assertion.addProperty('any', function () {\n    flag(this, 'any', true);\n    flag(this, 'all', false)\n  });\n\n\n  /**\n   * ### .all\n   *\n   * Sets the `all` flag (opposite of the `any` flag) \n   * later used by the `keys` assertion.\n   *\n   *     expect(foo).to.have.all.keys('bar', 'baz');\n   *\n   * @name all\n   * @api public\n   */\n\n  Assertion.addProperty('all', function () {\n    flag(this, 'all', true);\n    flag(this, 'any', false);\n  });\n\n  /**\n   * ### .a(type)\n   *\n   * The `a` and `an` assertions are aliases that can be\n   * used either as language chains or to assert a value's\n   * type.\n   *\n   *     // typeof\n   *     expect('test').to.be.a('string');\n   *     expect({ foo: 'bar' }).to.be.an('object');\n   *     expect(null).to.be.a('null');\n   *     expect(undefined).to.be.an('undefined');\n   *\n   *     // language chain\n   *     expect(foo).to.be.an.instanceof(Foo);\n   *\n   * @name a\n   * @alias an\n   * @param {String} type\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function an (type, msg) {\n    if (msg) flag(this, 'message', msg);\n    type = type.toLowerCase();\n    var obj = flag(this, 'object')\n      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';\n\n    this.assert(\n        type === _.type(obj)\n      , 'expected #{this} to be ' + article + type\n      , 'expected #{this} not to be ' + article + type\n    );\n  }\n\n  Assertion.addChainableMethod('an', an);\n  Assertion.addChainableMethod('a', an);\n\n  /**\n   * ### .include(value)\n   *\n   * The `include` and `contain` assertions can be used as either property\n   * based language chains or as methods to assert the inclusion of an object\n   * in an array or a substring in a string. When used as language chains,\n   * they toggle the `contains` flag for the `keys` assertion.\n   *\n   *     expect([1,2,3]).to.include(2);\n   *     expect('foobar').to.contain('foo');\n   *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');\n   *\n   * @name include\n   * @alias contain\n   * @alias includes\n   * @alias contains\n   * @param {Object|String|Number} obj\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function includeChainingBehavior () {\n    flag(this, 'contains', true);\n  }\n\n  function include (val, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    var expected = false;\n    if (_.type(obj) === 'array' && _.type(val) === 'object') {\n      for (var i in obj) {\n        if (_.eql(obj[i], val)) {\n          expected = true;\n          break;\n        }\n      }\n    } else if (_.type(val) === 'object') {\n      if (!flag(this, 'negate')) {\n        for (var k in val) new Assertion(obj).property(k, val[k]);\n        return;\n      }\n      var subset = {};\n      for (var k in val) subset[k] = obj[k];\n      expected = _.eql(subset, val);\n    } else {\n      expected = obj && ~obj.indexOf(val);\n    }\n    this.assert(\n        expected\n      , 'expected #{this} to include ' + _.inspect(val)\n      , 'expected #{this} to not include ' + _.inspect(val));\n  }\n\n  Assertion.addChainableMethod('include', include, includeChainingBehavior);\n  Assertion.addChainableMethod('contain', include, includeChainingBehavior);\n  Assertion.addChainableMethod('contains', include, includeChainingBehavior);\n  Assertion.addChainableMethod('includes', include, includeChainingBehavior);\n\n  /**\n   * ### .ok\n   *\n   * Asserts that the target is truthy.\n   *\n   *     expect('everthing').to.be.ok;\n   *     expect(1).to.be.ok;\n   *     expect(false).to.not.be.ok;\n   *     expect(undefined).to.not.be.ok;\n   *     expect(null).to.not.be.ok;\n   *\n   * @name ok\n   * @api public\n   */\n\n  Assertion.addProperty('ok', function () {\n    this.assert(\n        flag(this, 'object')\n      , 'expected #{this} to be truthy'\n      , 'expected #{this} to be falsy');\n  });\n\n  /**\n   * ### .true\n   *\n   * Asserts that the target is `true`.\n   *\n   *     expect(true).to.be.true;\n   *     expect(1).to.not.be.true;\n   *\n   * @name true\n   * @api public\n   */\n\n  Assertion.addProperty('true', function () {\n    this.assert(\n        true === flag(this, 'object')\n      , 'expected #{this} to be true'\n      , 'expected #{this} to be false'\n      , this.negate ? false : true\n    );\n  });\n\n  /**\n   * ### .false\n   *\n   * Asserts that the target is `false`.\n   *\n   *     expect(false).to.be.false;\n   *     expect(0).to.not.be.false;\n   *\n   * @name false\n   * @api public\n   */\n\n  Assertion.addProperty('false', function () {\n    this.assert(\n        false === flag(this, 'object')\n      , 'expected #{this} to be false'\n      , 'expected #{this} to be true'\n      , this.negate ? true : false\n    );\n  });\n\n  /**\n   * ### .null\n   *\n   * Asserts that the target is `null`.\n   *\n   *     expect(null).to.be.null;\n   *     expect(undefined).not.to.be.null;\n   *\n   * @name null\n   * @api public\n   */\n\n  Assertion.addProperty('null', function () {\n    this.assert(\n        null === flag(this, 'object')\n      , 'expected #{this} to be null'\n      , 'expected #{this} not to be null'\n    );\n  });\n\n  /**\n   * ### .undefined\n   *\n   * Asserts that the target is `undefined`.\n   *\n   *     expect(undefined).to.be.undefined;\n   *     expect(null).to.not.be.undefined;\n   *\n   * @name undefined\n   * @api public\n   */\n\n  Assertion.addProperty('undefined', function () {\n    this.assert(\n        undefined === flag(this, 'object')\n      , 'expected #{this} to be undefined'\n      , 'expected #{this} not to be undefined'\n    );\n  });\n\n  /**\n   * ### .exist\n   *\n   * Asserts that the target is neither `null` nor `undefined`.\n   *\n   *     var foo = 'hi'\n   *       , bar = null\n   *       , baz;\n   *\n   *     expect(foo).to.exist;\n   *     expect(bar).to.not.exist;\n   *     expect(baz).to.not.exist;\n   *\n   * @name exist\n   * @api public\n   */\n\n  Assertion.addProperty('exist', function () {\n    this.assert(\n        null != flag(this, 'object')\n      , 'expected #{this} to exist'\n      , 'expected #{this} to not exist'\n    );\n  });\n\n\n  /**\n   * ### .empty\n   *\n   * Asserts that the target's length is `0`. For arrays, it checks\n   * the `length` property. For objects, it gets the count of\n   * enumerable keys.\n   *\n   *     expect([]).to.be.empty;\n   *     expect('').to.be.empty;\n   *     expect({}).to.be.empty;\n   *\n   * @name empty\n   * @api public\n   */\n\n  Assertion.addProperty('empty', function () {\n    var obj = flag(this, 'object')\n      , expected = obj;\n\n    if (Array.isArray(obj) || 'string' === typeof object) {\n      expected = obj.length;\n    } else if (typeof obj === 'object') {\n      expected = Object.keys(obj).length;\n    }\n\n    this.assert(\n        !expected\n      , 'expected #{this} to be empty'\n      , 'expected #{this} not to be empty'\n    );\n  });\n\n  /**\n   * ### .arguments\n   *\n   * Asserts that the target is an arguments object.\n   *\n   *     function test () {\n   *       expect(arguments).to.be.arguments;\n   *     }\n   *\n   * @name arguments\n   * @alias Arguments\n   * @api public\n   */\n\n  function checkArguments () {\n    var obj = flag(this, 'object')\n      , type = Object.prototype.toString.call(obj);\n    this.assert(\n        '[object Arguments]' === type\n      , 'expected #{this} to be arguments but got ' + type\n      , 'expected #{this} to not be arguments'\n    );\n  }\n\n  Assertion.addProperty('arguments', checkArguments);\n  Assertion.addProperty('Arguments', checkArguments);\n\n  /**\n   * ### .equal(value)\n   *\n   * Asserts that the target is strictly equal (`===`) to `value`.\n   * Alternately, if the `deep` flag is set, asserts that\n   * the target is deeply equal to `value`.\n   *\n   *     expect('hello').to.equal('hello');\n   *     expect(42).to.equal(42);\n   *     expect(1).to.not.equal(true);\n   *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });\n   *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });\n   *\n   * @name equal\n   * @alias equals\n   * @alias eq\n   * @alias deep.equal\n   * @param {Mixed} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertEqual (val, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    if (flag(this, 'deep')) {\n      return this.eql(val);\n    } else {\n      this.assert(\n          val === obj\n        , 'expected #{this} to equal #{exp}'\n        , 'expected #{this} to not equal #{exp}'\n        , val\n        , this._obj\n        , true\n      );\n    }\n  }\n\n  Assertion.addMethod('equal', assertEqual);\n  Assertion.addMethod('equals', assertEqual);\n  Assertion.addMethod('eq', assertEqual);\n\n  /**\n   * ### .eql(value)\n   *\n   * Asserts that the target is deeply equal to `value`.\n   *\n   *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });\n   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);\n   *\n   * @name eql\n   * @alias eqls\n   * @param {Mixed} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertEql(obj, msg) {\n    if (msg) flag(this, 'message', msg);\n    this.assert(\n        _.eql(obj, flag(this, 'object'))\n      , 'expected #{this} to deeply equal #{exp}'\n      , 'expected #{this} to not deeply equal #{exp}'\n      , obj\n      , this._obj\n      , true\n    );\n  }\n\n  Assertion.addMethod('eql', assertEql);\n  Assertion.addMethod('eqls', assertEql);\n\n  /**\n   * ### .above(value)\n   *\n   * Asserts that the target is greater than `value`.\n   *\n   *     expect(10).to.be.above(5);\n   *\n   * Can also be used in conjunction with `length` to\n   * assert a minimum length. The benefit being a\n   * more informative error message than if the length\n   * was supplied directly.\n   *\n   *     expect('foo').to.have.length.above(2);\n   *     expect([ 1, 2, 3 ]).to.have.length.above(2);\n   *\n   * @name above\n   * @alias gt\n   * @alias greaterThan\n   * @param {Number} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertAbove (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    if (flag(this, 'doLength')) {\n      new Assertion(obj, msg).to.have.property('length');\n      var len = obj.length;\n      this.assert(\n          len > n\n        , 'expected #{this} to have a length above #{exp} but got #{act}'\n        , 'expected #{this} to not have a length above #{exp}'\n        , n\n        , len\n      );\n    } else {\n      this.assert(\n          obj > n\n        , 'expected #{this} to be above ' + n\n        , 'expected #{this} to be at most ' + n\n      );\n    }\n  }\n\n  Assertion.addMethod('above', assertAbove);\n  Assertion.addMethod('gt', assertAbove);\n  Assertion.addMethod('greaterThan', assertAbove);\n\n  /**\n   * ### .least(value)\n   *\n   * Asserts that the target is greater than or equal to `value`.\n   *\n   *     expect(10).to.be.at.least(10);\n   *\n   * Can also be used in conjunction with `length` to\n   * assert a minimum length. The benefit being a\n   * more informative error message than if the length\n   * was supplied directly.\n   *\n   *     expect('foo').to.have.length.of.at.least(2);\n   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);\n   *\n   * @name least\n   * @alias gte\n   * @param {Number} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertLeast (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    if (flag(this, 'doLength')) {\n      new Assertion(obj, msg).to.have.property('length');\n      var len = obj.length;\n      this.assert(\n          len >= n\n        , 'expected #{this} to have a length at least #{exp} but got #{act}'\n        , 'expected #{this} to have a length below #{exp}'\n        , n\n        , len\n      );\n    } else {\n      this.assert(\n          obj >= n\n        , 'expected #{this} to be at least ' + n\n        , 'expected #{this} to be below ' + n\n      );\n    }\n  }\n\n  Assertion.addMethod('least', assertLeast);\n  Assertion.addMethod('gte', assertLeast);\n\n  /**\n   * ### .below(value)\n   *\n   * Asserts that the target is less than `value`.\n   *\n   *     expect(5).to.be.below(10);\n   *\n   * Can also be used in conjunction with `length` to\n   * assert a maximum length. The benefit being a\n   * more informative error message than if the length\n   * was supplied directly.\n   *\n   *     expect('foo').to.have.length.below(4);\n   *     expect([ 1, 2, 3 ]).to.have.length.below(4);\n   *\n   * @name below\n   * @alias lt\n   * @alias lessThan\n   * @param {Number} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertBelow (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    if (flag(this, 'doLength')) {\n      new Assertion(obj, msg).to.have.property('length');\n      var len = obj.length;\n      this.assert(\n          len < n\n        , 'expected #{this} to have a length below #{exp} but got #{act}'\n        , 'expected #{this} to not have a length below #{exp}'\n        , n\n        , len\n      );\n    } else {\n      this.assert(\n          obj < n\n        , 'expected #{this} to be below ' + n\n        , 'expected #{this} to be at least ' + n\n      );\n    }\n  }\n\n  Assertion.addMethod('below', assertBelow);\n  Assertion.addMethod('lt', assertBelow);\n  Assertion.addMethod('lessThan', assertBelow);\n\n  /**\n   * ### .most(value)\n   *\n   * Asserts that the target is less than or equal to `value`.\n   *\n   *     expect(5).to.be.at.most(5);\n   *\n   * Can also be used in conjunction with `length` to\n   * assert a maximum length. The benefit being a\n   * more informative error message than if the length\n   * was supplied directly.\n   *\n   *     expect('foo').to.have.length.of.at.most(4);\n   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);\n   *\n   * @name most\n   * @alias lte\n   * @param {Number} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertMost (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    if (flag(this, 'doLength')) {\n      new Assertion(obj, msg).to.have.property('length');\n      var len = obj.length;\n      this.assert(\n          len <= n\n        , 'expected #{this} to have a length at most #{exp} but got #{act}'\n        , 'expected #{this} to have a length above #{exp}'\n        , n\n        , len\n      );\n    } else {\n      this.assert(\n          obj <= n\n        , 'expected #{this} to be at most ' + n\n        , 'expected #{this} to be above ' + n\n      );\n    }\n  }\n\n  Assertion.addMethod('most', assertMost);\n  Assertion.addMethod('lte', assertMost);\n\n  /**\n   * ### .within(start, finish)\n   *\n   * Asserts that the target is within a range.\n   *\n   *     expect(7).to.be.within(5,10);\n   *\n   * Can also be used in conjunction with `length` to\n   * assert a length range. The benefit being a\n   * more informative error message than if the length\n   * was supplied directly.\n   *\n   *     expect('foo').to.have.length.within(2,4);\n   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);\n   *\n   * @name within\n   * @param {Number} start lowerbound inclusive\n   * @param {Number} finish upperbound inclusive\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  Assertion.addMethod('within', function (start, finish, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , range = start + '..' + finish;\n    if (flag(this, 'doLength')) {\n      new Assertion(obj, msg).to.have.property('length');\n      var len = obj.length;\n      this.assert(\n          len >= start && len <= finish\n        , 'expected #{this} to have a length within ' + range\n        , 'expected #{this} to not have a length within ' + range\n      );\n    } else {\n      this.assert(\n          obj >= start && obj <= finish\n        , 'expected #{this} to be within ' + range\n        , 'expected #{this} to not be within ' + range\n      );\n    }\n  });\n\n  /**\n   * ### .instanceof(constructor)\n   *\n   * Asserts that the target is an instance of `constructor`.\n   *\n   *     var Tea = function (name) { this.name = name; }\n   *       , Chai = new Tea('chai');\n   *\n   *     expect(Chai).to.be.an.instanceof(Tea);\n   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);\n   *\n   * @name instanceof\n   * @param {Constructor} constructor\n   * @param {String} message _optional_\n   * @alias instanceOf\n   * @api public\n   */\n\n  function assertInstanceOf (constructor, msg) {\n    if (msg) flag(this, 'message', msg);\n    var name = _.getName(constructor);\n    this.assert(\n        flag(this, 'object') instanceof constructor\n      , 'expected #{this} to be an instance of ' + name\n      , 'expected #{this} to not be an instance of ' + name\n    );\n  };\n\n  Assertion.addMethod('instanceof', assertInstanceOf);\n  Assertion.addMethod('instanceOf', assertInstanceOf);\n\n  /**\n   * ### .property(name, [value])\n   *\n   * Asserts that the target has a property `name`, optionally asserting that\n   * the value of that property is strictly equal to  `value`.\n   * If the `deep` flag is set, you can use dot- and bracket-notation for deep\n   * references into objects and arrays.\n   *\n   *     // simple referencing\n   *     var obj = { foo: 'bar' };\n   *     expect(obj).to.have.property('foo');\n   *     expect(obj).to.have.property('foo', 'bar');\n   *\n   *     // deep referencing\n   *     var deepObj = {\n   *         green: { tea: 'matcha' }\n   *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]\n   *     };\n\n   *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');\n   *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');\n   *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');\n   *\n   * You can also use an array as the starting point of a `deep.property`\n   * assertion, or traverse nested arrays.\n   *\n   *     var arr = [\n   *         [ 'chai', 'matcha', 'konacha' ]\n   *       , [ { tea: 'chai' }\n   *         , { tea: 'matcha' }\n   *         , { tea: 'konacha' } ]\n   *     ];\n   *\n   *     expect(arr).to.have.deep.property('[0][1]', 'matcha');\n   *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');\n   *\n   * Furthermore, `property` changes the subject of the assertion\n   * to be the value of that property from the original object. This\n   * permits for further chainable assertions on that property.\n   *\n   *     expect(obj).to.have.property('foo')\n   *       .that.is.a('string');\n   *     expect(deepObj).to.have.property('green')\n   *       .that.is.an('object')\n   *       .that.deep.equals({ tea: 'matcha' });\n   *     expect(deepObj).to.have.property('teas')\n   *       .that.is.an('array')\n   *       .with.deep.property('[2]')\n   *         .that.deep.equals({ tea: 'konacha' });\n   *\n   * @name property\n   * @alias deep.property\n   * @param {String} name\n   * @param {Mixed} value (optional)\n   * @param {String} message _optional_\n   * @returns value of property for chaining\n   * @api public\n   */\n\n  Assertion.addMethod('property', function (name, val, msg) {\n    if (msg) flag(this, 'message', msg);\n\n    var isDeep = !!flag(this, 'deep')\n      , descriptor = isDeep ? 'deep property ' : 'property '\n      , negate = flag(this, 'negate')\n      , obj = flag(this, 'object')\n      , pathInfo = isDeep ? _.getPathInfo(name, obj) : null\n      , hasProperty = isDeep\n        ? pathInfo.exists\n        : _.hasProperty(name, obj)\n      , value = isDeep\n        ? pathInfo.value\n        : obj[name];\n\n    if (negate && undefined !== val) {\n      if (undefined === value) {\n        msg = (msg != null) ? msg + ': ' : '';\n        throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name));\n      }\n    } else {\n      this.assert(\n          hasProperty\n        , 'expected #{this} to have a ' + descriptor + _.inspect(name)\n        , 'expected #{this} to not have ' + descriptor + _.inspect(name));\n    }\n\n    if (undefined !== val) {\n      this.assert(\n          val === value\n        , 'expected #{this} to have a ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'\n        , 'expected #{this} to not have a ' + descriptor + _.inspect(name) + ' of #{act}'\n        , val\n        , value\n      );\n    }\n\n    flag(this, 'object', value);\n  });\n\n\n  /**\n   * ### .ownProperty(name)\n   *\n   * Asserts that the target has an own property `name`.\n   *\n   *     expect('test').to.have.ownProperty('length');\n   *\n   * @name ownProperty\n   * @alias haveOwnProperty\n   * @param {String} name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertOwnProperty (name, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    this.assert(\n        obj.hasOwnProperty(name)\n      , 'expected #{this} to have own property ' + _.inspect(name)\n      , 'expected #{this} to not have own property ' + _.inspect(name)\n    );\n  }\n\n  Assertion.addMethod('ownProperty', assertOwnProperty);\n  Assertion.addMethod('haveOwnProperty', assertOwnProperty);\n\n  /**\n   * ### .length(value)\n   *\n   * Asserts that the target's `length` property has\n   * the expected value.\n   *\n   *     expect([ 1, 2, 3]).to.have.length(3);\n   *     expect('foobar').to.have.length(6);\n   *\n   * Can also be used as a chain precursor to a value\n   * comparison for the length property.\n   *\n   *     expect('foo').to.have.length.above(2);\n   *     expect([ 1, 2, 3 ]).to.have.length.above(2);\n   *     expect('foo').to.have.length.below(4);\n   *     expect([ 1, 2, 3 ]).to.have.length.below(4);\n   *     expect('foo').to.have.length.within(2,4);\n   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);\n   *\n   * @name length\n   * @alias lengthOf\n   * @param {Number} length\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertLengthChain () {\n    flag(this, 'doLength', true);\n  }\n\n  function assertLength (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    new Assertion(obj, msg).to.have.property('length');\n    var len = obj.length;\n\n    this.assert(\n        len == n\n      , 'expected #{this} to have a length of #{exp} but got #{act}'\n      , 'expected #{this} to not have a length of #{act}'\n      , n\n      , len\n    );\n  }\n\n  Assertion.addChainableMethod('length', assertLength, assertLengthChain);\n  Assertion.addMethod('lengthOf', assertLength);\n\n  /**\n   * ### .match(regexp)\n   *\n   * Asserts that the target matches a regular expression.\n   *\n   *     expect('foobar').to.match(/^foo/);\n   *\n   * @name match\n   * @param {RegExp} RegularExpression\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  Assertion.addMethod('match', function (re, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    this.assert(\n        re.exec(obj)\n      , 'expected #{this} to match ' + re\n      , 'expected #{this} not to match ' + re\n    );\n  });\n\n  /**\n   * ### .string(string)\n   *\n   * Asserts that the string target contains another string.\n   *\n   *     expect('foobar').to.have.string('bar');\n   *\n   * @name string\n   * @param {String} string\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  Assertion.addMethod('string', function (str, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    new Assertion(obj, msg).is.a('string');\n\n    this.assert(\n        ~obj.indexOf(str)\n      , 'expected #{this} to contain ' + _.inspect(str)\n      , 'expected #{this} to not contain ' + _.inspect(str)\n    );\n  });\n\n\n  /**\n   * ### .keys(key1, [key2], [...])\n   *\n   * Asserts that the target contains any or all of the passed-in keys.\n   * Use in combination with `any`, `all`, `contains`, or `have` will affect \n   * what will pass.\n   * \n   * When used in conjunction with `any`, at least one key that is passed \n   * in must exist in the target object. This is regardless whether or not \n   * the `have` or `contain` qualifiers are used. Note, either `any` or `all`\n   * should be used in the assertion. If neither are used, the assertion is\n   * defaulted to `all`.\n   * \n   * When both `all` and `contain` are used, the target object must have at \n   * least all of the passed-in keys but may have more keys not listed.\n   * \n   * When both `all` and `have` are used, the target object must both contain\n   * all of the passed-in keys AND the number of keys in the target object must\n   * match the number of keys passed in (in other words, a target object must \n   * have all and only all of the passed-in keys).\n   * \n   *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo', 'baz');\n   *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo');\n   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys('bar', 'baz');\n   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys(['foo']);\n   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys({'foo': 6});\n   *     expect({ foo: 1, bar: 2 }).to.have.all.keys(['bar', 'foo']);\n   *     expect({ foo: 1, bar: 2 }).to.have.all.keys({'bar': 6, 'foo', 7});\n   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys(['bar', 'foo']);\n   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys([{'bar': 6}}]);\n   *\n   *\n   * @name keys\n   * @alias key\n   * @param {String...|Array|Object} keys\n   * @api public\n   */\n\n  function assertKeys (keys) {\n    var obj = flag(this, 'object')\n      , str\n      , ok = true\n      , mixedArgsMsg = 'keys must be given single argument of Array|Object|String, or multiple String arguments';\n\n    switch (_.type(keys)) {\n      case \"array\":\n        if (arguments.length > 1) throw (new Error(mixedArgsMsg));\n        break;\n      case \"object\":\n        if (arguments.length > 1) throw (new Error(mixedArgsMsg));\n        keys = Object.keys(keys);\n        break;\n      default:\n        keys = Array.prototype.slice.call(arguments);\n    }\n\n    if (!keys.length) throw new Error('keys required');\n\n    var actual = Object.keys(obj)\n      , expected = keys\n      , len = keys.length\n      , any = flag(this, 'any')\n      , all = flag(this, 'all');\n\n    if (!any && !all) {\n      all = true;\n    }\n\n    // Has any\n    if (any) {\n      var intersection = expected.filter(function(key) {\n        return ~actual.indexOf(key);\n      });\n      ok = intersection.length > 0;\n    }\n\n    // Has all\n    if (all) {\n      ok = keys.every(function(key){\n        return ~actual.indexOf(key);\n      });\n      if (!flag(this, 'negate') && !flag(this, 'contains')) {\n        ok = ok && keys.length == actual.length;\n      }\n    }\n\n    // Key string\n    if (len > 1) {\n      keys = keys.map(function(key){\n        return _.inspect(key);\n      });\n      var last = keys.pop();\n      if (all) {\n        str = keys.join(', ') + ', and ' + last;\n      }\n      if (any) {\n        str = keys.join(', ') + ', or ' + last;\n      }\n    } else {\n      str = _.inspect(keys[0]);\n    }\n\n    // Form\n    str = (len > 1 ? 'keys ' : 'key ') + str;\n\n    // Have / include\n    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;\n\n    // Assertion\n    this.assert(\n        ok\n      , 'expected #{this} to ' + str\n      , 'expected #{this} to not ' + str\n      , expected.slice(0).sort()\n      , actual.sort()\n      , true\n    );\n  }\n\n  Assertion.addMethod('keys', assertKeys);\n  Assertion.addMethod('key', assertKeys);\n\n  /**\n   * ### .throw(constructor)\n   *\n   * Asserts that the function target will throw a specific error, or specific type of error\n   * (as determined using `instanceof`), optionally with a RegExp or string inclusion test\n   * for the error's message.\n   *\n   *     var err = new ReferenceError('This is a bad function.');\n   *     var fn = function () { throw err; }\n   *     expect(fn).to.throw(ReferenceError);\n   *     expect(fn).to.throw(Error);\n   *     expect(fn).to.throw(/bad function/);\n   *     expect(fn).to.not.throw('good function');\n   *     expect(fn).to.throw(ReferenceError, /bad function/);\n   *     expect(fn).to.throw(err);\n   *     expect(fn).to.not.throw(new RangeError('Out of range.'));\n   *\n   * Please note that when a throw expectation is negated, it will check each\n   * parameter independently, starting with error constructor type. The appropriate way\n   * to check for the existence of a type of error but for a message that does not match\n   * is to use `and`.\n   *\n   *     expect(fn).to.throw(ReferenceError)\n   *        .and.not.throw(/good function/);\n   *\n   * @name throw\n   * @alias throws\n   * @alias Throw\n   * @param {ErrorConstructor} constructor\n   * @param {String|RegExp} expected error message\n   * @param {String} message _optional_\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n   * @returns error for chaining (null if no error)\n   * @api public\n   */\n\n  function assertThrows (constructor, errMsg, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    new Assertion(obj, msg).is.a('function');\n\n    var thrown = false\n      , desiredError = null\n      , name = null\n      , thrownError = null;\n\n    if (arguments.length === 0) {\n      errMsg = null;\n      constructor = null;\n    } else if (constructor && (constructor instanceof RegExp || 'string' === typeof constructor)) {\n      errMsg = constructor;\n      constructor = null;\n    } else if (constructor && constructor instanceof Error) {\n      desiredError = constructor;\n      constructor = null;\n      errMsg = null;\n    } else if (typeof constructor === 'function') {\n      name = constructor.prototype.name || constructor.name;\n      if (name === 'Error' && constructor !== Error) {\n        name = (new constructor()).name;\n      }\n    } else {\n      constructor = null;\n    }\n\n    try {\n      obj();\n    } catch (err) {\n      // first, check desired error\n      if (desiredError) {\n        this.assert(\n            err === desiredError\n          , 'expected #{this} to throw #{exp} but #{act} was thrown'\n          , 'expected #{this} to not throw #{exp}'\n          , (desiredError instanceof Error ? desiredError.toString() : desiredError)\n          , (err instanceof Error ? err.toString() : err)\n        );\n\n        flag(this, 'object', err);\n        return this;\n      }\n\n      // next, check constructor\n      if (constructor) {\n        this.assert(\n            err instanceof constructor\n          , 'expected #{this} to throw #{exp} but #{act} was thrown'\n          , 'expected #{this} to not throw #{exp} but #{act} was thrown'\n          , name\n          , (err instanceof Error ? err.toString() : err)\n        );\n\n        if (!errMsg) {\n          flag(this, 'object', err);\n          return this;\n        }\n      }\n\n      // next, check message\n      var message = 'object' === _.type(err) && \"message\" in err\n        ? err.message\n        : '' + err;\n\n      if ((message != null) && errMsg && errMsg instanceof RegExp) {\n        this.assert(\n            errMsg.exec(message)\n          , 'expected #{this} to throw error matching #{exp} but got #{act}'\n          , 'expected #{this} to throw error not matching #{exp}'\n          , errMsg\n          , message\n        );\n\n        flag(this, 'object', err);\n        return this;\n      } else if ((message != null) && errMsg && 'string' === typeof errMsg) {\n        this.assert(\n            ~message.indexOf(errMsg)\n          , 'expected #{this} to throw error including #{exp} but got #{act}'\n          , 'expected #{this} to throw error not including #{act}'\n          , errMsg\n          , message\n        );\n\n        flag(this, 'object', err);\n        return this;\n      } else {\n        thrown = true;\n        thrownError = err;\n      }\n    }\n\n    var actuallyGot = ''\n      , expectedThrown = name !== null\n        ? name\n        : desiredError\n          ? '#{exp}' //_.inspect(desiredError)\n          : 'an error';\n\n    if (thrown) {\n      actuallyGot = ' but #{act} was thrown'\n    }\n\n    this.assert(\n        thrown === true\n      , 'expected #{this} to throw ' + expectedThrown + actuallyGot\n      , 'expected #{this} to not throw ' + expectedThrown + actuallyGot\n      , (desiredError instanceof Error ? desiredError.toString() : desiredError)\n      , (thrownError instanceof Error ? thrownError.toString() : thrownError)\n    );\n\n    flag(this, 'object', thrownError);\n  };\n\n  Assertion.addMethod('throw', assertThrows);\n  Assertion.addMethod('throws', assertThrows);\n  Assertion.addMethod('Throw', assertThrows);\n\n  /**\n   * ### .respondTo(method)\n   *\n   * Asserts that the object or class target will respond to a method.\n   *\n   *     Klass.prototype.bar = function(){};\n   *     expect(Klass).to.respondTo('bar');\n   *     expect(obj).to.respondTo('bar');\n   *\n   * To check if a constructor will respond to a static function,\n   * set the `itself` flag.\n   *\n   *     Klass.baz = function(){};\n   *     expect(Klass).itself.to.respondTo('baz');\n   *\n   * @name respondTo\n   * @param {String} method\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  Assertion.addMethod('respondTo', function (method, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , itself = flag(this, 'itself')\n      , context = ('function' === _.type(obj) && !itself)\n        ? obj.prototype[method]\n        : obj[method];\n\n    this.assert(\n        'function' === typeof context\n      , 'expected #{this} to respond to ' + _.inspect(method)\n      , 'expected #{this} to not respond to ' + _.inspect(method)\n    );\n  });\n\n  /**\n   * ### .itself\n   *\n   * Sets the `itself` flag, later used by the `respondTo` assertion.\n   *\n   *     function Foo() {}\n   *     Foo.bar = function() {}\n   *     Foo.prototype.baz = function() {}\n   *\n   *     expect(Foo).itself.to.respondTo('bar');\n   *     expect(Foo).itself.not.to.respondTo('baz');\n   *\n   * @name itself\n   * @api public\n   */\n\n  Assertion.addProperty('itself', function () {\n    flag(this, 'itself', true);\n  });\n\n  /**\n   * ### .satisfy(method)\n   *\n   * Asserts that the target passes a given truth test.\n   *\n   *     expect(1).to.satisfy(function(num) { return num > 0; });\n   *\n   * @name satisfy\n   * @param {Function} matcher\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  Assertion.addMethod('satisfy', function (matcher, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    var result = matcher(obj);\n    this.assert(\n        result\n      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)\n      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)\n      , this.negate ? false : true\n      , result\n    );\n  });\n\n  /**\n   * ### .closeTo(expected, delta)\n   *\n   * Asserts that the target is equal `expected`, to within a +/- `delta` range.\n   *\n   *     expect(1.5).to.be.closeTo(1, 0.5);\n   *\n   * @name closeTo\n   * @param {Number} expected\n   * @param {Number} delta\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  Assertion.addMethod('closeTo', function (expected, delta, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n\n    new Assertion(obj, msg).is.a('number');\n    if (_.type(expected) !== 'number' || _.type(delta) !== 'number') {\n      throw new Error('the arguments to closeTo must be numbers');\n    }\n\n    this.assert(\n        Math.abs(obj - expected) <= delta\n      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta\n      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta\n    );\n  });\n\n  function isSubsetOf(subset, superset, cmp) {\n    return subset.every(function(elem) {\n      if (!cmp) return superset.indexOf(elem) !== -1;\n\n      return superset.some(function(elem2) {\n        return cmp(elem, elem2);\n      });\n    })\n  }\n\n  /**\n   * ### .members(set)\n   *\n   * Asserts that the target is a superset of `set`,\n   * or that the target and `set` have the same strictly-equal (===) members.\n   * Alternately, if the `deep` flag is set, set members are compared for deep\n   * equality.\n   *\n   *     expect([1, 2, 3]).to.include.members([3, 2]);\n   *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);\n   *\n   *     expect([4, 2]).to.have.members([2, 4]);\n   *     expect([5, 2]).to.not.have.members([5, 2, 1]);\n   *\n   *     expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);\n   *\n   * @name members\n   * @param {Array} set\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  Assertion.addMethod('members', function (subset, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n\n    new Assertion(obj).to.be.an('array');\n    new Assertion(subset).to.be.an('array');\n\n    var cmp = flag(this, 'deep') ? _.eql : undefined;\n\n    if (flag(this, 'contains')) {\n      return this.assert(\n          isSubsetOf(subset, obj, cmp)\n        , 'expected #{this} to be a superset of #{act}'\n        , 'expected #{this} to not be a superset of #{act}'\n        , obj\n        , subset\n      );\n    }\n\n    this.assert(\n        isSubsetOf(obj, subset, cmp) && isSubsetOf(subset, obj, cmp)\n        , 'expected #{this} to have the same members as #{act}'\n        , 'expected #{this} to not have the same members as #{act}'\n        , obj\n        , subset\n    );\n  });\n\n  /**\n   * ### .change(function)\n   *\n   * Asserts that a function changes an object property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val += 3 };\n   *     var noChangeFn = function() { return 'foo' + 'bar'; }\n   *     expect(fn).to.change(obj, 'val');\n   *     expect(noChangFn).to.not.change(obj, 'val')\n   *\n   * @name change\n   * @alias changes\n   * @alias Change\n   * @param {String} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertChanges (object, prop, msg) {\n    if (msg) flag(this, 'message', msg);\n    var fn = flag(this, 'object');\n    new Assertion(object, msg).to.have.property(prop);\n    new Assertion(fn).is.a('function');\n\n    var initial = object[prop];\n    fn();\n\n    this.assert(\n      initial !== object[prop]\n      , 'expected .' + prop + ' to change'\n      , 'expected .' + prop + ' to not change'\n    );\n  }\n\n  Assertion.addChainableMethod('change', assertChanges);\n  Assertion.addChainableMethod('changes', assertChanges);\n\n  /**\n   * ### .increase(function)\n   *\n   * Asserts that a function increases an object property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 15 };\n   *     expect(fn).to.increase(obj, 'val');\n   *\n   * @name increase\n   * @alias increases\n   * @alias Increase\n   * @param {String} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertIncreases (object, prop, msg) {\n    if (msg) flag(this, 'message', msg);\n    var fn = flag(this, 'object');\n    new Assertion(object, msg).to.have.property(prop);\n    new Assertion(fn).is.a('function');\n\n    var initial = object[prop];\n    fn();\n\n    this.assert(\n      object[prop] - initial > 0\n      , 'expected .' + prop + ' to increase'\n      , 'expected .' + prop + ' to not increase'\n    );\n  }\n\n  Assertion.addChainableMethod('increase', assertIncreases);\n  Assertion.addChainableMethod('increases', assertIncreases);\n\n  /**\n   * ### .decrease(function)\n   *\n   * Asserts that a function decreases an object property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 5 };\n   *     expect(fn).to.decrease(obj, 'val');\n   *\n   * @name decrease\n   * @alias decreases\n   * @alias Decrease\n   * @param {String} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertDecreases (object, prop, msg) {\n    if (msg) flag(this, 'message', msg);\n    var fn = flag(this, 'object');\n    new Assertion(object, msg).to.have.property(prop);\n    new Assertion(fn).is.a('function');\n\n    var initial = object[prop];\n    fn();\n\n    this.assert(\n      object[prop] - initial < 0\n      , 'expected .' + prop + ' to decrease'\n      , 'expected .' + prop + ' to not decrease'\n    );\n  }\n\n  Assertion.addChainableMethod('decrease', assertDecreases);\n  Assertion.addChainableMethod('decreases', assertDecreases);\n\n};\n\n});\n\nrequire.register(\"chai/lib/chai/interface/assert.js\", function (exports, module) {\n/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n\nmodule.exports = function (chai, util) {\n\n  /*!\n   * Chai dependencies.\n   */\n\n  var Assertion = chai.Assertion\n    , flag = util.flag;\n\n  /*!\n   * Module export.\n   */\n\n  /**\n   * ### assert(expression, message)\n   *\n   * Write your own test expressions.\n   *\n   *     assert('foo' !== 'bar', 'foo is not bar');\n   *     assert(Array.isArray([]), 'empty arrays are arrays');\n   *\n   * @param {Mixed} expression to test for truthiness\n   * @param {String} message to display on error\n   * @name assert\n   * @api public\n   */\n\n  var assert = chai.assert = function (express, errmsg) {\n    var test = new Assertion(null, null, chai.assert);\n    test.assert(\n        express\n      , errmsg\n      , '[ negation message unavailable ]'\n    );\n  };\n\n  /**\n   * ### .fail(actual, expected, [message], [operator])\n   *\n   * Throw a failure. Node.js `assert` module-compatible.\n   *\n   * @name fail\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @param {String} operator\n   * @api public\n   */\n\n  assert.fail = function (actual, expected, message, operator) {\n    message = message || 'assert.fail()';\n    throw new chai.AssertionError(message, {\n        actual: actual\n      , expected: expected\n      , operator: operator\n    }, assert.fail);\n  };\n\n  /**\n   * ### .ok(object, [message])\n   *\n   * Asserts that `object` is truthy.\n   *\n   *     assert.ok('everything', 'everything is ok');\n   *     assert.ok(false, 'this will fail');\n   *\n   * @name ok\n   * @param {Mixed} object to test\n   * @param {String} message\n   * @api public\n   */\n\n  assert.ok = function (val, msg) {\n    new Assertion(val, msg).is.ok;\n  };\n\n  /**\n   * ### .notOk(object, [message])\n   *\n   * Asserts that `object` is falsy.\n   *\n   *     assert.notOk('everything', 'this will fail');\n   *     assert.notOk(false, 'this will pass');\n   *\n   * @name notOk\n   * @param {Mixed} object to test\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notOk = function (val, msg) {\n    new Assertion(val, msg).is.not.ok;\n  };\n\n  /**\n   * ### .equal(actual, expected, [message])\n   *\n   * Asserts non-strict equality (`==`) of `actual` and `expected`.\n   *\n   *     assert.equal(3, '3', '== coerces values to strings');\n   *\n   * @name equal\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.equal = function (act, exp, msg) {\n    var test = new Assertion(act, msg, assert.equal);\n\n    test.assert(\n        exp == flag(test, 'object')\n      , 'expected #{this} to equal #{exp}'\n      , 'expected #{this} to not equal #{act}'\n      , exp\n      , act\n    );\n  };\n\n  /**\n   * ### .notEqual(actual, expected, [message])\n   *\n   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.\n   *\n   *     assert.notEqual(3, 4, 'these numbers are not equal');\n   *\n   * @name notEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notEqual = function (act, exp, msg) {\n    var test = new Assertion(act, msg, assert.notEqual);\n\n    test.assert(\n        exp != flag(test, 'object')\n      , 'expected #{this} to not equal #{exp}'\n      , 'expected #{this} to equal #{act}'\n      , exp\n      , act\n    );\n  };\n\n  /**\n   * ### .strictEqual(actual, expected, [message])\n   *\n   * Asserts strict equality (`===`) of `actual` and `expected`.\n   *\n   *     assert.strictEqual(true, true, 'these booleans are strictly equal');\n   *\n   * @name strictEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.strictEqual = function (act, exp, msg) {\n    new Assertion(act, msg).to.equal(exp);\n  };\n\n  /**\n   * ### .notStrictEqual(actual, expected, [message])\n   *\n   * Asserts strict inequality (`!==`) of `actual` and `expected`.\n   *\n   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');\n   *\n   * @name notStrictEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notStrictEqual = function (act, exp, msg) {\n    new Assertion(act, msg).to.not.equal(exp);\n  };\n\n  /**\n   * ### .deepEqual(actual, expected, [message])\n   *\n   * Asserts that `actual` is deeply equal to `expected`.\n   *\n   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });\n   *\n   * @name deepEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.deepEqual = function (act, exp, msg) {\n    new Assertion(act, msg).to.eql(exp);\n  };\n\n  /**\n   * ### .notDeepEqual(actual, expected, [message])\n   *\n   * Assert that `actual` is not deeply equal to `expected`.\n   *\n   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });\n   *\n   * @name notDeepEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notDeepEqual = function (act, exp, msg) {\n    new Assertion(act, msg).to.not.eql(exp);\n  };\n\n  /**\n   * ### .isTrue(value, [message])\n   *\n   * Asserts that `value` is true.\n   *\n   *     var teaServed = true;\n   *     assert.isTrue(teaServed, 'the tea has been served');\n   *\n   * @name isTrue\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isAbove = function (val, abv, msg) {\n    new Assertion(val, msg).to.be.above(abv);\n  };\n\n   /**\n   * ### .isAbove(valueToCheck, valueToBeAbove, [message])\n   *\n   * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`\n   *\n   *     assert.isAbove(5, 2, '5 is strictly greater than 2');\n   *\n   * @name isAbove\n   * @param {Mixed} valueToCheck\n   * @param {Mixed} valueToBeAbove\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isBelow = function (val, blw, msg) {\n    new Assertion(val, msg).to.be.below(blw);\n  };\n\n   /**\n   * ### .isBelow(valueToCheck, valueToBeBelow, [message])\n   *\n   * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`\n   *\n   *     assert.isBelow(3, 6, '3 is strictly less than 6');\n   *\n   * @name isBelow\n   * @param {Mixed} valueToCheck\n   * @param {Mixed} valueToBeBelow\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isTrue = function (val, msg) {\n    new Assertion(val, msg).is['true'];\n  };\n\n  /**\n   * ### .isFalse(value, [message])\n   *\n   * Asserts that `value` is false.\n   *\n   *     var teaServed = false;\n   *     assert.isFalse(teaServed, 'no tea yet? hmm...');\n   *\n   * @name isFalse\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isFalse = function (val, msg) {\n    new Assertion(val, msg).is['false'];\n  };\n\n  /**\n   * ### .isNull(value, [message])\n   *\n   * Asserts that `value` is null.\n   *\n   *     assert.isNull(err, 'there was no error');\n   *\n   * @name isNull\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNull = function (val, msg) {\n    new Assertion(val, msg).to.equal(null);\n  };\n\n  /**\n   * ### .isNotNull(value, [message])\n   *\n   * Asserts that `value` is not null.\n   *\n   *     var tea = 'tasty chai';\n   *     assert.isNotNull(tea, 'great, time for tea!');\n   *\n   * @name isNotNull\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotNull = function (val, msg) {\n    new Assertion(val, msg).to.not.equal(null);\n  };\n\n  /**\n   * ### .isUndefined(value, [message])\n   *\n   * Asserts that `value` is `undefined`.\n   *\n   *     var tea;\n   *     assert.isUndefined(tea, 'no tea defined');\n   *\n   * @name isUndefined\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isUndefined = function (val, msg) {\n    new Assertion(val, msg).to.equal(undefined);\n  };\n\n  /**\n   * ### .isDefined(value, [message])\n   *\n   * Asserts that `value` is not `undefined`.\n   *\n   *     var tea = 'cup of chai';\n   *     assert.isDefined(tea, 'tea has been defined');\n   *\n   * @name isDefined\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isDefined = function (val, msg) {\n    new Assertion(val, msg).to.not.equal(undefined);\n  };\n\n  /**\n   * ### .isFunction(value, [message])\n   *\n   * Asserts that `value` is a function.\n   *\n   *     function serveTea() { return 'cup of tea'; };\n   *     assert.isFunction(serveTea, 'great, we can have tea now');\n   *\n   * @name isFunction\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isFunction = function (val, msg) {\n    new Assertion(val, msg).to.be.a('function');\n  };\n\n  /**\n   * ### .isNotFunction(value, [message])\n   *\n   * Asserts that `value` is _not_ a function.\n   *\n   *     var serveTea = [ 'heat', 'pour', 'sip' ];\n   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');\n   *\n   * @name isNotFunction\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotFunction = function (val, msg) {\n    new Assertion(val, msg).to.not.be.a('function');\n  };\n\n  /**\n   * ### .isObject(value, [message])\n   *\n   * Asserts that `value` is an object (as revealed by\n   * `Object.prototype.toString`).\n   *\n   *     var selection = { name: 'Chai', serve: 'with spices' };\n   *     assert.isObject(selection, 'tea selection is an object');\n   *\n   * @name isObject\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isObject = function (val, msg) {\n    new Assertion(val, msg).to.be.a('object');\n  };\n\n  /**\n   * ### .isNotObject(value, [message])\n   *\n   * Asserts that `value` is _not_ an object.\n   *\n   *     var selection = 'chai'\n   *     assert.isNotObject(selection, 'tea selection is not an object');\n   *     assert.isNotObject(null, 'null is not an object');\n   *\n   * @name isNotObject\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotObject = function (val, msg) {\n    new Assertion(val, msg).to.not.be.a('object');\n  };\n\n  /**\n   * ### .isArray(value, [message])\n   *\n   * Asserts that `value` is an array.\n   *\n   *     var menu = [ 'green', 'chai', 'oolong' ];\n   *     assert.isArray(menu, 'what kind of tea do we want?');\n   *\n   * @name isArray\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isArray = function (val, msg) {\n    new Assertion(val, msg).to.be.an('array');\n  };\n\n  /**\n   * ### .isNotArray(value, [message])\n   *\n   * Asserts that `value` is _not_ an array.\n   *\n   *     var menu = 'green|chai|oolong';\n   *     assert.isNotArray(menu, 'what kind of tea do we want?');\n   *\n   * @name isNotArray\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotArray = function (val, msg) {\n    new Assertion(val, msg).to.not.be.an('array');\n  };\n\n  /**\n   * ### .isString(value, [message])\n   *\n   * Asserts that `value` is a string.\n   *\n   *     var teaOrder = 'chai';\n   *     assert.isString(teaOrder, 'order placed');\n   *\n   * @name isString\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isString = function (val, msg) {\n    new Assertion(val, msg).to.be.a('string');\n  };\n\n  /**\n   * ### .isNotString(value, [message])\n   *\n   * Asserts that `value` is _not_ a string.\n   *\n   *     var teaOrder = 4;\n   *     assert.isNotString(teaOrder, 'order placed');\n   *\n   * @name isNotString\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotString = function (val, msg) {\n    new Assertion(val, msg).to.not.be.a('string');\n  };\n\n  /**\n   * ### .isNumber(value, [message])\n   *\n   * Asserts that `value` is a number.\n   *\n   *     var cups = 2;\n   *     assert.isNumber(cups, 'how many cups');\n   *\n   * @name isNumber\n   * @param {Number} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNumber = function (val, msg) {\n    new Assertion(val, msg).to.be.a('number');\n  };\n\n  /**\n   * ### .isNotNumber(value, [message])\n   *\n   * Asserts that `value` is _not_ a number.\n   *\n   *     var cups = '2 cups please';\n   *     assert.isNotNumber(cups, 'how many cups');\n   *\n   * @name isNotNumber\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotNumber = function (val, msg) {\n    new Assertion(val, msg).to.not.be.a('number');\n  };\n\n  /**\n   * ### .isBoolean(value, [message])\n   *\n   * Asserts that `value` is a boolean.\n   *\n   *     var teaReady = true\n   *       , teaServed = false;\n   *\n   *     assert.isBoolean(teaReady, 'is the tea ready');\n   *     assert.isBoolean(teaServed, 'has tea been served');\n   *\n   * @name isBoolean\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isBoolean = function (val, msg) {\n    new Assertion(val, msg).to.be.a('boolean');\n  };\n\n  /**\n   * ### .isNotBoolean(value, [message])\n   *\n   * Asserts that `value` is _not_ a boolean.\n   *\n   *     var teaReady = 'yep'\n   *       , teaServed = 'nope';\n   *\n   *     assert.isNotBoolean(teaReady, 'is the tea ready');\n   *     assert.isNotBoolean(teaServed, 'has tea been served');\n   *\n   * @name isNotBoolean\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotBoolean = function (val, msg) {\n    new Assertion(val, msg).to.not.be.a('boolean');\n  };\n\n  /**\n   * ### .typeOf(value, name, [message])\n   *\n   * Asserts that `value`'s type is `name`, as determined by\n   * `Object.prototype.toString`.\n   *\n   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');\n   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');\n   *     assert.typeOf('tea', 'string', 'we have a string');\n   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');\n   *     assert.typeOf(null, 'null', 'we have a null');\n   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');\n   *\n   * @name typeOf\n   * @param {Mixed} value\n   * @param {String} name\n   * @param {String} message\n   * @api public\n   */\n\n  assert.typeOf = function (val, type, msg) {\n    new Assertion(val, msg).to.be.a(type);\n  };\n\n  /**\n   * ### .notTypeOf(value, name, [message])\n   *\n   * Asserts that `value`'s type is _not_ `name`, as determined by\n   * `Object.prototype.toString`.\n   *\n   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');\n   *\n   * @name notTypeOf\n   * @param {Mixed} value\n   * @param {String} typeof name\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notTypeOf = function (val, type, msg) {\n    new Assertion(val, msg).to.not.be.a(type);\n  };\n\n  /**\n   * ### .instanceOf(object, constructor, [message])\n   *\n   * Asserts that `value` is an instance of `constructor`.\n   *\n   *     var Tea = function (name) { this.name = name; }\n   *       , chai = new Tea('chai');\n   *\n   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');\n   *\n   * @name instanceOf\n   * @param {Object} object\n   * @param {Constructor} constructor\n   * @param {String} message\n   * @api public\n   */\n\n  assert.instanceOf = function (val, type, msg) {\n    new Assertion(val, msg).to.be.instanceOf(type);\n  };\n\n  /**\n   * ### .notInstanceOf(object, constructor, [message])\n   *\n   * Asserts `value` is not an instance of `constructor`.\n   *\n   *     var Tea = function (name) { this.name = name; }\n   *       , chai = new String('chai');\n   *\n   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');\n   *\n   * @name notInstanceOf\n   * @param {Object} object\n   * @param {Constructor} constructor\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notInstanceOf = function (val, type, msg) {\n    new Assertion(val, msg).to.not.be.instanceOf(type);\n  };\n\n  /**\n   * ### .include(haystack, needle, [message])\n   *\n   * Asserts that `haystack` includes `needle`. Works\n   * for strings and arrays.\n   *\n   *     assert.include('foobar', 'bar', 'foobar contains string \"bar\"');\n   *     assert.include([ 1, 2, 3 ], 3, 'array contains value');\n   *\n   * @name include\n   * @param {Array|String} haystack\n   * @param {Mixed} needle\n   * @param {String} message\n   * @api public\n   */\n\n  assert.include = function (exp, inc, msg) {\n    new Assertion(exp, msg, assert.include).include(inc);\n  };\n\n  /**\n   * ### .notInclude(haystack, needle, [message])\n   *\n   * Asserts that `haystack` does not include `needle`. Works\n   * for strings and arrays.\n   *i\n   *     assert.notInclude('foobar', 'baz', 'string not include substring');\n   *     assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');\n   *\n   * @name notInclude\n   * @param {Array|String} haystack\n   * @param {Mixed} needle\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notInclude = function (exp, inc, msg) {\n    new Assertion(exp, msg, assert.notInclude).not.include(inc);\n  };\n\n  /**\n   * ### .match(value, regexp, [message])\n   *\n   * Asserts that `value` matches the regular expression `regexp`.\n   *\n   *     assert.match('foobar', /^foo/, 'regexp matches');\n   *\n   * @name match\n   * @param {Mixed} value\n   * @param {RegExp} regexp\n   * @param {String} message\n   * @api public\n   */\n\n  assert.match = function (exp, re, msg) {\n    new Assertion(exp, msg).to.match(re);\n  };\n\n  /**\n   * ### .notMatch(value, regexp, [message])\n   *\n   * Asserts that `value` does not match the regular expression `regexp`.\n   *\n   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');\n   *\n   * @name notMatch\n   * @param {Mixed} value\n   * @param {RegExp} regexp\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notMatch = function (exp, re, msg) {\n    new Assertion(exp, msg).to.not.match(re);\n  };\n\n  /**\n   * ### .property(object, property, [message])\n   *\n   * Asserts that `object` has a property named by `property`.\n   *\n   *     assert.property({ tea: { green: 'matcha' }}, 'tea');\n   *\n   * @name property\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @api public\n   */\n\n  assert.property = function (obj, prop, msg) {\n    new Assertion(obj, msg).to.have.property(prop);\n  };\n\n  /**\n   * ### .notProperty(object, property, [message])\n   *\n   * Asserts that `object` does _not_ have a property named by `property`.\n   *\n   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');\n   *\n   * @name notProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg).to.not.have.property(prop);\n  };\n\n  /**\n   * ### .deepProperty(object, property, [message])\n   *\n   * Asserts that `object` has a property named by `property`, which can be a\n   * string using dot- and bracket-notation for deep reference.\n   *\n   *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');\n   *\n   * @name deepProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @api public\n   */\n\n  assert.deepProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg).to.have.deep.property(prop);\n  };\n\n  /**\n   * ### .notDeepProperty(object, property, [message])\n   *\n   * Asserts that `object` does _not_ have a property named by `property`, which\n   * can be a string using dot- and bracket-notation for deep reference.\n   *\n   *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');\n   *\n   * @name notDeepProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notDeepProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg).to.not.have.deep.property(prop);\n  };\n\n  /**\n   * ### .propertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a property named by `property` with value given\n   * by `value`.\n   *\n   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');\n   *\n   * @name propertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.propertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg).to.have.property(prop, val);\n  };\n\n  /**\n   * ### .propertyNotVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a property named by `property`, but with a value\n   * different from that given by `value`.\n   *\n   *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');\n   *\n   * @name propertyNotVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.propertyNotVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg).to.not.have.property(prop, val);\n  };\n\n  /**\n   * ### .deepPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a property named by `property` with value given\n   * by `value`. `property` can use dot- and bracket-notation for deep\n   * reference.\n   *\n   *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');\n   *\n   * @name deepPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.deepPropertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg).to.have.deep.property(prop, val);\n  };\n\n  /**\n   * ### .deepPropertyNotVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a property named by `property`, but with a value\n   * different from that given by `value`. `property` can use dot- and\n   * bracket-notation for deep reference.\n   *\n   *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');\n   *\n   * @name deepPropertyNotVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.deepPropertyNotVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg).to.not.have.deep.property(prop, val);\n  };\n\n  /**\n   * ### .lengthOf(object, length, [message])\n   *\n   * Asserts that `object` has a `length` property with the expected value.\n   *\n   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');\n   *     assert.lengthOf('foobar', 5, 'string has length of 6');\n   *\n   * @name lengthOf\n   * @param {Mixed} object\n   * @param {Number} length\n   * @param {String} message\n   * @api public\n   */\n\n  assert.lengthOf = function (exp, len, msg) {\n    new Assertion(exp, msg).to.have.length(len);\n  };\n\n  /**\n   * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])\n   *\n   * Asserts that `function` will throw an error that is an instance of\n   * `constructor`, or alternately that it will throw an error with message\n   * matching `regexp`.\n   *\n   *     assert.throw(fn, 'function throws a reference error');\n   *     assert.throw(fn, /function throws a reference error/);\n   *     assert.throw(fn, ReferenceError);\n   *     assert.throw(fn, ReferenceError, 'function throws a reference error');\n   *     assert.throw(fn, ReferenceError, /function throws a reference error/);\n   *\n   * @name throws\n   * @alias throw\n   * @alias Throw\n   * @param {Function} function\n   * @param {ErrorConstructor} constructor\n   * @param {RegExp} regexp\n   * @param {String} message\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n   * @api public\n   */\n\n  assert.Throw = function (fn, errt, errs, msg) {\n    if ('string' === typeof errt || errt instanceof RegExp) {\n      errs = errt;\n      errt = null;\n    }\n\n    var assertErr = new Assertion(fn, msg).to.Throw(errt, errs);\n    return flag(assertErr, 'object');\n  };\n\n  /**\n   * ### .doesNotThrow(function, [constructor/regexp], [message])\n   *\n   * Asserts that `function` will _not_ throw an error that is an instance of\n   * `constructor`, or alternately that it will not throw an error with message\n   * matching `regexp`.\n   *\n   *     assert.doesNotThrow(fn, Error, 'function does not throw');\n   *\n   * @name doesNotThrow\n   * @param {Function} function\n   * @param {ErrorConstructor} constructor\n   * @param {RegExp} regexp\n   * @param {String} message\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n   * @api public\n   */\n\n  assert.doesNotThrow = function (fn, type, msg) {\n    if ('string' === typeof type) {\n      msg = type;\n      type = null;\n    }\n\n    new Assertion(fn, msg).to.not.Throw(type);\n  };\n\n  /**\n   * ### .operator(val1, operator, val2, [message])\n   *\n   * Compares two values using `operator`.\n   *\n   *     assert.operator(1, '<', 2, 'everything is ok');\n   *     assert.operator(1, '>', 2, 'this will fail');\n   *\n   * @name operator\n   * @param {Mixed} val1\n   * @param {String} operator\n   * @param {Mixed} val2\n   * @param {String} message\n   * @api public\n   */\n\n  assert.operator = function (val, operator, val2, msg) {\n    if (!~['==', '===', '>', '>=', '<', '<=', '!=', '!=='].indexOf(operator)) {\n      throw new Error('Invalid operator \"' + operator + '\"');\n    }\n    var test = new Assertion(eval(val + operator + val2), msg);\n    test.assert(\n        true === flag(test, 'object')\n      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)\n      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );\n  };\n\n  /**\n   * ### .closeTo(actual, expected, delta, [message])\n   *\n   * Asserts that the target is equal `expected`, to within a +/- `delta` range.\n   *\n   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');\n   *\n   * @name closeTo\n   * @param {Number} actual\n   * @param {Number} expected\n   * @param {Number} delta\n   * @param {String} message\n   * @api public\n   */\n\n  assert.closeTo = function (act, exp, delta, msg) {\n    new Assertion(act, msg).to.be.closeTo(exp, delta);\n  };\n\n  /**\n   * ### .sameMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` have the same members.\n   * Order is not taken into account.\n   *\n   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');\n   *\n   * @name sameMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @api public\n   */\n\n  assert.sameMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg).to.have.same.members(set2);\n  }\n\n  /**\n   * ### .sameDeepMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` have the same members - using a deep equality checking.\n   * Order is not taken into account.\n   *\n   *     assert.sameDeepMembers([ {b: 3}, {a: 2}, {c: 5} ], [ {c: 5}, {b: 3}, {a: 2} ], 'same deep members');\n   *\n   * @name sameDeepMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @api public\n   */\n\n  assert.sameDeepMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg).to.have.same.deep.members(set2);\n  }\n\n  /**\n   * ### .includeMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` is included in `superset`.\n   * Order is not taken into account.\n   *\n   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');\n   *\n   * @name includeMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @api public\n   */\n\n  assert.includeMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg).to.include.members(subset);\n  }\n\n   /**\n   * ### .changes(function, object, property)\n   *\n   * Asserts that a function changes the value of a property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 22 };\n   *     assert.changes(fn, obj, 'val');\n   *\n   * @name changes\n   * @param {Function} modifier function\n   * @param {Object} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.changes = function (fn, obj, prop) {\n    new Assertion(fn).to.change(obj, prop);\n  }\n\n   /**\n   * ### .doesNotChange(function, object, property)\n   *\n   * Asserts that a function does not changes the value of a property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { console.log('foo'); };\n   *     assert.doesNotChange(fn, obj, 'val');\n   *\n   * @name doesNotChange\n   * @param {Function} modifier function\n   * @param {Object} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.doesNotChange = function (fn, obj, prop) {\n    new Assertion(fn).to.not.change(obj, prop);\n  }\n\n   /**\n   * ### .increases(function, object, property)\n   *\n   * Asserts that a function increases an object property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 13 };\n   *     assert.increases(fn, obj, 'val');\n   *\n   * @name increases\n   * @param {Function} modifier function\n   * @param {Object} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.increases = function (fn, obj, prop) {\n    new Assertion(fn).to.increase(obj, prop);\n  }\n\n   /**\n   * ### .doesNotIncrease(function, object, property)\n   *\n   * Asserts that a function does not increase object property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 8 };\n   *     assert.doesNotIncrease(fn, obj, 'val');\n   *\n   * @name doesNotIncrease\n   * @param {Function} modifier function\n   * @param {Object} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.doesNotIncrease = function (fn, obj, prop) {\n    new Assertion(fn).to.not.increase(obj, prop);\n  }\n\n   /**\n   * ### .decreases(function, object, property)\n   *\n   * Asserts that a function decreases an object property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 5 };\n   *     assert.decreases(fn, obj, 'val');\n   *\n   * @name decreases\n   * @param {Function} modifier function\n   * @param {Object} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.decreases = function (fn, obj, prop) {\n    new Assertion(fn).to.decrease(obj, prop);\n  }\n\n   /**\n   * ### .doesNotDecrease(function, object, property)\n   *\n   * Asserts that a function does not decreases an object property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 15 };\n   *     assert.doesNotDecrease(fn, obj, 'val');\n   *\n   * @name doesNotDecrease\n   * @param {Function} modifier function\n   * @param {Object} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.doesNotDecrease = function (fn, obj, prop) {\n    new Assertion(fn).to.not.decrease(obj, prop);\n  }\n\n  /*!\n   * Undocumented / untested\n   */\n\n  assert.ifError = function (val, msg) {\n    new Assertion(val, msg).to.not.be.ok;\n  };\n\n  /*!\n   * Aliases.\n   */\n\n  (function alias(name, as){\n    assert[as] = assert[name];\n    return alias;\n  })\n  ('Throw', 'throw')\n  ('Throw', 'throws');\n};\n\n});\n\nrequire.register(\"chai/lib/chai/interface/expect.js\", function (exports, module) {\n/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nmodule.exports = function (chai, util) {\n  chai.expect = function (val, message) {\n    return new chai.Assertion(val, message);\n  };\n\n  /**\n   * ### .fail(actual, expected, [message], [operator])\n   *\n   * Throw a failure.\n   *\n   * @name fail\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @param {String} operator\n   * @api public\n   */\n\n  chai.expect.fail = function (actual, expected, message, operator) {\n    message = message || 'expect.fail()';\n    throw new chai.AssertionError(message, {\n        actual: actual\n      , expected: expected\n      , operator: operator\n    }, chai.expect.fail);\n  };\n};\n\n});\n\nrequire.register(\"chai/lib/chai/interface/should.js\", function (exports, module) {\n/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nmodule.exports = function (chai, util) {\n  var Assertion = chai.Assertion;\n\n  function loadShould () {\n    // explicitly define this method as function as to have it's name to include as `ssfi`\n    function shouldGetter() {\n      if (this instanceof String || this instanceof Number) {\n        return new Assertion(this.constructor(this), null, shouldGetter);\n      } else if (this instanceof Boolean) {\n        return new Assertion(this == true, null, shouldGetter);\n      }\n      return new Assertion(this, null, shouldGetter);\n    }\n    function shouldSetter(value) {\n      // See https://github.com/chaijs/chai/issues/86: this makes\n      // `whatever.should = someValue` actually set `someValue`, which is\n      // especially useful for `global.should = require('chai').should()`.\n      //\n      // Note that we have to use [[DefineProperty]] instead of [[Put]]\n      // since otherwise we would trigger this very setter!\n      Object.defineProperty(this, 'should', {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    }\n    // modify Object.prototype to have `should`\n    Object.defineProperty(Object.prototype, 'should', {\n      set: shouldSetter\n      , get: shouldGetter\n      , configurable: true\n    });\n\n    var should = {};\n\n    /**\n     * ### .fail(actual, expected, [message], [operator])\n     *\n     * Throw a failure.\n     *\n     * @name fail\n     * @param {Mixed} actual\n     * @param {Mixed} expected\n     * @param {String} message\n     * @param {String} operator\n     * @api public\n     */\n\n    should.fail = function (actual, expected, message, operator) {\n      message = message || 'should.fail()';\n      throw new chai.AssertionError(message, {\n          actual: actual\n        , expected: expected\n        , operator: operator\n      }, should.fail);\n    };\n\n    should.equal = function (val1, val2, msg) {\n      new Assertion(val1, msg).to.equal(val2);\n    };\n\n    should.Throw = function (fn, errt, errs, msg) {\n      new Assertion(fn, msg).to.Throw(errt, errs);\n    };\n\n    should.exist = function (val, msg) {\n      new Assertion(val, msg).to.exist;\n    }\n\n    // negation\n    should.not = {}\n\n    should.not.equal = function (val1, val2, msg) {\n      new Assertion(val1, msg).to.not.equal(val2);\n    };\n\n    should.not.Throw = function (fn, errt, errs, msg) {\n      new Assertion(fn, msg).to.not.Throw(errt, errs);\n    };\n\n    should.not.exist = function (val, msg) {\n      new Assertion(val, msg).to.not.exist;\n    }\n\n    should['throw'] = should['Throw'];\n    should.not['throw'] = should.not['Throw'];\n\n    return should;\n  };\n\n  chai.should = loadShould;\n  chai.Should = loadShould;\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/addChainableMethod.js\", function (exports, module) {\n/*!\n * Chai - addChainingMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar transferFlags = require('chai/lib/chai/utils/transferFlags.js');\nvar flag = require('chai/lib/chai/utils/flag.js');\nvar config = require('chai/lib/chai/config.js');\n\n/*!\n * Module variables\n */\n\n// Check whether `__proto__` is supported\nvar hasProtoSupport = '__proto__' in Object;\n\n// Without `__proto__` support, this module will need to add properties to a function.\n// However, some Function.prototype methods cannot be overwritten,\n// and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).\nvar excludeNames = /^(?:length|name|arguments|caller)$/;\n\n// Cache `Function` properties\nvar call  = Function.prototype.call,\n    apply = Function.prototype.apply;\n\n/**\n * ### addChainableMethod (ctx, name, method, chainingBehavior)\n *\n * Adds a method to an object, such that the method can also be chained.\n *\n *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {\n *       var obj = utils.flag(this, 'object');\n *       new chai.Assertion(obj).to.be.equal(str);\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);\n *\n * The result can then be used as both a method assertion, executing both `method` and\n * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.\n *\n *     expect(fooStr).to.be.foo('bar');\n *     expect(fooStr).to.be.foo.equal('foo');\n *\n * @param {Object} ctx object to which the method is added\n * @param {String} name of method to add\n * @param {Function} method function to be used for `name`, when called\n * @param {Function} chainingBehavior function to be called every time the property is accessed\n * @name addChainableMethod\n * @api public\n */\n\nmodule.exports = function (ctx, name, method, chainingBehavior) {\n  if (typeof chainingBehavior !== 'function') {\n    chainingBehavior = function () { };\n  }\n\n  var chainableBehavior = {\n      method: method\n    , chainingBehavior: chainingBehavior\n  };\n\n  // save the methods so we can overwrite them later, if we need to.\n  if (!ctx.__methods) {\n    ctx.__methods = {};\n  }\n  ctx.__methods[name] = chainableBehavior;\n\n  Object.defineProperty(ctx, name,\n    { get: function () {\n        chainableBehavior.chainingBehavior.call(this);\n\n        var assert = function assert() {\n          var old_ssfi = flag(this, 'ssfi');\n          if (old_ssfi && config.includeStack === false)\n            flag(this, 'ssfi', assert);\n          var result = chainableBehavior.method.apply(this, arguments);\n          return result === undefined ? this : result;\n        };\n\n        // Use `__proto__` if available\n        if (hasProtoSupport) {\n          // Inherit all properties from the object by replacing the `Function` prototype\n          var prototype = assert.__proto__ = Object.create(this);\n          // Restore the `call` and `apply` methods from `Function`\n          prototype.call = call;\n          prototype.apply = apply;\n        }\n        // Otherwise, redefine all properties (slow!)\n        else {\n          var asserterNames = Object.getOwnPropertyNames(ctx);\n          asserterNames.forEach(function (asserterName) {\n            if (!excludeNames.test(asserterName)) {\n              var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);\n              Object.defineProperty(assert, asserterName, pd);\n            }\n          });\n        }\n\n        transferFlags(this, assert);\n        return assert;\n      }\n    , configurable: true\n  });\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/addMethod.js\", function (exports, module) {\n/*!\n * Chai - addMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar config = require('chai/lib/chai/config.js');\n\n/**\n * ### .addMethod (ctx, name, method)\n *\n * Adds a method to the prototype of an object.\n *\n *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {\n *       var obj = utils.flag(this, 'object');\n *       new chai.Assertion(obj).to.be.equal(str);\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.addMethod('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(fooStr).to.be.foo('bar');\n *\n * @param {Object} ctx object to which the method is added\n * @param {String} name of method to add\n * @param {Function} method function to be used for name\n * @name addMethod\n * @api public\n */\nvar flag = require('chai/lib/chai/utils/flag.js');\n\nmodule.exports = function (ctx, name, method) {\n  ctx[name] = function () {\n    var old_ssfi = flag(this, 'ssfi');\n    if (old_ssfi && config.includeStack === false)\n      flag(this, 'ssfi', ctx[name]);\n    var result = method.apply(this, arguments);\n    return result === undefined ? this : result;\n  };\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/addProperty.js\", function (exports, module) {\n/*!\n * Chai - addProperty utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### addProperty (ctx, name, getter)\n *\n * Adds a property to the prototype of an object.\n *\n *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {\n *       var obj = utils.flag(this, 'object');\n *       new chai.Assertion(obj).to.be.instanceof(Foo);\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.addProperty('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.be.foo;\n *\n * @param {Object} ctx object to which the property is added\n * @param {String} name of property to add\n * @param {Function} getter function to be used for name\n * @name addProperty\n * @api public\n */\n\nmodule.exports = function (ctx, name, getter) {\n  Object.defineProperty(ctx, name,\n    { get: function () {\n        var result = getter.call(this);\n        return result === undefined ? this : result;\n      }\n    , configurable: true\n  });\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/flag.js\", function (exports, module) {\n/*!\n * Chai - flag utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### flag(object, key, [value])\n *\n * Get or set a flag value on an object. If a\n * value is provided it will be set, else it will\n * return the currently set value or `undefined` if\n * the value is not set.\n *\n *     utils.flag(this, 'foo', 'bar'); // setter\n *     utils.flag(this, 'foo'); // getter, returns `bar`\n *\n * @param {Object} object constructed Assertion\n * @param {String} key\n * @param {Mixed} value (optional)\n * @name flag\n * @api private\n */\n\nmodule.exports = function (obj, key, value) {\n  var flags = obj.__flags || (obj.__flags = Object.create(null));\n  if (arguments.length === 3) {\n    flags[key] = value;\n  } else {\n    return flags[key];\n  }\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/getActual.js\", function (exports, module) {\n/*!\n * Chai - getActual utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * # getActual(object, [actual])\n *\n * Returns the `actual` value for an Assertion\n *\n * @param {Object} object (constructed Assertion)\n * @param {Arguments} chai.Assertion.prototype.assert arguments\n */\n\nmodule.exports = function (obj, args) {\n  return args.length > 4 ? args[4] : obj._obj;\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/getEnumerableProperties.js\", function (exports, module) {\n/*!\n * Chai - getEnumerableProperties utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .getEnumerableProperties(object)\n *\n * This allows the retrieval of enumerable property names of an object,\n * inherited or not.\n *\n * @param {Object} object\n * @returns {Array}\n * @name getEnumerableProperties\n * @api public\n */\n\nmodule.exports = function getEnumerableProperties(object) {\n  var result = [];\n  for (var name in object) {\n    result.push(name);\n  }\n  return result;\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/getMessage.js\", function (exports, module) {\n/*!\n * Chai - message composition utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependancies\n */\n\nvar flag = require('chai/lib/chai/utils/flag.js')\n  , getActual = require('chai/lib/chai/utils/getActual.js')\n  , inspect = require('chai/lib/chai/utils/inspect.js')\n  , objDisplay = require('chai/lib/chai/utils/objDisplay.js');\n\n/**\n * ### .getMessage(object, message, negateMessage)\n *\n * Construct the error message based on flags\n * and template tags. Template tags will return\n * a stringified inspection of the object referenced.\n *\n * Message template tags:\n * - `#{this}` current asserted object\n * - `#{act}` actual value\n * - `#{exp}` expected value\n *\n * @param {Object} object (constructed Assertion)\n * @param {Arguments} chai.Assertion.prototype.assert arguments\n * @name getMessage\n * @api public\n */\n\nmodule.exports = function (obj, args) {\n  var negate = flag(obj, 'negate')\n    , val = flag(obj, 'object')\n    , expected = args[3]\n    , actual = getActual(obj, args)\n    , msg = negate ? args[2] : args[1]\n    , flagMsg = flag(obj, 'message');\n\n  if(typeof msg === \"function\") msg = msg();\n  msg = msg || '';\n  msg = msg\n    .replace(/#{this}/g, objDisplay(val))\n    .replace(/#{act}/g, objDisplay(actual))\n    .replace(/#{exp}/g, objDisplay(expected));\n\n  return flagMsg ? flagMsg + ': ' + msg : msg;\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/getName.js\", function (exports, module) {\n/*!\n * Chai - getName utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * # getName(func)\n *\n * Gets the name of a function, in a cross-browser way.\n *\n * @param {Function} a function (usually a constructor)\n */\n\nmodule.exports = function (func) {\n  if (func.name) return func.name;\n\n  var match = /^\\s?function ([^(]*)\\(/.exec(func);\n  return match && match[1] ? match[1] : \"\";\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/getPathValue.js\", function (exports, module) {\n/*!\n * Chai - getPathValue utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * @see https://github.com/logicalparadox/filtr\n * MIT Licensed\n */\n\nvar getPathInfo = require('chai/lib/chai/utils/getPathInfo.js');\n\n/**\n * ### .getPathValue(path, object)\n *\n * This allows the retrieval of values in an\n * object given a string path.\n *\n *     var obj = {\n *         prop1: {\n *             arr: ['a', 'b', 'c']\n *           , str: 'Hello'\n *         }\n *       , prop2: {\n *             arr: [ { nested: 'Universe' } ]\n *           , str: 'Hello again!'\n *         }\n *     }\n *\n * The following would be the results.\n *\n *     getPathValue('prop1.str', obj); // Hello\n *     getPathValue('prop1.att[2]', obj); // b\n *     getPathValue('prop2.arr[0].nested', obj); // Universe\n *\n * @param {String} path\n * @param {Object} object\n * @returns {Object} value or `undefined`\n * @name getPathValue\n * @api public\n */\nmodule.exports = function(path, obj) {\n  var info = getPathInfo(path, obj);\n  return info.value;\n}; \n\n});\n\nrequire.register(\"chai/lib/chai/utils/getPathInfo.js\", function (exports, module) {\n/*!\n * Chai - getPathInfo utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar hasProperty = require('chai/lib/chai/utils/hasProperty.js');\n\n/**\n * ### .getPathInfo(path, object)\n *\n * This allows the retrieval of property info in an\n * object given a string path.\n *\n * The path info consists of an object with the\n * following properties:\n *\n * * parent - The parent object of the property referenced by `path`\n * * name - The name of the final property, a number if it was an array indexer\n * * value - The value of the property, if it exists, otherwise `undefined`\n * * exists - Whether the property exists or not\n *\n * @param {String} path\n * @param {Object} object\n * @returns {Object} info\n * @name getPathInfo\n * @api public\n */\n\nmodule.exports = function getPathInfo(path, obj) {\n  var parsed = parsePath(path),\n      last = parsed[parsed.length - 1];\n\n  var info = {\n    parent: _getPathValue(parsed, obj, parsed.length - 1),\n    name: last.p || last.i,\n    value: _getPathValue(parsed, obj),\n  };\n  info.exists = hasProperty(info.name, info.parent);\n\n  return info;\n};\n\n\n/*!\n * ## parsePath(path)\n *\n * Helper function used to parse string object\n * paths. Use in conjunction with `_getPathValue`.\n *\n *      var parsed = parsePath('myobject.property.subprop');\n *\n * ### Paths:\n *\n * * Can be as near infinitely deep and nested\n * * Arrays are also valid using the formal `myobject.document[3].property`.\n *\n * @param {String} path\n * @returns {Object} parsed\n * @api private\n */\n\nfunction parsePath (path) {\n  var str = path.replace(/\\[/g, '.[')\n    , parts = str.match(/(\\\\\\.|[^.]+?)+/g);\n  return parts.map(function (value) {\n    var re = /\\[(\\d+)\\]$/\n      , mArr = re.exec(value);\n    if (mArr) return { i: parseFloat(mArr[1]) };\n    else return { p: value };\n  });\n}\n\n\n/*!\n * ## _getPathValue(parsed, obj)\n *\n * Helper companion function for `.parsePath` that returns\n * the value located at the parsed address.\n *\n *      var value = getPathValue(parsed, obj);\n *\n * @param {Object} parsed definition from `parsePath`.\n * @param {Object} object to search against\n * @param {Number} object to search against\n * @returns {Object|Undefined} value\n * @api private\n */\n\nfunction _getPathValue (parsed, obj, index) {\n  var tmp = obj\n    , res;\n\n  index = (index === undefined ? parsed.length : index);\n\n  for (var i = 0, l = index; i < l; i++) {\n    var part = parsed[i];\n    if (tmp) {\n      if ('undefined' !== typeof part.p)\n        tmp = tmp[part.p];\n      else if ('undefined' !== typeof part.i)\n        tmp = tmp[part.i];\n      if (i == (l - 1)) res = tmp;\n    } else {\n      res = undefined;\n    }\n  }\n  return res;\n}\n\n});\n\nrequire.register(\"chai/lib/chai/utils/hasProperty.js\", function (exports, module) {\n/*!\n * Chai - hasProperty utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar type = require('chai/lib/chai/utils/type.js');\n\n/**\n * ### .hasProperty(object, name)\n *\n * This allows checking whether an object has\n * named property or numeric array index.\n *\n * Basically does the same thing as the `in`\n * operator but works properly with natives\n * and null/undefined values.\n *\n *     var obj = {\n *         arr: ['a', 'b', 'c']\n *       , str: 'Hello'\n *     }\n *\n * The following would be the results.\n *\n *     hasProperty('str', obj);  // true\n *     hasProperty('constructor', obj);  // true\n *     hasProperty('bar', obj);  // false\n *     \n *     hasProperty('length', obj.str); // true\n *     hasProperty(1, obj.str);  // true\n *     hasProperty(5, obj.str);  // false\n *\n *     hasProperty('length', obj.arr);  // true\n *     hasProperty(2, obj.arr);  // true\n *     hasProperty(3, obj.arr);  // false\n *\n * @param {Objuect} object\n * @param {String|Number} name\n * @returns {Boolean} whether it exists\n * @name getPathInfo\n * @api public\n */\n\nvar literals = {\n    'number': Number\n  , 'string': String\n};\n\nmodule.exports = function hasProperty(name, obj) {\n  var ot = type(obj);\n\n  // Bad Object, obviously no props at all\n  if(ot === 'null' || ot === 'undefined')\n    return false;\n\n  // The `in` operator does not work with certain literals\n  // box these before the check\n  if(literals[ot] && typeof obj !== 'object')\n    obj = new literals[ot](obj);\n\n  return name in obj;\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/getProperties.js\", function (exports, module) {\n/*!\n * Chai - getProperties utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .getProperties(object)\n *\n * This allows the retrieval of property names of an object, enumerable or not,\n * inherited or not.\n *\n * @param {Object} object\n * @returns {Array}\n * @name getProperties\n * @api public\n */\n\nmodule.exports = function getProperties(object) {\n  var result = Object.getOwnPropertyNames(subject);\n\n  function addProperty(property) {\n    if (result.indexOf(property) === -1) {\n      result.push(property);\n    }\n  }\n\n  var proto = Object.getPrototypeOf(subject);\n  while (proto !== null) {\n    Object.getOwnPropertyNames(proto).forEach(addProperty);\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return result;\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/index.js\", function (exports, module) {\n/*!\n * chai\n * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Main exports\n */\n\nvar exports = module.exports = {};\n\n/*!\n * test utility\n */\n\nexports.test = require('chai/lib/chai/utils/test.js');\n\n/*!\n * type utility\n */\n\nexports.type = require('chai/lib/chai/utils/type.js');\n\n/*!\n * message utility\n */\n\nexports.getMessage = require('chai/lib/chai/utils/getMessage.js');\n\n/*!\n * actual utility\n */\n\nexports.getActual = require('chai/lib/chai/utils/getActual.js');\n\n/*!\n * Inspect util\n */\n\nexports.inspect = require('chai/lib/chai/utils/inspect.js');\n\n/*!\n * Object Display util\n */\n\nexports.objDisplay = require('chai/lib/chai/utils/objDisplay.js');\n\n/*!\n * Flag utility\n */\n\nexports.flag = require('chai/lib/chai/utils/flag.js');\n\n/*!\n * Flag transferring utility\n */\n\nexports.transferFlags = require('chai/lib/chai/utils/transferFlags.js');\n\n/*!\n * Deep equal utility\n */\n\nexports.eql = require('chaijs~deep-eql@0.1.3');\n\n/*!\n * Deep path value\n */\n\nexports.getPathValue = require('chai/lib/chai/utils/getPathValue.js');\n\n/*!\n * Deep path info\n */\n\nexports.getPathInfo = require('chai/lib/chai/utils/getPathInfo.js');\n\n/*!\n * Check if a property exists\n */\n\nexports.hasProperty = require('chai/lib/chai/utils/hasProperty.js');\n\n/*!\n * Function name\n */\n\nexports.getName = require('chai/lib/chai/utils/getName.js');\n\n/*!\n * add Property\n */\n\nexports.addProperty = require('chai/lib/chai/utils/addProperty.js');\n\n/*!\n * add Method\n */\n\nexports.addMethod = require('chai/lib/chai/utils/addMethod.js');\n\n/*!\n * overwrite Property\n */\n\nexports.overwriteProperty = require('chai/lib/chai/utils/overwriteProperty.js');\n\n/*!\n * overwrite Method\n */\n\nexports.overwriteMethod = require('chai/lib/chai/utils/overwriteMethod.js');\n\n/*!\n * Add a chainable method\n */\n\nexports.addChainableMethod = require('chai/lib/chai/utils/addChainableMethod.js');\n\n/*!\n * Overwrite chainable method\n */\n\nexports.overwriteChainableMethod = require('chai/lib/chai/utils/overwriteChainableMethod.js');\n\n\n});\n\nrequire.register(\"chai/lib/chai/utils/inspect.js\", function (exports, module) {\n// This is (almost) directly from Node.js utils\n// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js\n\nvar getName = require('chai/lib/chai/utils/getName.js');\nvar getProperties = require('chai/lib/chai/utils/getProperties.js');\nvar getEnumerableProperties = require('chai/lib/chai/utils/getEnumerableProperties.js');\n\nmodule.exports = inspect;\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Boolean} showHidden Flag that shows hidden (not enumerable)\n *    properties of objects.\n * @param {Number} depth Depth in which to descend in object. Default is 2.\n * @param {Boolean} colors Flag to turn on ANSI escape codes to color the\n *    output. Default is false (no coloring).\n */\nfunction inspect(obj, showHidden, depth, colors) {\n  var ctx = {\n    showHidden: showHidden,\n    seen: [],\n    stylize: function (str) { return str; }\n  };\n  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));\n}\n\n// Returns true if object is a DOM element.\nvar isDOMElement = function (object) {\n  if (typeof HTMLElement === 'object') {\n    return object instanceof HTMLElement;\n  } else {\n    return object &&\n      typeof object === 'object' &&\n      object.nodeType === 1 &&\n      typeof object.nodeName === 'string';\n  }\n};\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (value && typeof value.inspect === 'function' &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes);\n    if (typeof ret !== 'string') {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // If this is a DOM element, try to get the outer HTML.\n  if (isDOMElement(value)) {\n    if ('outerHTML' in value) {\n      return value.outerHTML;\n      // This value does not have an outerHTML attribute,\n      //   it could still be an XML element\n    } else {\n      // Attempt to serialize it\n      try {\n        if (document.xmlVersion) {\n          var xmlSerializer = new XMLSerializer();\n          return xmlSerializer.serializeToString(value);\n        } else {\n          // Firefox 11- do not support outerHTML\n          //   It does, however, support innerHTML\n          //   Use the following to render the element\n          var ns = \"http://www.w3.org/1999/xhtml\";\n          var container = document.createElementNS(ns, '_');\n\n          container.appendChild(value.cloneNode(false));\n          html = container.innerHTML\n            .replace('><', '>' + value.innerHTML + '<');\n          container.innerHTML = '';\n          return html;\n        }\n      } catch (err) {\n        // This could be a non-native DOM implementation,\n        //   continue with the normal flow:\n        //   printing the element as if it is an object.\n      }\n    }\n  }\n\n  // Look up the keys of the object.\n  var visibleKeys = getEnumerableProperties(value);\n  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;\n\n  // Some type of object without properties can be shortcutted.\n  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,\n  // a `stack` plus `description` property; ignore those for consistency.\n  if (keys.length === 0 || (isError(value) && (\n      (keys.length === 1 && keys[0] === 'stack') ||\n      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')\n     ))) {\n    if (typeof value === 'function') {\n      var name = getName(value);\n      var nameSuffix = name ? ': ' + name : '';\n      return ctx.stylize('[Function' + nameSuffix + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (typeof value === 'function') {\n    var name = getName(value);\n    var nameSuffix = name ? ': ' + name : '';\n    base = ' [Function' + nameSuffix + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    return formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  switch (typeof value) {\n    case 'undefined':\n      return ctx.stylize('undefined', 'undefined');\n\n    case 'string':\n      var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                               .replace(/'/g, \"\\\\'\")\n                                               .replace(/\\\\\"/g, '\"') + '\\'';\n      return ctx.stylize(simple, 'string');\n\n    case 'number':\n      if (value === 0 && (1/value) === -Infinity) {\n        return ctx.stylize('-0', 'number');\n      }\n      return ctx.stylize('' + value, 'number');\n\n    case 'boolean':\n      return ctx.stylize('' + value, 'boolean');\n  }\n  // For some reason typeof null is \"object\", so special case here.\n  if (value === null) {\n    return ctx.stylize('null', 'null');\n  }\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (Object.prototype.hasOwnProperty.call(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str;\n  if (value.__lookupGetter__) {\n    if (value.__lookupGetter__(key)) {\n      if (value.__lookupSetter__(key)) {\n        str = ctx.stylize('[Getter/Setter]', 'special');\n      } else {\n        str = ctx.stylize('[Getter]', 'special');\n      }\n    } else {\n      if (value.__lookupSetter__(key)) {\n        str = ctx.stylize('[Setter]', 'special');\n      }\n    }\n  }\n  if (visibleKeys.indexOf(key) < 0) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(value[key]) < 0) {\n      if (recurseTimes === null) {\n        str = formatValue(ctx, value[key], null);\n      } else {\n        str = formatValue(ctx, value[key], recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (typeof name === 'undefined') {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\nfunction isArray(ar) {\n  return Array.isArray(ar) ||\n         (typeof ar === 'object' && objectToString(ar) === '[object Array]');\n}\n\nfunction isRegExp(re) {\n  return typeof re === 'object' && objectToString(re) === '[object RegExp]';\n}\n\nfunction isDate(d) {\n  return typeof d === 'object' && objectToString(d) === '[object Date]';\n}\n\nfunction isError(e) {\n  return typeof e === 'object' && objectToString(e) === '[object Error]';\n}\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n});\n\nrequire.register(\"chai/lib/chai/utils/objDisplay.js\", function (exports, module) {\n/*!\n * Chai - flag utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependancies\n */\n\nvar inspect = require('chai/lib/chai/utils/inspect.js');\nvar config = require('chai/lib/chai/config.js');\n\n/**\n * ### .objDisplay (object)\n *\n * Determines if an object or an array matches\n * criteria to be inspected in-line for error\n * messages or should be truncated.\n *\n * @param {Mixed} javascript object to inspect\n * @name objDisplay\n * @api public\n */\n\nmodule.exports = function (obj) {\n  var str = inspect(obj)\n    , type = Object.prototype.toString.call(obj);\n\n  if (config.truncateThreshold && str.length >= config.truncateThreshold) {\n    if (type === '[object Function]') {\n      return !obj.name || obj.name === ''\n        ? '[Function]'\n        : '[Function: ' + obj.name + ']';\n    } else if (type === '[object Array]') {\n      return '[ Array(' + obj.length + ') ]';\n    } else if (type === '[object Object]') {\n      var keys = Object.keys(obj)\n        , kstr = keys.length > 2\n          ? keys.splice(0, 2).join(', ') + ', ...'\n          : keys.join(', ');\n      return '{ Object (' + kstr + ') }';\n    } else {\n      return str;\n    }\n  } else {\n    return str;\n  }\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/overwriteMethod.js\", function (exports, module) {\n/*!\n * Chai - overwriteMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### overwriteMethod (ctx, name, fn)\n *\n * Overwites an already existing method and provides\n * access to previous function. Must return function\n * to be used for name.\n *\n *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {\n *       return function (str) {\n *         var obj = utils.flag(this, 'object');\n *         if (obj instanceof Foo) {\n *           new chai.Assertion(obj.value).to.equal(str);\n *         } else {\n *           _super.apply(this, arguments);\n *         }\n *       }\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.overwriteMethod('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.equal('bar');\n *\n * @param {Object} ctx object whose method is to be overwritten\n * @param {String} name of method to overwrite\n * @param {Function} method function that returns a function to be used for name\n * @name overwriteMethod\n * @api public\n */\n\nmodule.exports = function (ctx, name, method) {\n  var _method = ctx[name]\n    , _super = function () { return this; };\n\n  if (_method && 'function' === typeof _method)\n    _super = _method;\n\n  ctx[name] = function () {\n    var result = method(_super).apply(this, arguments);\n    return result === undefined ? this : result;\n  }\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/overwriteProperty.js\", function (exports, module) {\n/*!\n * Chai - overwriteProperty utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### overwriteProperty (ctx, name, fn)\n *\n * Overwites an already existing property getter and provides\n * access to previous value. Must return function to use as getter.\n *\n *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {\n *       return function () {\n *         var obj = utils.flag(this, 'object');\n *         if (obj instanceof Foo) {\n *           new chai.Assertion(obj.name).to.equal('bar');\n *         } else {\n *           _super.call(this);\n *         }\n *       }\n *     });\n *\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.overwriteProperty('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.be.ok;\n *\n * @param {Object} ctx object whose property is to be overwritten\n * @param {String} name of property to overwrite\n * @param {Function} getter function that returns a getter function to be used for name\n * @name overwriteProperty\n * @api public\n */\n\nmodule.exports = function (ctx, name, getter) {\n  var _get = Object.getOwnPropertyDescriptor(ctx, name)\n    , _super = function () {};\n\n  if (_get && 'function' === typeof _get.get)\n    _super = _get.get\n\n  Object.defineProperty(ctx, name,\n    { get: function () {\n        var result = getter(_super).call(this);\n        return result === undefined ? this : result;\n      }\n    , configurable: true\n  });\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/overwriteChainableMethod.js\", function (exports, module) {\n/*!\n * Chai - overwriteChainableMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### overwriteChainableMethod (ctx, name, method, chainingBehavior)\n *\n * Overwites an already existing chainable method\n * and provides access to the previous function or\n * property.  Must return functions to be used for\n * name.\n *\n *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'length',\n *       function (_super) {\n *       }\n *     , function (_super) {\n *       }\n *     );\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.have.length(3);\n *     expect(myFoo).to.have.length.above(3);\n *\n * @param {Object} ctx object whose method / property is to be overwritten\n * @param {String} name of method / property to overwrite\n * @param {Function} method function that returns a function to be used for name\n * @param {Function} chainingBehavior function that returns a function to be used for property\n * @name overwriteChainableMethod\n * @api public\n */\n\nmodule.exports = function (ctx, name, method, chainingBehavior) {\n  var chainableBehavior = ctx.__methods[name];\n\n  var _chainingBehavior = chainableBehavior.chainingBehavior;\n  chainableBehavior.chainingBehavior = function () {\n    var result = chainingBehavior(_chainingBehavior).call(this);\n    return result === undefined ? this : result;\n  };\n\n  var _method = chainableBehavior.method;\n  chainableBehavior.method = function () {\n    var result = method(_method).apply(this, arguments);\n    return result === undefined ? this : result;\n  };\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/test.js\", function (exports, module) {\n/*!\n * Chai - test utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependancies\n */\n\nvar flag = require('chai/lib/chai/utils/flag.js');\n\n/**\n * # test(object, expression)\n *\n * Test and object for expression.\n *\n * @param {Object} object (constructed Assertion)\n * @param {Arguments} chai.Assertion.prototype.assert arguments\n */\n\nmodule.exports = function (obj, args) {\n  var negate = flag(obj, 'negate')\n    , expr = args[0];\n  return negate ? !expr : expr;\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/transferFlags.js\", function (exports, module) {\n/*!\n * Chai - transferFlags utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### transferFlags(assertion, object, includeAll = true)\n *\n * Transfer all the flags for `assertion` to `object`. If\n * `includeAll` is set to `false`, then the base Chai\n * assertion flags (namely `object`, `ssfi`, and `message`)\n * will not be transferred.\n *\n *\n *     var newAssertion = new Assertion();\n *     utils.transferFlags(assertion, newAssertion);\n *\n *     var anotherAsseriton = new Assertion(myObj);\n *     utils.transferFlags(assertion, anotherAssertion, false);\n *\n * @param {Assertion} assertion the assertion to transfer the flags from\n * @param {Object} object the object to transfer the flags to; usually a new assertion\n * @param {Boolean} includeAll\n * @name transferFlags\n * @api private\n */\n\nmodule.exports = function (assertion, object, includeAll) {\n  var flags = assertion.__flags || (assertion.__flags = Object.create(null));\n\n  if (!object.__flags) {\n    object.__flags = Object.create(null);\n  }\n\n  includeAll = arguments.length === 3 ? includeAll : true;\n\n  for (var flag in flags) {\n    if (includeAll ||\n        (flag !== 'object' && flag !== 'ssfi' && flag != 'message')) {\n      object.__flags[flag] = flags[flag];\n    }\n  }\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/type.js\", function (exports, module) {\n/*!\n * Chai - type utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Detectable javascript natives\n */\n\nvar natives = {\n    '[object Arguments]': 'arguments'\n  , '[object Array]': 'array'\n  , '[object Date]': 'date'\n  , '[object Function]': 'function'\n  , '[object Number]': 'number'\n  , '[object RegExp]': 'regexp'\n  , '[object String]': 'string'\n};\n\n/**\n * ### type(object)\n *\n * Better implementation of `typeof` detection that can\n * be used cross-browser. Handles the inconsistencies of\n * Array, `null`, and `undefined` detection.\n *\n *     utils.type({}) // 'object'\n *     utils.type(null) // `null'\n *     utils.type(undefined) // `undefined`\n *     utils.type([]) // `array`\n *\n * @param {Mixed} object to detect type of\n * @name type\n * @api private\n */\n\nmodule.exports = function (obj) {\n  var str = Object.prototype.toString.call(obj);\n  if (natives[str]) return natives[str];\n  if (obj === null) return 'null';\n  if (obj === undefined) return 'undefined';\n  if (obj === Object(obj)) return 'object';\n  return typeof obj;\n};\n\n});\n\nif (typeof exports == \"object\") {\n  module.exports = require(\"chai\");\n} else if (typeof define == \"function\" && define.amd) {\n  define(\"chai\", [], function(){ return require(\"chai\"); });\n} else {\n  (this || window)[\"chai\"] = require(\"chai\");\n}\n})()"]},"hash":"adee2cb53d0f6c1603e86df3518b95b96931d3ce"}
