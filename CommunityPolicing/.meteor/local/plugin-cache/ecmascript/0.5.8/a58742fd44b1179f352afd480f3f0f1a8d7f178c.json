{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/prism/components/prism-parigp.js","filenameRelative":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/prism/components/prism-parigp.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/prism/components/prism-parigp.js.map","sourceFileName":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/prism/components/prism-parigp.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"prism-parigp"},"ignored":false,"code":"Prism.languages.parigp = {\n\t'comment': /\\/\\*[\\s\\S]*?\\*\\/|\\\\\\\\.*/,\n\t'string': /\"(?:[^\"\\\\]|\\\\.)*\"/,\n\t// PARI/GP does not care about white spaces at all\n\t// so let's process the keywords to build an appropriate regexp\n\t// (e.g. \"b *r *e *a *k\", etc.)\n\t'keyword': function () {\n\t\tvar keywords = ['breakpoint', 'break', 'dbg_down', 'dbg_err', 'dbg_up', 'dbg_x', 'forcomposite', 'fordiv', 'forell', 'forpart', 'forprime', 'forstep', 'forsubgroup', 'forvec', 'for', 'iferr', 'if', 'local', 'my', 'next', 'return', 'until', 'while'];\n\t\tkeywords = keywords.map(function (keyword) {\n\t\t\treturn keyword.split('').join(' *');\n\t\t}).join('|');\n\t\treturn RegExp('\\\\b(?:' + keywords + ')\\\\b');\n\t}(),\n\t'function': /\\w[\\w ]*?(?= *\\()/,\n\t'number': {\n\t\t// The lookbehind and the negative lookahead prevent from breaking the .. operator\n\t\tpattern: /((?:\\. *\\. *)?)(?:\\d(?: *\\d)*(?: *(?!\\. *\\.)\\.(?: *\\d)*)?|\\. *\\d(?: *\\d)*)(?: *e *[+-]? *\\d(?: *\\d)*)?/i,\n\t\tlookbehind: true\n\t},\n\t'operator': /\\. *\\.|[*\\/!](?: *=)?|%(?: *=|(?: *#)?(?: *')*)?|\\+(?: *[+=])?|-(?: *[-=>])?|<(?:(?: *<)?(?: *=)?| *>)?|>(?: *>)?(?: *=)?|=(?: *=){0,2}|\\\\(?: *\\/)?(?: *=)?|&(?: *&)?|\\| *\\||['#~^]/,\n\t'punctuation': /[\\[\\]{}().,:;|]/\n};","ast":null,"map":{"version":3,"sources":["/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/prism/components/prism-parigp.js"],"names":[],"mappings":"AAAA,MAAM,SAAN,CAAgB,MAAhB,GAAyB;AACxB,YAAW,yBADa;AAExB,WAAU,mBAFc;;;;AAMxB,YAAY,YAAY;AACvB,MAAI,WAAW,CACd,YADc,EACA,OADA,EACS,UADT,EACqB,SADrB,EACgC,QADhC,EAC0C,OAD1C,EAEd,cAFc,EAEE,QAFF,EAEY,QAFZ,EAEsB,SAFtB,EAEiC,UAFjC,EAGd,SAHc,EAGH,aAHG,EAGY,QAHZ,EAGsB,KAHtB,EAG6B,OAH7B,EAGsC,IAHtC,EAId,OAJc,EAIL,IAJK,EAIC,MAJD,EAIS,QAJT,EAImB,OAJnB,EAI4B,OAJ5B,CAAf;AAMA,aAAW,SAAS,GAAT,CAAa,UAAU,OAAV,EAAmB;AAC1C,UAAO,QAAQ,KAAR,CAAc,EAAd,EAAkB,IAAlB,CAAuB,IAAvB,CAAP;AACA,GAFU,EAER,IAFQ,CAEH,GAFG,CAAX;AAGA,SAAO,OAAO,WAAW,QAAX,GAAsB,MAA7B,CAAP;AACA,EAXW,EANY;AAkBxB,aAAY,mBAlBY;AAmBxB,WAAU;;AAET,WAAS,yGAFA;AAGT,cAAY;AAHH,EAnBc;AAwBxB,aAAY,qLAxBY;AAyBxB,gBAAe;AAzBS,CAAzB","file":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/prism/components/prism-parigp.js.map","sourcesContent":["Prism.languages.parigp = {\n\t'comment': /\\/\\*[\\s\\S]*?\\*\\/|\\\\\\\\.*/,\n\t'string': /\"(?:[^\"\\\\]|\\\\.)*\"/,\n\t// PARI/GP does not care about white spaces at all\n\t// so let's process the keywords to build an appropriate regexp\n\t// (e.g. \"b *r *e *a *k\", etc.)\n\t'keyword': (function () {\n\t\tvar keywords = [\n\t\t\t'breakpoint', 'break', 'dbg_down', 'dbg_err', 'dbg_up', 'dbg_x',\n\t\t\t'forcomposite', 'fordiv', 'forell', 'forpart', 'forprime',\n\t\t\t'forstep', 'forsubgroup', 'forvec', 'for', 'iferr', 'if',\n\t\t\t'local', 'my', 'next', 'return', 'until', 'while'\n\t\t];\n\t\tkeywords = keywords.map(function (keyword) {\n\t\t\treturn keyword.split('').join(' *');\n\t\t}).join('|');\n\t\treturn RegExp('\\\\b(?:' + keywords + ')\\\\b');\n\t}()),\n\t'function': /\\w[\\w ]*?(?= *\\()/,\n\t'number': {\n\t\t// The lookbehind and the negative lookahead prevent from breaking the .. operator\n\t\tpattern: /((?:\\. *\\. *)?)(?:\\d(?: *\\d)*(?: *(?!\\. *\\.)\\.(?: *\\d)*)?|\\. *\\d(?: *\\d)*)(?: *e *[+-]? *\\d(?: *\\d)*)?/i,\n\t\tlookbehind: true\n\t},\n\t'operator': /\\. *\\.|[*\\/!](?: *=)?|%(?: *=|(?: *#)?(?: *')*)?|\\+(?: *[+=])?|-(?: *[-=>])?|<(?:(?: *<)?(?: *=)?| *>)?|>(?: *>)?(?: *=)?|=(?: *=){0,2}|\\\\(?: *\\/)?(?: *=)?|&(?: *&)?|\\| *\\||['#~^]/,\n\t'punctuation': /[\\[\\]{}().,:;|]/\n};"]},"hash":"a58742fd44b1179f352afd480f3f0f1a8d7f178c"}
