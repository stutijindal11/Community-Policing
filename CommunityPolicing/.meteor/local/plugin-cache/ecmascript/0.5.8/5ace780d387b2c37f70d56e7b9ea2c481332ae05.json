{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/equiv.js","filenameRelative":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/equiv.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/equiv.js.map","sourceFileName":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/equiv.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"equiv"},"ignored":false,"code":"// Test for equality any JavaScript type.\n// Author: Philippe Rathé <prathe@gmail.com>\nQUnit.equiv = function () {\n\n\t// Stack to decide between skip/abort functions\n\tvar callers = [];\n\n\t// Stack to avoiding loops from circular referencing\n\tvar parents = [];\n\tvar parentsB = [];\n\n\tfunction useStrictEquality(b, a) {\n\n\t\t/*jshint eqeqeq:false */\n\t\tif (b instanceof a.constructor || a instanceof b.constructor) {\n\n\t\t\t// To catch short annotation VS 'new' annotation of a declaration. e.g.:\n\t\t\t// `var i = 1;`\n\t\t\t// `var j = new Number(1);`\n\t\t\treturn a == b;\n\t\t} else {\n\t\t\treturn a === b;\n\t\t}\n\t}\n\n\tfunction compareConstructors(a, b) {\n\t\tvar getProto = Object.getPrototypeOf || function (obj) {\n\n\t\t\t/*jshint proto: true */\n\t\t\treturn obj.__proto__;\n\t\t};\n\t\tvar protoA = getProto(a);\n\t\tvar protoB = getProto(b);\n\n\t\t// Comparing constructors is more strict than using `instanceof`\n\t\tif (a.constructor === b.constructor) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Ref #851\n\t\t// If the obj prototype descends from a null constructor, treat it\n\t\t// as a null prototype.\n\t\tif (protoA && protoA.constructor === null) {\n\t\t\tprotoA = null;\n\t\t}\n\t\tif (protoB && protoB.constructor === null) {\n\t\t\tprotoB = null;\n\t\t}\n\n\t\t// Allow objects with no prototype to be equivalent to\n\t\t// objects with Object as their constructor.\n\t\tif (protoA === null && protoB === Object.prototype || protoB === null && protoA === Object.prototype) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tvar callbacks = {\n\t\t\"string\": useStrictEquality,\n\t\t\"boolean\": useStrictEquality,\n\t\t\"number\": useStrictEquality,\n\t\t\"null\": useStrictEquality,\n\t\t\"undefined\": useStrictEquality,\n\t\t\"symbol\": useStrictEquality,\n\n\t\t\"nan\": function nan(b) {\n\t\t\treturn isNaN(b);\n\t\t},\n\n\t\t\"date\": function date(b, a) {\n\t\t\treturn QUnit.objectType(b) === \"date\" && a.valueOf() === b.valueOf();\n\t\t},\n\n\t\t\"regexp\": function regexp(b, a) {\n\t\t\treturn QUnit.objectType(b) === \"regexp\" &&\n\n\t\t\t// The regex itself\n\t\t\ta.source === b.source &&\n\n\t\t\t// And its modifiers\n\t\t\ta.global === b.global &&\n\n\t\t\t// (gmi) ...\n\t\t\ta.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky;\n\t\t},\n\n\t\t// - skip when the property is a method of an instance (OOP)\n\t\t// - abort otherwise,\n\t\t// initial === would have catch identical references anyway\n\t\t\"function\": function _function() {\n\t\t\tvar caller = callers[callers.length - 1];\n\t\t\treturn caller !== Object && typeof caller !== \"undefined\";\n\t\t},\n\n\t\t\"array\": function array(b, a) {\n\t\t\tvar i, j, len, loop, aCircular, bCircular;\n\n\t\t\t// b could be an object literal here\n\t\t\tif (QUnit.objectType(b) !== \"array\") {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlen = a.length;\n\t\t\tif (len !== b.length) {\n\t\t\t\t// safe and faster\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Track reference to avoid circular references\n\t\t\tparents.push(a);\n\t\t\tparentsB.push(b);\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tloop = false;\n\t\t\t\tfor (j = 0; j < parents.length; j++) {\n\t\t\t\t\taCircular = parents[j] === a[i];\n\t\t\t\t\tbCircular = parentsB[j] === b[i];\n\t\t\t\t\tif (aCircular || bCircular) {\n\t\t\t\t\t\tif (a[i] === b[i] || aCircular && bCircular) {\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!loop && !innerEquiv(a[i], b[i])) {\n\t\t\t\t\tparents.pop();\n\t\t\t\t\tparentsB.pop();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparents.pop();\n\t\t\tparentsB.pop();\n\t\t\treturn true;\n\t\t},\n\n\t\t\"set\": function set(b, a) {\n\t\t\tvar aArray, bArray;\n\n\t\t\t// `b` could be any object here\n\t\t\tif (QUnit.objectType(b) !== \"set\") {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\taArray = [];\n\t\t\ta.forEach(function (v) {\n\t\t\t\taArray.push(v);\n\t\t\t});\n\t\t\tbArray = [];\n\t\t\tb.forEach(function (v) {\n\t\t\t\tbArray.push(v);\n\t\t\t});\n\n\t\t\treturn innerEquiv(bArray, aArray);\n\t\t},\n\n\t\t\"map\": function map(b, a) {\n\t\t\tvar aArray, bArray;\n\n\t\t\t// `b` could be any object here\n\t\t\tif (QUnit.objectType(b) !== \"map\") {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\taArray = [];\n\t\t\ta.forEach(function (v, k) {\n\t\t\t\taArray.push([k, v]);\n\t\t\t});\n\t\t\tbArray = [];\n\t\t\tb.forEach(function (v, k) {\n\t\t\t\tbArray.push([k, v]);\n\t\t\t});\n\n\t\t\treturn innerEquiv(bArray, aArray);\n\t\t},\n\n\t\t\"object\": function object(b, a) {\n\t\t\tvar i, j, loop, aCircular, bCircular;\n\n\t\t\t// Default to true\n\t\t\tvar eq = true;\n\t\t\tvar aProperties = [];\n\t\t\tvar bProperties = [];\n\n\t\t\tif (compareConstructors(a, b) === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Stack constructor before traversing properties\n\t\t\tcallers.push(a.constructor);\n\n\t\t\t// Track reference to avoid circular references\n\t\t\tparents.push(a);\n\t\t\tparentsB.push(b);\n\n\t\t\t// Be strict: don't ensure hasOwnProperty and go deep\n\t\t\tfor (i in a) {\n\t\t\t\tloop = false;\n\t\t\t\tfor (j = 0; j < parents.length; j++) {\n\t\t\t\t\taCircular = parents[j] === a[i];\n\t\t\t\t\tbCircular = parentsB[j] === b[i];\n\t\t\t\t\tif (aCircular || bCircular) {\n\t\t\t\t\t\tif (a[i] === b[i] || aCircular && bCircular) {\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taProperties.push(i);\n\t\t\t\tif (!loop && !innerEquiv(a[i], b[i])) {\n\t\t\t\t\teq = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparents.pop();\n\t\t\tparentsB.pop();\n\n\t\t\t// Unstack, we are done\n\t\t\tcallers.pop();\n\n\t\t\tfor (i in b) {\n\n\t\t\t\t// Collect b's properties\n\t\t\t\tbProperties.push(i);\n\t\t\t}\n\n\t\t\t// Ensures identical properties name\n\t\t\treturn eq && innerEquiv(aProperties.sort(), bProperties.sort());\n\t\t}\n\t};\n\n\tfunction typeEquiv(a, b) {\n\t\tvar prop = QUnit.objectType(a);\n\t\treturn callbacks[prop](b, a);\n\t}\n\n\t// The real equiv function\n\tfunction innerEquiv() {\n\t\tvar args = [].slice.apply(arguments);\n\t\tif (args.length < 2) {\n\n\t\t\t// End transition\n\t\t\treturn true;\n\t\t}\n\n\t\treturn function (a, b) {\n\t\t\tif (a === b) {\n\n\t\t\t\t// Catch the most you can\n\t\t\t\treturn true;\n\t\t\t} else if (a === null || b === null || typeof a === \"undefined\" || typeof b === \"undefined\" || QUnit.objectType(a) !== QUnit.objectType(b)) {\n\n\t\t\t\t// Don't lose time with error prone cases\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn typeEquiv(a, b);\n\t\t\t}\n\n\t\t\t// Apply transition with (1..n) arguments\n\t\t}(args[0], args[1]) && innerEquiv.apply(this, args.splice(1, args.length - 1));\n\t}\n\n\treturn innerEquiv;\n}();","ast":null,"map":{"version":3,"sources":["/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/equiv.js"],"names":[],"mappings":"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","file":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/equiv.js.map","sourcesContent":["// Test for equality any JavaScript type.\n// Author: Philippe Rathé <prathe@gmail.com>\nQUnit.equiv = (function() {\n\n\t// Stack to decide between skip/abort functions\n\tvar callers = [];\n\n\t// Stack to avoiding loops from circular referencing\n\tvar parents = [];\n\tvar parentsB = [];\n\n\tfunction useStrictEquality( b, a ) {\n\n\t\t/*jshint eqeqeq:false */\n\t\tif ( b instanceof a.constructor || a instanceof b.constructor ) {\n\n\t\t\t// To catch short annotation VS 'new' annotation of a declaration. e.g.:\n\t\t\t// `var i = 1;`\n\t\t\t// `var j = new Number(1);`\n\t\t\treturn a == b;\n\t\t} else {\n\t\t\treturn a === b;\n\t\t}\n\t}\n\n\tfunction compareConstructors( a, b ) {\n\t\tvar getProto = Object.getPrototypeOf || function( obj ) {\n\n\t\t\t/*jshint proto: true */\n\t\t\treturn obj.__proto__;\n\t\t};\n\t\tvar protoA = getProto( a );\n\t\tvar protoB = getProto( b );\n\n\t\t// Comparing constructors is more strict than using `instanceof`\n\t\tif ( a.constructor === b.constructor ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Ref #851\n\t\t// If the obj prototype descends from a null constructor, treat it\n\t\t// as a null prototype.\n\t\tif ( protoA && protoA.constructor === null ) {\n\t\t\tprotoA = null;\n\t\t}\n\t\tif ( protoB && protoB.constructor === null ) {\n\t\t\tprotoB = null;\n\t\t}\n\n\t\t// Allow objects with no prototype to be equivalent to\n\t\t// objects with Object as their constructor.\n\t\tif ( ( protoA === null && protoB === Object.prototype ) ||\n\t\t\t\t( protoB === null && protoA === Object.prototype ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tvar callbacks = {\n\t\t\"string\": useStrictEquality,\n\t\t\"boolean\": useStrictEquality,\n\t\t\"number\": useStrictEquality,\n\t\t\"null\": useStrictEquality,\n\t\t\"undefined\": useStrictEquality,\n\t\t\"symbol\": useStrictEquality,\n\n\t\t\"nan\": function( b ) {\n\t\t\treturn isNaN( b );\n\t\t},\n\n\t\t\"date\": function( b, a ) {\n\t\t\treturn QUnit.objectType( b ) === \"date\" && a.valueOf() === b.valueOf();\n\t\t},\n\n\t\t\"regexp\": function( b, a ) {\n\t\t\treturn QUnit.objectType( b ) === \"regexp\" &&\n\n\t\t\t\t// The regex itself\n\t\t\t\ta.source === b.source &&\n\n\t\t\t\t// And its modifiers\n\t\t\t\ta.global === b.global &&\n\n\t\t\t\t// (gmi) ...\n\t\t\t\ta.ignoreCase === b.ignoreCase &&\n\t\t\t\ta.multiline === b.multiline &&\n\t\t\t\ta.sticky === b.sticky;\n\t\t},\n\n\t\t// - skip when the property is a method of an instance (OOP)\n\t\t// - abort otherwise,\n\t\t// initial === would have catch identical references anyway\n\t\t\"function\": function() {\n\t\t\tvar caller = callers[ callers.length - 1 ];\n\t\t\treturn caller !== Object && typeof caller !== \"undefined\";\n\t\t},\n\n\t\t\"array\": function( b, a ) {\n\t\t\tvar i, j, len, loop, aCircular, bCircular;\n\n\t\t\t// b could be an object literal here\n\t\t\tif ( QUnit.objectType( b ) !== \"array\" ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlen = a.length;\n\t\t\tif ( len !== b.length ) {\n\t\t\t\t// safe and faster\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Track reference to avoid circular references\n\t\t\tparents.push( a );\n\t\t\tparentsB.push( b );\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\tloop = false;\n\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\tparents.pop();\n\t\t\t\t\tparentsB.pop();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparents.pop();\n\t\t\tparentsB.pop();\n\t\t\treturn true;\n\t\t},\n\n\t\t\"set\": function( b, a ) {\n\t\t\tvar aArray, bArray;\n\n\t\t\t// `b` could be any object here\n\t\t\tif ( QUnit.objectType( b ) !== \"set\" ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\taArray = [];\n\t\t\ta.forEach( function( v ) {\n\t\t\t\taArray.push( v );\n\t\t\t});\n\t\t\tbArray = [];\n\t\t\tb.forEach( function( v ) {\n\t\t\t\tbArray.push( v );\n\t\t\t});\n\n\t\t\treturn innerEquiv( bArray, aArray );\n\t\t},\n\n\t\t\"map\": function( b, a ) {\n\t\t\tvar aArray, bArray;\n\n\t\t\t// `b` could be any object here\n\t\t\tif ( QUnit.objectType( b ) !== \"map\" ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\taArray = [];\n\t\t\ta.forEach( function( v, k ) {\n\t\t\t\taArray.push( [ k, v ] );\n\t\t\t});\n\t\t\tbArray = [];\n\t\t\tb.forEach( function( v, k ) {\n\t\t\t\tbArray.push( [ k, v ] );\n\t\t\t});\n\n\t\t\treturn innerEquiv( bArray, aArray );\n\t\t},\n\n\t\t\"object\": function( b, a ) {\n\t\t\tvar i, j, loop, aCircular, bCircular;\n\n\t\t\t// Default to true\n\t\t\tvar eq = true;\n\t\t\tvar aProperties = [];\n\t\t\tvar bProperties = [];\n\n\t\t\tif ( compareConstructors( a, b ) === false ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Stack constructor before traversing properties\n\t\t\tcallers.push( a.constructor );\n\n\t\t\t// Track reference to avoid circular references\n\t\t\tparents.push( a );\n\t\t\tparentsB.push( b );\n\n\t\t\t// Be strict: don't ensure hasOwnProperty and go deep\n\t\t\tfor ( i in a ) {\n\t\t\t\tloop = false;\n\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taProperties.push( i );\n\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\teq = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparents.pop();\n\t\t\tparentsB.pop();\n\n\t\t\t// Unstack, we are done\n\t\t\tcallers.pop();\n\n\t\t\tfor ( i in b ) {\n\n\t\t\t\t// Collect b's properties\n\t\t\t\tbProperties.push( i );\n\t\t\t}\n\n\t\t\t// Ensures identical properties name\n\t\t\treturn eq && innerEquiv( aProperties.sort(), bProperties.sort() );\n\t\t}\n\t};\n\n\tfunction typeEquiv( a, b ) {\n\t\tvar prop = QUnit.objectType( a );\n\t\treturn callbacks[ prop ]( b, a );\n\t}\n\n\t// The real equiv function\n\tfunction innerEquiv() {\n\t\tvar args = [].slice.apply( arguments );\n\t\tif ( args.length < 2 ) {\n\n\t\t\t// End transition\n\t\t\treturn true;\n\t\t}\n\n\t\treturn ( (function( a, b ) {\n\t\t\tif ( a === b ) {\n\n\t\t\t\t// Catch the most you can\n\t\t\t\treturn true;\n\t\t\t} else if ( a === null || b === null || typeof a === \"undefined\" ||\n\t\t\t\t\ttypeof b === \"undefined\" ||\n\t\t\t\t\tQUnit.objectType( a ) !== QUnit.objectType( b ) ) {\n\n\t\t\t\t// Don't lose time with error prone cases\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn typeEquiv( a, b );\n\t\t\t}\n\n\t\t// Apply transition with (1..n) arguments\n\t\t}( args[ 0 ], args[ 1 ] ) ) &&\n\t\t\tinnerEquiv.apply( this, args.splice( 1, args.length - 1 ) ) );\n\t}\n\n\treturn innerEquiv;\n}());\n"]},"hash":"5ace780d387b2c37f70d56e7b9ea2c481332ae05"}
