{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/test.js","filenameRelative":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/test.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/test.js.map","sourceFileName":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/test.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"test"},"ignored":false,"code":"var focused = false;\n\nfunction Test(settings) {\n\tvar i, l;\n\n\t++Test.count;\n\n\textend(this, settings);\n\tthis.assertions = [];\n\tthis.semaphore = 0;\n\tthis.usedAsync = false;\n\tthis.module = config.currentModule;\n\tthis.stack = sourceFromStacktrace(3);\n\n\t// Register unique strings\n\tfor (i = 0, l = this.module.tests; i < l.length; i++) {\n\t\tif (this.module.tests[i].name === this.testName) {\n\t\t\tthis.testName += \" \";\n\t\t}\n\t}\n\n\tthis.testId = generateHash(this.module.name, this.testName);\n\n\tthis.module.tests.push({\n\t\tname: this.testName,\n\t\ttestId: this.testId\n\t});\n\n\tif (settings.skip) {\n\n\t\t// Skipped tests will fully ignore any sent callback\n\t\tthis.callback = function () {};\n\t\tthis.async = false;\n\t\tthis.expected = 0;\n\t} else {\n\t\tthis.assert = new Assert(this);\n\t}\n}\n\nTest.count = 0;\n\nTest.prototype = {\n\tbefore: function before() {\n\t\tif (\n\n\t\t// Emit moduleStart when we're switching from one module to another\n\t\tthis.module !== config.previousModule ||\n\n\t\t// They could be equal (both undefined) but if the previousModule property doesn't\n\t\t// yet exist it means this is the first test in a suite that isn't wrapped in a\n\t\t// module, in which case we'll just emit a moduleStart event for 'undefined'.\n\t\t// Without this, reporters can get testStart before moduleStart  which is a problem.\n\t\t!hasOwn.call(config, \"previousModule\")) {\n\t\t\tif (hasOwn.call(config, \"previousModule\")) {\n\t\t\t\trunLoggingCallbacks(\"moduleDone\", {\n\t\t\t\t\tname: config.previousModule.name,\n\t\t\t\t\ttests: config.previousModule.tests,\n\t\t\t\t\tfailed: config.moduleStats.bad,\n\t\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\t\t\ttotal: config.moduleStats.all,\n\t\t\t\t\truntime: now() - config.moduleStats.started\n\t\t\t\t});\n\t\t\t}\n\t\t\tconfig.previousModule = this.module;\n\t\t\tconfig.moduleStats = { all: 0, bad: 0, started: now() };\n\t\t\trunLoggingCallbacks(\"moduleStart\", {\n\t\t\t\tname: this.module.name,\n\t\t\t\ttests: this.module.tests\n\t\t\t});\n\t\t}\n\n\t\tconfig.current = this;\n\n\t\tif (this.module.testEnvironment) {\n\t\t\tdelete this.module.testEnvironment.beforeEach;\n\t\t\tdelete this.module.testEnvironment.afterEach;\n\t\t}\n\t\tthis.testEnvironment = extend({}, this.module.testEnvironment);\n\n\t\tthis.started = now();\n\t\trunLoggingCallbacks(\"testStart\", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module.name,\n\t\t\ttestId: this.testId\n\t\t});\n\n\t\tif (!config.pollution) {\n\t\t\tsaveGlobal();\n\t\t}\n\t},\n\n\trun: function run() {\n\t\tvar promise;\n\n\t\tconfig.current = this;\n\n\t\tif (this.async) {\n\t\t\tQUnit.stop();\n\t\t}\n\n\t\tthis.callbackStarted = now();\n\n\t\tif (config.notrycatch) {\n\t\t\trunTest(this);\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\trunTest(this);\n\t\t} catch (e) {\n\t\t\tthis.pushFailure(\"Died on test #\" + (this.assertions.length + 1) + \" \" + this.stack + \": \" + (e.message || e), extractStacktrace(e, 0));\n\n\t\t\t// else next test will carry the responsibility\n\t\t\tsaveGlobal();\n\n\t\t\t// Restart the tests if they're blocking\n\t\t\tif (config.blocking) {\n\t\t\t\tQUnit.start();\n\t\t\t}\n\t\t}\n\n\t\tfunction runTest(test) {\n\t\t\tpromise = test.callback.call(test.testEnvironment, test.assert);\n\t\t\ttest.resolvePromise(promise);\n\t\t}\n\t},\n\n\tafter: function after() {\n\t\tcheckPollution();\n\t},\n\n\tqueueHook: function queueHook(hook, hookName) {\n\t\tvar promise,\n\t\t    test = this;\n\t\treturn function runHook() {\n\t\t\tconfig.current = test;\n\t\t\tif (config.notrycatch) {\n\t\t\t\tcallHook();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tcallHook();\n\t\t\t} catch (error) {\n\t\t\t\ttest.pushFailure(hookName + \" failed on \" + test.testName + \": \" + (error.message || error), extractStacktrace(error, 0));\n\t\t\t}\n\n\t\t\tfunction callHook() {\n\t\t\t\tpromise = hook.call(test.testEnvironment, test.assert);\n\t\t\t\ttest.resolvePromise(promise, hookName);\n\t\t\t}\n\t\t};\n\t},\n\n\t// Currently only used for module level hooks, can be used to add global level ones\n\thooks: function hooks(handler) {\n\t\tvar hooks = [];\n\n\t\tfunction processHooks(test, module) {\n\t\t\tif (module.parentModule) {\n\t\t\t\tprocessHooks(test, module.parentModule);\n\t\t\t}\n\t\t\tif (module.testEnvironment && QUnit.objectType(module.testEnvironment[handler]) === \"function\") {\n\t\t\t\thooks.push(test.queueHook(module.testEnvironment[handler], handler));\n\t\t\t}\n\t\t}\n\n\t\t// Hooks are ignored on skipped tests\n\t\tif (!this.skip) {\n\t\t\tprocessHooks(this, this.module);\n\t\t}\n\t\treturn hooks;\n\t},\n\n\tfinish: function finish() {\n\t\tconfig.current = this;\n\t\tif (config.requireExpects && this.expected === null) {\n\t\t\tthis.pushFailure(\"Expected number of assertions to be defined, but expect() was \" + \"not called.\", this.stack);\n\t\t} else if (this.expected !== null && this.expected !== this.assertions.length) {\n\t\t\tthis.pushFailure(\"Expected \" + this.expected + \" assertions, but \" + this.assertions.length + \" were run\", this.stack);\n\t\t} else if (this.expected === null && !this.assertions.length) {\n\t\t\tthis.pushFailure(\"Expected at least one assertion, but none were run - call \" + \"expect(0) to accept zero assertions.\", this.stack);\n\t\t}\n\n\t\tvar i,\n\t\t    bad = 0;\n\n\t\tthis.runtime = now() - this.started;\n\t\tconfig.stats.all += this.assertions.length;\n\t\tconfig.moduleStats.all += this.assertions.length;\n\n\t\tfor (i = 0; i < this.assertions.length; i++) {\n\t\t\tif (!this.assertions[i].result) {\n\t\t\t\tbad++;\n\t\t\t\tconfig.stats.bad++;\n\t\t\t\tconfig.moduleStats.bad++;\n\t\t\t}\n\t\t}\n\n\t\trunLoggingCallbacks(\"testDone\", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module.name,\n\t\t\tskipped: !!this.skip,\n\t\t\tfailed: bad,\n\t\t\tpassed: this.assertions.length - bad,\n\t\t\ttotal: this.assertions.length,\n\t\t\truntime: this.runtime,\n\n\t\t\t// HTML Reporter use\n\t\t\tassertions: this.assertions,\n\t\t\ttestId: this.testId,\n\n\t\t\t// Source of Test\n\t\t\tsource: this.stack,\n\n\t\t\t// DEPRECATED: this property will be removed in 2.0.0, use runtime instead\n\t\t\tduration: this.runtime\n\t\t});\n\n\t\t// QUnit.reset() is deprecated and will be replaced for a new\n\t\t// fixture reset function on QUnit 2.0/2.1.\n\t\t// It's still called here for backwards compatibility handling\n\t\tQUnit.reset();\n\n\t\tconfig.current = undefined;\n\t},\n\n\tqueue: function queue() {\n\t\tvar priority,\n\t\t    test = this;\n\n\t\tif (!this.valid()) {\n\t\t\treturn;\n\t\t}\n\n\t\tfunction run() {\n\n\t\t\t// each of these can by async\n\t\t\tsynchronize([function () {\n\t\t\t\ttest.before();\n\t\t\t}, test.hooks(\"beforeEach\"), function () {\n\t\t\t\ttest.run();\n\t\t\t}, test.hooks(\"afterEach\").reverse(), function () {\n\t\t\t\ttest.after();\n\t\t\t}, function () {\n\t\t\t\ttest.finish();\n\t\t\t}]);\n\t\t}\n\n\t\t// Prioritize previously failed tests, detected from sessionStorage\n\t\tpriority = QUnit.config.reorder && defined.sessionStorage && +sessionStorage.getItem(\"qunit-test-\" + this.module.name + \"-\" + this.testName);\n\n\t\treturn synchronize(run, priority);\n\t},\n\n\tpush: function push(result, actual, expected, message, negative) {\n\t\tvar source,\n\t\t    details = {\n\t\t\tmodule: this.module.name,\n\t\t\tname: this.testName,\n\t\t\tresult: result,\n\t\t\tmessage: message,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\ttestId: this.testId,\n\t\t\tnegative: negative || false,\n\t\t\truntime: now() - this.started\n\t\t};\n\n\t\tif (!result) {\n\t\t\tsource = sourceFromStacktrace();\n\n\t\t\tif (source) {\n\t\t\t\tdetails.source = source;\n\t\t\t}\n\t\t}\n\n\t\trunLoggingCallbacks(\"log\", details);\n\n\t\tthis.assertions.push({\n\t\t\tresult: !!result,\n\t\t\tmessage: message\n\t\t});\n\t},\n\n\tpushFailure: function pushFailure(message, source, actual) {\n\t\tif (!(this instanceof Test)) {\n\t\t\tthrow new Error(\"pushFailure() assertion outside test context, was \" + sourceFromStacktrace(2));\n\t\t}\n\n\t\tvar details = {\n\t\t\tmodule: this.module.name,\n\t\t\tname: this.testName,\n\t\t\tresult: false,\n\t\t\tmessage: message || \"error\",\n\t\t\tactual: actual || null,\n\t\t\ttestId: this.testId,\n\t\t\truntime: now() - this.started\n\t\t};\n\n\t\tif (source) {\n\t\t\tdetails.source = source;\n\t\t}\n\n\t\trunLoggingCallbacks(\"log\", details);\n\n\t\tthis.assertions.push({\n\t\t\tresult: false,\n\t\t\tmessage: message\n\t\t});\n\t},\n\n\tresolvePromise: function resolvePromise(promise, phase) {\n\t\tvar then,\n\t\t    message,\n\t\t    test = this;\n\t\tif (promise != null) {\n\t\t\tthen = promise.then;\n\t\t\tif (QUnit.objectType(then) === \"function\") {\n\t\t\t\tQUnit.stop();\n\t\t\t\tthen.call(promise, function () {\n\t\t\t\t\tQUnit.start();\n\t\t\t\t}, function (error) {\n\t\t\t\t\tmessage = \"Promise rejected \" + (!phase ? \"during\" : phase.replace(/Each$/, \"\")) + \" \" + test.testName + \": \" + (error.message || error);\n\t\t\t\t\ttest.pushFailure(message, extractStacktrace(error, 0));\n\n\t\t\t\t\t// else next test will carry the responsibility\n\t\t\t\t\tsaveGlobal();\n\n\t\t\t\t\t// Unblock\n\t\t\t\t\tQUnit.start();\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t},\n\n\tvalid: function valid() {\n\t\tvar include,\n\t\t    filter = config.filter && config.filter.toLowerCase(),\n\t\t    module = QUnit.urlParams.module && QUnit.urlParams.module.toLowerCase(),\n\t\t    fullName = (this.module.name + \": \" + this.testName).toLowerCase();\n\n\t\tfunction testInModuleChain(testModule) {\n\t\t\tvar testModuleName = testModule.name ? testModule.name.toLowerCase() : null;\n\t\t\tif (testModuleName === module) {\n\t\t\t\treturn true;\n\t\t\t} else if (testModule.parentModule) {\n\t\t\t\treturn testInModuleChain(testModule.parentModule);\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Internally-generated tests are always valid\n\t\tif (this.callback && this.callback.validTest) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (config.testId.length > 0 && inArray(this.testId, config.testId) < 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (module && !testInModuleChain(this.module)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!filter) {\n\t\t\treturn true;\n\t\t}\n\n\t\tinclude = filter.charAt(0) !== \"!\";\n\t\tif (!include) {\n\t\t\tfilter = filter.slice(1);\n\t\t}\n\n\t\t// If the filter matches, we need to honour include\n\t\tif (fullName.indexOf(filter) !== -1) {\n\t\t\treturn include;\n\t\t}\n\n\t\t// Otherwise, do the opposite\n\t\treturn !include;\n\t}\n};\n\n// Resets the test setup. Useful for tests that modify the DOM.\n/*\nDEPRECATED: Use multiple tests instead of resetting inside a test.\nUse testStart or testDone for custom cleanup.\nThis method will throw an error in 2.0, and will be removed in 2.1\n*/\nQUnit.reset = function () {\n\n\t// Return on non-browser environments\n\t// This is necessary to not break on node tests\n\tif (!defined.document) {\n\t\treturn;\n\t}\n\n\tvar fixture = defined.document && document.getElementById && document.getElementById(\"qunit-fixture\");\n\n\tif (fixture) {\n\t\tfixture.innerHTML = config.fixture;\n\t}\n};\n\nQUnit.pushFailure = function () {\n\tif (!QUnit.config.current) {\n\t\tthrow new Error(\"pushFailure() assertion outside test context, in \" + sourceFromStacktrace(2));\n\t}\n\n\t// Gets current test obj\n\tvar currentTest = QUnit.config.current;\n\n\treturn currentTest.pushFailure.apply(currentTest, arguments);\n};\n\n// Based on Java's String.hashCode, a simple but not\n// rigorously collision resistant hashing function\nfunction generateHash(module, testName) {\n\tvar hex,\n\t    i = 0,\n\t    hash = 0,\n\t    str = module + \"\\x1C\" + testName,\n\t    len = str.length;\n\n\tfor (; i < len; i++) {\n\t\thash = (hash << 5) - hash + str.charCodeAt(i);\n\t\thash |= 0;\n\t}\n\n\t// Convert the possibly negative integer hash code into an 8 character hex string, which isn't\n\t// strictly necessary but increases user understanding that the id is a SHA-like hash\n\thex = (0x100000000 + hash).toString(16);\n\tif (hex.length < 8) {\n\t\thex = \"0000000\" + hex;\n\t}\n\n\treturn hex.slice(-8);\n}\n\nfunction synchronize(callback, priority) {\n\tvar last = !priority;\n\n\tif (QUnit.objectType(callback) === \"array\") {\n\t\twhile (callback.length) {\n\t\t\tsynchronize(callback.shift());\n\t\t}\n\t\treturn;\n\t}\n\n\tif (priority) {\n\t\tpriorityFill(callback);\n\t} else {\n\t\tconfig.queue.push(callback);\n\t}\n\n\tif (config.autorun && !config.blocking) {\n\t\tprocess(last);\n\t}\n}\n\n// Place previously failed tests on a queue priority line, respecting the order they get assigned.\nfunction priorityFill(callback) {\n\tvar queue, prioritizedQueue;\n\n\tqueue = config.queue.slice(priorityFill.pos);\n\tprioritizedQueue = config.queue.slice(0, -config.queue.length + priorityFill.pos);\n\n\tqueue.unshift(callback);\n\tqueue.unshift.apply(queue, prioritizedQueue);\n\n\tconfig.queue = queue;\n\n\tpriorityFill.pos += 1;\n}\npriorityFill.pos = 0;\n\nfunction saveGlobal() {\n\tconfig.pollution = [];\n\n\tif (config.noglobals) {\n\t\tfor (var key in global) {\n\t\t\tif (hasOwn.call(global, key)) {\n\n\t\t\t\t// in Opera sometimes DOM element ids show up here, ignore them\n\t\t\t\tif (/^qunit-test-output/.test(key)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconfig.pollution.push(key);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction checkPollution() {\n\tvar newGlobals,\n\t    deletedGlobals,\n\t    old = config.pollution;\n\n\tsaveGlobal();\n\n\tnewGlobals = diff(config.pollution, old);\n\tif (newGlobals.length > 0) {\n\t\tQUnit.pushFailure(\"Introduced global variable(s): \" + newGlobals.join(\", \"));\n\t}\n\n\tdeletedGlobals = diff(old, config.pollution);\n\tif (deletedGlobals.length > 0) {\n\t\tQUnit.pushFailure(\"Deleted global variable(s): \" + deletedGlobals.join(\", \"));\n\t}\n}\n\n// Will be exposed as QUnit.asyncTest\nfunction asyncTest(testName, expected, callback) {\n\tif (arguments.length === 2) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tQUnit.test(testName, expected, callback, true);\n}\n\n// Will be exposed as QUnit.test\nfunction test(testName, expected, callback, async) {\n\tif (focused) {\n\t\treturn;\n\t}\n\n\tvar newTest;\n\n\tif (arguments.length === 2) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tnewTest = new Test({\n\t\ttestName: testName,\n\t\texpected: expected,\n\t\tasync: async,\n\t\tcallback: callback\n\t});\n\n\tnewTest.queue();\n}\n\n// Will be exposed as QUnit.skip\nfunction skip(testName) {\n\tif (focused) {\n\t\treturn;\n\t}\n\n\tvar test = new Test({\n\t\ttestName: testName,\n\t\tskip: true\n\t});\n\n\ttest.queue();\n}\n\n// Will be exposed as QUnit.only\nfunction only(testName, expected, callback, async) {\n\tvar newTest;\n\n\tif (focused) {\n\t\treturn;\n\t}\n\n\tQUnit.config.queue.length = 0;\n\tfocused = true;\n\n\tif (arguments.length === 2) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tnewTest = new Test({\n\t\ttestName: testName,\n\t\texpected: expected,\n\t\tasync: async,\n\t\tcallback: callback\n\t});\n\n\tnewTest.queue();\n}","ast":null,"map":{"version":3,"sources":["/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/test.js"],"names":[],"mappings":"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","file":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/test.js.map","sourcesContent":["var focused = false;\n\nfunction Test( settings ) {\n\tvar i, l;\n\n\t++Test.count;\n\n\textend( this, settings );\n\tthis.assertions = [];\n\tthis.semaphore = 0;\n\tthis.usedAsync = false;\n\tthis.module = config.currentModule;\n\tthis.stack = sourceFromStacktrace( 3 );\n\n\t// Register unique strings\n\tfor ( i = 0, l = this.module.tests; i < l.length; i++ ) {\n\t\tif ( this.module.tests[ i ].name === this.testName ) {\n\t\t\tthis.testName += \" \";\n\t\t}\n\t}\n\n\tthis.testId = generateHash( this.module.name, this.testName );\n\n\tthis.module.tests.push({\n\t\tname: this.testName,\n\t\ttestId: this.testId\n\t});\n\n\tif ( settings.skip ) {\n\n\t\t// Skipped tests will fully ignore any sent callback\n\t\tthis.callback = function() {};\n\t\tthis.async = false;\n\t\tthis.expected = 0;\n\t} else {\n\t\tthis.assert = new Assert( this );\n\t}\n}\n\nTest.count = 0;\n\nTest.prototype = {\n\tbefore: function() {\n\t\tif (\n\n\t\t\t// Emit moduleStart when we're switching from one module to another\n\t\t\tthis.module !== config.previousModule ||\n\n\t\t\t\t// They could be equal (both undefined) but if the previousModule property doesn't\n\t\t\t\t// yet exist it means this is the first test in a suite that isn't wrapped in a\n\t\t\t\t// module, in which case we'll just emit a moduleStart event for 'undefined'.\n\t\t\t\t// Without this, reporters can get testStart before moduleStart  which is a problem.\n\t\t\t\t!hasOwn.call( config, \"previousModule\" )\n\t\t) {\n\t\t\tif ( hasOwn.call( config, \"previousModule\" ) ) {\n\t\t\t\trunLoggingCallbacks( \"moduleDone\", {\n\t\t\t\t\tname: config.previousModule.name,\n\t\t\t\t\ttests: config.previousModule.tests,\n\t\t\t\t\tfailed: config.moduleStats.bad,\n\t\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\t\t\ttotal: config.moduleStats.all,\n\t\t\t\t\truntime: now() - config.moduleStats.started\n\t\t\t\t});\n\t\t\t}\n\t\t\tconfig.previousModule = this.module;\n\t\t\tconfig.moduleStats = { all: 0, bad: 0, started: now() };\n\t\t\trunLoggingCallbacks( \"moduleStart\", {\n\t\t\t\tname: this.module.name,\n\t\t\t\ttests: this.module.tests\n\t\t\t});\n\t\t}\n\n\t\tconfig.current = this;\n\n\t\tif ( this.module.testEnvironment ) {\n\t\t\tdelete this.module.testEnvironment.beforeEach;\n\t\t\tdelete this.module.testEnvironment.afterEach;\n\t\t}\n\t\tthis.testEnvironment = extend( {}, this.module.testEnvironment );\n\n\t\tthis.started = now();\n\t\trunLoggingCallbacks( \"testStart\", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module.name,\n\t\t\ttestId: this.testId\n\t\t});\n\n\t\tif ( !config.pollution ) {\n\t\t\tsaveGlobal();\n\t\t}\n\t},\n\n\trun: function() {\n\t\tvar promise;\n\n\t\tconfig.current = this;\n\n\t\tif ( this.async ) {\n\t\t\tQUnit.stop();\n\t\t}\n\n\t\tthis.callbackStarted = now();\n\n\t\tif ( config.notrycatch ) {\n\t\t\trunTest( this );\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\trunTest( this );\n\t\t} catch ( e ) {\n\t\t\tthis.pushFailure( \"Died on test #\" + ( this.assertions.length + 1 ) + \" \" +\n\t\t\t\tthis.stack + \": \" + ( e.message || e ), extractStacktrace( e, 0 ) );\n\n\t\t\t// else next test will carry the responsibility\n\t\t\tsaveGlobal();\n\n\t\t\t// Restart the tests if they're blocking\n\t\t\tif ( config.blocking ) {\n\t\t\t\tQUnit.start();\n\t\t\t}\n\t\t}\n\n\t\tfunction runTest( test ) {\n\t\t\tpromise = test.callback.call( test.testEnvironment, test.assert );\n\t\t\ttest.resolvePromise( promise );\n\t\t}\n\t},\n\n\tafter: function() {\n\t\tcheckPollution();\n\t},\n\n\tqueueHook: function( hook, hookName ) {\n\t\tvar promise,\n\t\t\ttest = this;\n\t\treturn function runHook() {\n\t\t\tconfig.current = test;\n\t\t\tif ( config.notrycatch ) {\n\t\t\t\tcallHook();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tcallHook();\n\t\t\t} catch ( error ) {\n\t\t\t\ttest.pushFailure( hookName + \" failed on \" + test.testName + \": \" +\n\t\t\t\t( error.message || error ), extractStacktrace( error, 0 ) );\n\t\t\t}\n\n\t\t\tfunction callHook() {\n\t\t\t\tpromise = hook.call( test.testEnvironment, test.assert );\n\t\t\t\ttest.resolvePromise( promise, hookName );\n\t\t\t}\n\t\t};\n\t},\n\n\t// Currently only used for module level hooks, can be used to add global level ones\n\thooks: function( handler ) {\n\t\tvar hooks = [];\n\n\t\tfunction processHooks( test, module ) {\n\t\t\tif ( module.parentModule ) {\n\t\t\t\tprocessHooks( test, module.parentModule );\n\t\t\t}\n\t\t\tif ( module.testEnvironment &&\n\t\t\t\tQUnit.objectType( module.testEnvironment[ handler ] ) === \"function\" ) {\n\t\t\t\thooks.push( test.queueHook( module.testEnvironment[ handler ], handler ) );\n\t\t\t}\n\t\t}\n\n\t\t// Hooks are ignored on skipped tests\n\t\tif ( !this.skip ) {\n\t\t\tprocessHooks( this, this.module );\n\t\t}\n\t\treturn hooks;\n\t},\n\n\tfinish: function() {\n\t\tconfig.current = this;\n\t\tif ( config.requireExpects && this.expected === null ) {\n\t\t\tthis.pushFailure( \"Expected number of assertions to be defined, but expect() was \" +\n\t\t\t\t\"not called.\", this.stack );\n\t\t} else if ( this.expected !== null && this.expected !== this.assertions.length ) {\n\t\t\tthis.pushFailure( \"Expected \" + this.expected + \" assertions, but \" +\n\t\t\t\tthis.assertions.length + \" were run\", this.stack );\n\t\t} else if ( this.expected === null && !this.assertions.length ) {\n\t\t\tthis.pushFailure( \"Expected at least one assertion, but none were run - call \" +\n\t\t\t\t\"expect(0) to accept zero assertions.\", this.stack );\n\t\t}\n\n\t\tvar i,\n\t\t\tbad = 0;\n\n\t\tthis.runtime = now() - this.started;\n\t\tconfig.stats.all += this.assertions.length;\n\t\tconfig.moduleStats.all += this.assertions.length;\n\n\t\tfor ( i = 0; i < this.assertions.length; i++ ) {\n\t\t\tif ( !this.assertions[ i ].result ) {\n\t\t\t\tbad++;\n\t\t\t\tconfig.stats.bad++;\n\t\t\t\tconfig.moduleStats.bad++;\n\t\t\t}\n\t\t}\n\n\t\trunLoggingCallbacks( \"testDone\", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module.name,\n\t\t\tskipped: !!this.skip,\n\t\t\tfailed: bad,\n\t\t\tpassed: this.assertions.length - bad,\n\t\t\ttotal: this.assertions.length,\n\t\t\truntime: this.runtime,\n\n\t\t\t// HTML Reporter use\n\t\t\tassertions: this.assertions,\n\t\t\ttestId: this.testId,\n\n\t\t\t// Source of Test\n\t\t\tsource: this.stack,\n\n\t\t\t// DEPRECATED: this property will be removed in 2.0.0, use runtime instead\n\t\t\tduration: this.runtime\n\t\t});\n\n\t\t// QUnit.reset() is deprecated and will be replaced for a new\n\t\t// fixture reset function on QUnit 2.0/2.1.\n\t\t// It's still called here for backwards compatibility handling\n\t\tQUnit.reset();\n\n\t\tconfig.current = undefined;\n\t},\n\n\tqueue: function() {\n\t\tvar priority,\n\t\t\ttest = this;\n\n\t\tif ( !this.valid() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfunction run() {\n\n\t\t\t// each of these can by async\n\t\t\tsynchronize([\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.before();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( \"beforeEach\" ),\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.run();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( \"afterEach\" ).reverse(),\n\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.after();\n\t\t\t\t},\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.finish();\n\t\t\t\t}\n\t\t\t]);\n\t\t}\n\n\t\t// Prioritize previously failed tests, detected from sessionStorage\n\t\tpriority = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t\t+sessionStorage.getItem( \"qunit-test-\" + this.module.name + \"-\" + this.testName );\n\n\t\treturn synchronize( run, priority );\n\t},\n\n\tpush: function( result, actual, expected, message, negative ) {\n\t\tvar source,\n\t\t\tdetails = {\n\t\t\t\tmodule: this.module.name,\n\t\t\t\tname: this.testName,\n\t\t\t\tresult: result,\n\t\t\t\tmessage: message,\n\t\t\t\tactual: actual,\n\t\t\t\texpected: expected,\n\t\t\t\ttestId: this.testId,\n\t\t\t\tnegative: negative || false,\n\t\t\t\truntime: now() - this.started\n\t\t\t};\n\n\t\tif ( !result ) {\n\t\t\tsource = sourceFromStacktrace();\n\n\t\t\tif ( source ) {\n\t\t\t\tdetails.source = source;\n\t\t\t}\n\t\t}\n\n\t\trunLoggingCallbacks( \"log\", details );\n\n\t\tthis.assertions.push({\n\t\t\tresult: !!result,\n\t\t\tmessage: message\n\t\t});\n\t},\n\n\tpushFailure: function( message, source, actual ) {\n\t\tif ( !( this instanceof Test ) ) {\n\t\t\tthrow new Error( \"pushFailure() assertion outside test context, was \" +\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t}\n\n\t\tvar details = {\n\t\t\t\tmodule: this.module.name,\n\t\t\t\tname: this.testName,\n\t\t\t\tresult: false,\n\t\t\t\tmessage: message || \"error\",\n\t\t\t\tactual: actual || null,\n\t\t\t\ttestId: this.testId,\n\t\t\t\truntime: now() - this.started\n\t\t\t};\n\n\t\tif ( source ) {\n\t\t\tdetails.source = source;\n\t\t}\n\n\t\trunLoggingCallbacks( \"log\", details );\n\n\t\tthis.assertions.push({\n\t\t\tresult: false,\n\t\t\tmessage: message\n\t\t});\n\t},\n\n\tresolvePromise: function( promise, phase ) {\n\t\tvar then, message,\n\t\t\ttest = this;\n\t\tif ( promise != null ) {\n\t\t\tthen = promise.then;\n\t\t\tif ( QUnit.objectType( then ) === \"function\" ) {\n\t\t\t\tQUnit.stop();\n\t\t\t\tthen.call(\n\t\t\t\t\tpromise,\n\t\t\t\t\tfunction() { QUnit.start(); },\n\t\t\t\t\tfunction( error ) {\n\t\t\t\t\t\tmessage = \"Promise rejected \" +\n\t\t\t\t\t\t\t( !phase ? \"during\" : phase.replace( /Each$/, \"\" ) ) +\n\t\t\t\t\t\t\t\" \" + test.testName + \": \" + ( error.message || error );\n\t\t\t\t\t\ttest.pushFailure( message, extractStacktrace( error, 0 ) );\n\n\t\t\t\t\t\t// else next test will carry the responsibility\n\t\t\t\t\t\tsaveGlobal();\n\n\t\t\t\t\t\t// Unblock\n\t\t\t\t\t\tQUnit.start();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t},\n\n\tvalid: function() {\n\t\tvar include,\n\t\t\tfilter = config.filter && config.filter.toLowerCase(),\n\t\t\tmodule = QUnit.urlParams.module && QUnit.urlParams.module.toLowerCase(),\n\t\t\tfullName = ( this.module.name + \": \" + this.testName ).toLowerCase();\n\n\t\tfunction testInModuleChain( testModule ) {\n\t\t\tvar testModuleName = testModule.name ? testModule.name.toLowerCase() : null;\n\t\t\tif ( testModuleName === module ) {\n\t\t\t\treturn true;\n\t\t\t} else if ( testModule.parentModule ) {\n\t\t\t\treturn testInModuleChain( testModule.parentModule );\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Internally-generated tests are always valid\n\t\tif ( this.callback && this.callback.validTest ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( config.testId.length > 0 && inArray( this.testId, config.testId ) < 0 ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( module && !testInModuleChain( this.module ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( !filter ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tinclude = filter.charAt( 0 ) !== \"!\";\n\t\tif ( !include ) {\n\t\t\tfilter = filter.slice( 1 );\n\t\t}\n\n\t\t// If the filter matches, we need to honour include\n\t\tif ( fullName.indexOf( filter ) !== -1 ) {\n\t\t\treturn include;\n\t\t}\n\n\t\t// Otherwise, do the opposite\n\t\treturn !include;\n\t}\n};\n\n// Resets the test setup. Useful for tests that modify the DOM.\n/*\nDEPRECATED: Use multiple tests instead of resetting inside a test.\nUse testStart or testDone for custom cleanup.\nThis method will throw an error in 2.0, and will be removed in 2.1\n*/\nQUnit.reset = function() {\n\n\t// Return on non-browser environments\n\t// This is necessary to not break on node tests\n\tif ( !defined.document ) {\n\t\treturn;\n\t}\n\n\tvar fixture = defined.document && document.getElementById &&\n\t\t\tdocument.getElementById( \"qunit-fixture\" );\n\n\tif ( fixture ) {\n\t\tfixture.innerHTML = config.fixture;\n\t}\n};\n\nQUnit.pushFailure = function() {\n\tif ( !QUnit.config.current ) {\n\t\tthrow new Error( \"pushFailure() assertion outside test context, in \" +\n\t\t\tsourceFromStacktrace( 2 ) );\n\t}\n\n\t// Gets current test obj\n\tvar currentTest = QUnit.config.current;\n\n\treturn currentTest.pushFailure.apply( currentTest, arguments );\n};\n\n// Based on Java's String.hashCode, a simple but not\n// rigorously collision resistant hashing function\nfunction generateHash( module, testName ) {\n\tvar hex,\n\t\ti = 0,\n\t\thash = 0,\n\t\tstr = module + \"\\x1C\" + testName,\n\t\tlen = str.length;\n\n\tfor ( ; i < len; i++ ) {\n\t\thash  = ( ( hash << 5 ) - hash ) + str.charCodeAt( i );\n\t\thash |= 0;\n\t}\n\n\t// Convert the possibly negative integer hash code into an 8 character hex string, which isn't\n\t// strictly necessary but increases user understanding that the id is a SHA-like hash\n\thex = ( 0x100000000 + hash ).toString( 16 );\n\tif ( hex.length < 8 ) {\n\t\thex = \"0000000\" + hex;\n\t}\n\n\treturn hex.slice( -8 );\n}\n\nfunction synchronize( callback, priority ) {\n\tvar last = !priority;\n\n\tif ( QUnit.objectType( callback ) === \"array\" ) {\n\t\twhile ( callback.length ) {\n\t\t\tsynchronize( callback.shift() );\n\t\t}\n\t\treturn;\n\t}\n\n\tif ( priority ) {\n\t\tpriorityFill( callback );\n\t} else {\n\t\tconfig.queue.push( callback );\n\t}\n\n\tif ( config.autorun && !config.blocking ) {\n\t\tprocess( last );\n\t}\n}\n\n// Place previously failed tests on a queue priority line, respecting the order they get assigned.\nfunction priorityFill( callback ) {\n\tvar queue, prioritizedQueue;\n\n\tqueue = config.queue.slice( priorityFill.pos );\n\tprioritizedQueue = config.queue.slice( 0, -config.queue.length + priorityFill.pos );\n\n\tqueue.unshift( callback );\n\tqueue.unshift.apply( queue, prioritizedQueue );\n\n\tconfig.queue = queue;\n\n\tpriorityFill.pos += 1;\n}\npriorityFill.pos = 0;\n\nfunction saveGlobal() {\n\tconfig.pollution = [];\n\n\tif ( config.noglobals ) {\n\t\tfor ( var key in global ) {\n\t\t\tif ( hasOwn.call( global, key ) ) {\n\n\t\t\t\t// in Opera sometimes DOM element ids show up here, ignore them\n\t\t\t\tif ( /^qunit-test-output/.test( key ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconfig.pollution.push( key );\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction checkPollution() {\n\tvar newGlobals,\n\t\tdeletedGlobals,\n\t\told = config.pollution;\n\n\tsaveGlobal();\n\n\tnewGlobals = diff( config.pollution, old );\n\tif ( newGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( \"Introduced global variable(s): \" + newGlobals.join( \", \" ) );\n\t}\n\n\tdeletedGlobals = diff( old, config.pollution );\n\tif ( deletedGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( \"Deleted global variable(s): \" + deletedGlobals.join( \", \" ) );\n\t}\n}\n\n// Will be exposed as QUnit.asyncTest\nfunction asyncTest( testName, expected, callback ) {\n\tif ( arguments.length === 2 ) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tQUnit.test( testName, expected, callback, true );\n}\n\n// Will be exposed as QUnit.test\nfunction test( testName, expected, callback, async ) {\n\tif ( focused )  { return; }\n\n\tvar newTest;\n\n\tif ( arguments.length === 2 ) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tnewTest = new Test({\n\t\ttestName: testName,\n\t\texpected: expected,\n\t\tasync: async,\n\t\tcallback: callback\n\t});\n\n\tnewTest.queue();\n}\n\n// Will be exposed as QUnit.skip\nfunction skip( testName ) {\n\tif ( focused )  { return; }\n\n\tvar test = new Test({\n\t\ttestName: testName,\n\t\tskip: true\n\t});\n\n\ttest.queue();\n}\n\n// Will be exposed as QUnit.only\nfunction only( testName, expected, callback, async ) {\n\tvar newTest;\n\n\tif ( focused )  { return; }\n\n\tQUnit.config.queue.length = 0;\n\tfocused = true;\n\n\tif ( arguments.length === 2 ) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tnewTest = new Test({\n\t\ttestName: testName,\n\t\texpected: expected,\n\t\tasync: async,\n\t\tcallback: callback\n\t});\n\n\tnewTest.queue();\n}\n"]},"hash":"b47c5575ac09e11e9428c4e3a3d6f9bd263bfda1"}
