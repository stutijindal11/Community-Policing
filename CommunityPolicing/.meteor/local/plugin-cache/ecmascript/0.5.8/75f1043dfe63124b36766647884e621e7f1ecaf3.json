{"metadata":{"usedHelpers":["typeof"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/modernizr/test/js/lib/jsonselect.js","filenameRelative":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/modernizr/test/js/lib/jsonselect.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/modernizr/test/js/lib/jsonselect.js.map","sourceFileName":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/modernizr/test/js/lib/jsonselect.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"jsonselect"},"ignored":false,"code":"var _typeof;module.import(\"babel-runtime/helpers/typeof\",{\"default\":function(v){_typeof=v}});\n/*! Copyright (c) 2011, Lloyd Hilaiel, ISC License */\n/*\n * This is the JSONSelect reference implementation, in javascript.\n */\n(function (exports) {\n\n    var // localize references\n    toString = Object.prototype.toString;\n\n    function jsonParse(str) {\n        try {\n            if (JSON && JSON.parse) {\n                return JSON.parse(str);\n            }\n            return new Function(\"return \" + str)();\n        } catch (e) {\n            te(\"ijs\");\n        }\n    }\n\n    // emitted error codes.\n    var errorCodes = {\n        \"ijs\": \"invalid json string\",\n        \"mpc\": \"multiple pseudo classes (:xxx) not allowed\",\n        \"mepf\": \"malformed expression in pseudo-function\",\n        \"nmi\": \"multiple ids not allowed\",\n        \"se\": \"selector expected\",\n        \"sra\": \"string required after '.'\",\n        \"uc\": \"unrecognized char\",\n        \"ujs\": \"unclosed json string\",\n        \"upc\": \"unrecognized pseudo class\"\n    };\n\n    // throw an error message\n    function te(ec) {\n        throw new Error(errorCodes[ec]);\n    }\n\n    // THE LEXER\n    var toks = {\n        psc: 1, // pseudo class\n        psf: 2, // pseudo class function\n        typ: 3, // type\n        str: 4 // string\n    };\n\n    var pat = /^(?:([\\r\\n\\t\\ ]+)|([*.,>])|(string|boolean|null|array|object|number)|(:(?:root|first-child|last-child|only-child))|(:(?:nth-child|nth-last-child))|(:\\w+)|(\\\"(?:[^\\\\]|\\\\[^\\\"])*\\\")|(\\\")|((?:[_a-zA-Z]|[^\\0-\\0177]|\\\\[^\\r\\n\\f0-9a-fA-F])(?:[_a-zA-Z0-9\\-]|[^\\u0000-\\u0177]|(?:\\\\[^\\r\\n\\f0-9a-fA-F]))*))/;\n    var exprPat = /^\\s*\\(\\s*(?:([+\\-]?)([0-9]*)n\\s*(?:([+\\-])\\s*([0-9]))?|(odd|even)|([+\\-]?[0-9]+))\\s*\\)/;\n    var lex = function lex(str, off) {\n        if (!off) off = 0;\n        var m = pat.exec(str.substr(off));\n        if (!m) return undefined;\n        off += m[0].length;\n        var a;\n        if (m[1]) a = [off, \" \"];else if (m[2]) a = [off, m[0]];else if (m[3]) a = [off, toks.typ, m[0]];else if (m[4]) a = [off, toks.psc, m[0]];else if (m[5]) a = [off, toks.psf, m[0]];else if (m[6]) te(\"upc\");else if (m[7]) a = [off, toks.str, jsonParse(m[0])];else if (m[8]) te(\"ujs\");else if (m[9]) a = [off, toks.str, m[0].replace(/\\\\([^\\r\\n\\f0-9a-fA-F])/g, \"$1\")];\n        return a;\n    };\n\n    // THE PARSER\n\n    var parse = function parse(str) {\n        var a = [],\n            off = 0,\n            am;\n\n        while (true) {\n            var s = parse_selector(str, off);\n            a.push(s[1]);\n            s = lex(str, off = s[0]);\n            if (s && s[1] === \" \") s = lex(str, off = s[0]);\n            if (!s) break;\n            // now we've parsed a selector, and have something else...\n            if (s[1] === \">\") {\n                a.push(\">\");\n                off = s[0];\n            } else if (s[1] === \",\") {\n                if (am === undefined) am = [\",\", a];else am.push(a);\n                a = [];\n                off = s[0];\n            }\n        }\n        if (am) am.push(a);\n        return am ? am : a;\n    };\n\n    var parse_selector = function parse_selector(str, off) {\n        var soff = off;\n        var s = {};\n        var l = lex(str, off);\n        // skip space\n        if (l && l[1] === \" \") {\n            soff = off = l[0];l = lex(str, off);\n        }\n        if (l && l[1] === toks.typ) {\n            s.type = l[2];\n            l = lex(str, off = l[0]);\n        } else if (l && l[1] === \"*\") {\n            // don't bother representing the universal sel, '*' in the\n            // parse tree, cause it's the default\n            l = lex(str, off = l[0]);\n        }\n\n        // now support either an id or a pc\n        while (true) {\n            if (l === undefined) {\n                break;\n            } else if (l[1] === \".\") {\n                l = lex(str, off = l[0]);\n                if (!l || l[1] !== toks.str) te(\"sra\");\n                if (s.id) te(\"nmi\");\n                s.id = l[2];\n            } else if (l[1] === toks.psc) {\n                if (s.pc || s.pf) te(\"mpc\");\n                // collapse first-child and last-child into nth-child expressions\n                if (l[2] === \":first-child\") {\n                    s.pf = \":nth-child\";\n                    s.a = 0;\n                    s.b = 1;\n                } else if (l[2] === \":last-child\") {\n                    s.pf = \":nth-last-child\";\n                    s.a = 0;\n                    s.b = 1;\n                } else {\n                    s.pc = l[2];\n                }\n            } else if (l[1] === toks.psf) {\n                if (s.pc || s.pf) te(\"mpc\");\n                s.pf = l[2];\n                var m = exprPat.exec(str.substr(l[0]));\n                if (!m) te(\"mepf\");\n                if (m[5]) {\n                    s.a = 2;\n                    s.b = m[5] === \"odd\" ? 1 : 0;\n                } else if (m[6]) {\n                    s.a = 0;\n                    s.b = parseInt(m[6], 10);\n                } else {\n                    s.a = parseInt((m[1] ? m[1] : \"+\") + (m[2] ? m[2] : \"1\"), 10);\n                    s.b = m[3] ? parseInt(m[3] + m[4], 10) : 0;\n                }\n                l[0] += m[0].length;\n            } else {\n                break;\n            }\n            l = lex(str, off = l[0]);\n        }\n\n        // now if we didn't actually parse anything it's an error\n        if (soff === off) te(\"se\");\n\n        return [off, s];\n    };\n\n    // THE EVALUATOR\n\n    function isArray(o) {\n        return Array.isArray ? Array.isArray(o) : toString.call(o) === \"[object Array]\";\n    }\n\n    function mytypeof(o) {\n        if (o === null) return \"null\";\n        var to = typeof o === \"undefined\" ? \"undefined\" : _typeof(o);\n        if (to === \"object\" && isArray(o)) to = \"array\";\n        return to;\n    }\n\n    function mn(node, sel, id, num, tot) {\n        var sels = [];\n        var cs = sel[0] === \">\" ? sel[1] : sel[0];\n        var m = true,\n            mod;\n        if (cs.type) m = m && cs.type === mytypeof(node);\n        if (cs.id) m = m && cs.id === id;\n        if (m && cs.pf) {\n            if (cs.pf === \":nth-last-child\") num = tot - num;else num++;\n            if (cs.a === 0) {\n                m = cs.b === num;\n            } else {\n                mod = (num - cs.b) % cs.a;\n\n                m = !mod && num * cs.a + cs.b >= 0;\n            }\n        }\n\n        // should we repeat this selector for descendants?\n        if (sel[0] !== \">\" && sel[0].pc !== \":root\") sels.push(sel);\n\n        if (m) {\n            // is there a fragment that we should pass down?\n            if (sel[0] === \">\") {\n                if (sel.length > 2) {\n                    m = false;sels.push(sel.slice(2));\n                }\n            } else if (sel.length > 1) {\n                m = false;sels.push(sel.slice(1));\n            }\n        }\n\n        return [m, sels];\n    }\n\n    function _forEach(sel, obj, fun, id, num, tot) {\n        var a = sel[0] === \",\" ? sel.slice(1) : [sel],\n            a0 = [],\n            call = false,\n            i = 0,\n            j = 0,\n            l = 0,\n            k,\n            x;\n        for (i = 0; i < a.length; i++) {\n            x = mn(obj, a[i], id, num, tot);\n            if (x[0]) {\n                call = true;\n            }\n            for (j = 0; j < x[1].length; j++) {\n                a0.push(x[1][j]);\n            }\n        }\n        if (a0.length && (typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) === \"object\") {\n            if (a0.length >= 1) {\n                a0.unshift(\",\");\n            }\n            if (isArray(obj)) {\n                for (i = 0; i < obj.length; i++) {\n                    _forEach(a0, obj[i], fun, undefined, i, obj.length);\n                }\n            } else {\n                // it's a shame to do this for :last-child and other\n                // properties which count from the end when we don't\n                // even know if they're present.  Also, the stream\n                // parser is going to be pissed.\n                l = 0;\n                for (k in obj) {\n                    if (obj.hasOwnProperty(k)) {\n                        l++;\n                    }\n                }\n                i = 0;\n                for (k in obj) {\n                    if (obj.hasOwnProperty(k)) {\n                        _forEach(a0, obj[k], fun, k, i++, l);\n                    }\n                }\n            }\n        }\n        if (call && fun) {\n            fun(obj);\n        }\n    }\n\n    function _match(sel, obj) {\n        var a = [];\n        _forEach(sel, obj, function (x) {\n            a.push(x);\n        });\n        return a;\n    }\n\n    function compile(sel) {\n        return {\n            sel: parse(sel),\n            match: function match(obj) {\n                return _match(this.sel, obj);\n            },\n            forEach: function forEach(obj, fun) {\n                return _forEach(this.sel, obj, fun);\n            }\n        };\n    }\n\n    exports._lex = lex;\n    exports._parse = parse;\n    exports.match = function (sel, obj) {\n        return compile(sel).match(obj);\n    };\n    exports.forEach = function (sel, obj, fun) {\n        return compile(sel).forEach(obj, fun);\n    };\n    exports.compile = compile;\n})(typeof exports === \"undefined\" ? window.JSONSelect = {} : exports);","ast":null,"map":{"version":3,"sources":["/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/modernizr/test/js/lib/jsonselect.js"],"names":[],"mappings":"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","file":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/modernizr/test/js/lib/jsonselect.js.map","sourcesContent":["/*! Copyright (c) 2011, Lloyd Hilaiel, ISC License */\n/*\n * This is the JSONSelect reference implementation, in javascript.\n */\n(function(exports) {\n\n    var // localize references\n    toString = Object.prototype.toString;\n\n    function jsonParse(str) {\n      try {\n          if(JSON && JSON.parse){\n              return JSON.parse(str);\n          }\n          return (new Function(\"return \" + str))();\n      } catch(e) {\n        te(\"ijs\");\n      }\n    }\n\n    // emitted error codes.\n    var errorCodes = {\n        \"ijs\": \"invalid json string\",\n        \"mpc\": \"multiple pseudo classes (:xxx) not allowed\",\n        \"mepf\": \"malformed expression in pseudo-function\",\n        \"nmi\": \"multiple ids not allowed\",\n        \"se\": \"selector expected\",\n        \"sra\": \"string required after '.'\",\n        \"uc\": \"unrecognized char\",\n        \"ujs\": \"unclosed json string\",\n        \"upc\": \"unrecognized pseudo class\"\n    };\n\n    // throw an error message\n    function te(ec) {\n        throw new Error(errorCodes[ec]);\n    }\n\n    // THE LEXER\n    var toks = {\n        psc: 1, // pseudo class\n        psf: 2, // pseudo class function\n        typ: 3, // type\n        str: 4 // string\n    };\n\n    var pat = /^(?:([\\r\\n\\t\\ ]+)|([*.,>])|(string|boolean|null|array|object|number)|(:(?:root|first-child|last-child|only-child))|(:(?:nth-child|nth-last-child))|(:\\w+)|(\\\"(?:[^\\\\]|\\\\[^\\\"])*\\\")|(\\\")|((?:[_a-zA-Z]|[^\\0-\\0177]|\\\\[^\\r\\n\\f0-9a-fA-F])(?:[_a-zA-Z0-9\\-]|[^\\u0000-\\u0177]|(?:\\\\[^\\r\\n\\f0-9a-fA-F]))*))/;\n    var exprPat = /^\\s*\\(\\s*(?:([+\\-]?)([0-9]*)n\\s*(?:([+\\-])\\s*([0-9]))?|(odd|even)|([+\\-]?[0-9]+))\\s*\\)/;\n    var lex = function (str, off) {\n        if (!off) off = 0;\n        var m = pat.exec(str.substr(off));\n        if (!m) return undefined;\n        off+=m[0].length;\n        var a;\n        if (m[1]) a = [off, \" \"];\n        else if (m[2]) a = [off, m[0]];\n        else if (m[3]) a = [off, toks.typ, m[0]];\n        else if (m[4]) a = [off, toks.psc, m[0]];\n        else if (m[5]) a = [off, toks.psf, m[0]];\n        else if (m[6]) te(\"upc\");\n        else if (m[7]) a = [off, toks.str, jsonParse(m[0])];\n        else if (m[8]) te(\"ujs\");\n        else if (m[9]) a = [off, toks.str, m[0].replace(/\\\\([^\\r\\n\\f0-9a-fA-F])/g,\"$1\")];\n        return a;\n    };\n\n    // THE PARSER\n\n    var parse = function (str) {\n        var a = [], off = 0, am;\n\n        while (true) {\n            var s = parse_selector(str, off);\n            a.push(s[1]);\n            s = lex(str, off = s[0]);\n            if (s && s[1] === \" \") s = lex(str, off = s[0]);\n            if (!s) break;\n            // now we've parsed a selector, and have something else...\n            if (s[1] === \">\") {\n                a.push(\">\");\n                off = s[0];\n            } else if (s[1] === \",\") {\n                if (am === undefined) am = [ \",\", a ];\n                else am.push(a);\n                a = [];\n                off = s[0];\n            }\n        }\n        if (am) am.push(a);\n        return am ? am : a;\n    };\n\n    var parse_selector = function(str, off) {\n        var soff = off;\n        var s = { };\n        var l = lex(str, off);\n        // skip space\n        if (l && l[1] === \" \") { soff = off = l[0]; l = lex(str, off); }\n        if (l && l[1] === toks.typ) {\n            s.type = l[2];\n            l = lex(str, (off = l[0]));\n        } else if (l && l[1] === \"*\") {\n            // don't bother representing the universal sel, '*' in the\n            // parse tree, cause it's the default\n            l = lex(str, (off = l[0]));\n        }\n\n        // now support either an id or a pc\n        while (true) {\n            if (l === undefined) {\n                break;\n            } else if (l[1] === \".\") {\n                l = lex(str, (off = l[0]));\n                if (!l || l[1] !== toks.str) te(\"sra\");\n                if (s.id) te(\"nmi\");\n                s.id = l[2];\n            } else if (l[1] === toks.psc) {\n                if (s.pc || s.pf) te(\"mpc\");\n                // collapse first-child and last-child into nth-child expressions\n                if (l[2] === \":first-child\") {\n                    s.pf = \":nth-child\";\n                    s.a = 0;\n                    s.b = 1;\n                } else if (l[2] === \":last-child\") {\n                    s.pf = \":nth-last-child\";\n                    s.a = 0;\n                    s.b = 1;\n                } else {\n                    s.pc = l[2];\n                }\n            } else if (l[1] === toks.psf) {\n                if (s.pc || s.pf ) te(\"mpc\");\n                s.pf = l[2];\n                var m = exprPat.exec(str.substr(l[0]));\n                if (!m) te(\"mepf\");\n                if (m[5]) {\n                    s.a = 2;\n                    s.b = (m[5] === \"odd\") ? 1 : 0;\n                } else if (m[6]) {\n                    s.a = 0;\n                    s.b = parseInt(m[6], 10);\n                } else {\n                    s.a = parseInt((m[1] ? m[1] : \"+\") + (m[2] ? m[2] : \"1\"),10);\n                    s.b = m[3] ? parseInt(m[3] + m[4],10) : 0;\n                }\n                l[0] += m[0].length;\n            } else {\n                break;\n            }\n            l = lex(str, (off = l[0]));\n        }\n\n        // now if we didn't actually parse anything it's an error\n        if (soff === off) te(\"se\");\n\n        return [off, s];\n    };\n\n    // THE EVALUATOR\n\n    function isArray(o) {\n        return Array.isArray ? Array.isArray(o) : \n          toString.call(o) === \"[object Array]\";\n    }\n\n    function mytypeof(o) {\n        if (o === null) return \"null\";\n        var to = typeof o;\n        if (to === \"object\" && isArray(o)) to = \"array\";\n        return to;\n    }\n\n    function mn(node, sel, id, num, tot) {\n        var sels = [];\n        var cs = (sel[0] === \">\") ? sel[1] : sel[0];\n        var m = true, mod;\n        if (cs.type) m = m && (cs.type === mytypeof(node));\n        if (cs.id)   m = m && (cs.id === id);\n        if (m && cs.pf) {\n            if (cs.pf === \":nth-last-child\") num = tot - num;\n            else num++;\n            if (cs.a === 0) {\n                m = cs.b === num;\n            } else {\n                mod = ((num - cs.b) % cs.a);\n\n                m = (!mod && ((num*cs.a + cs.b) >= 0));\n            }\n        }\n\n        // should we repeat this selector for descendants?\n        if (sel[0] !== \">\" && sel[0].pc !== \":root\") sels.push(sel);\n\n        if (m) {\n            // is there a fragment that we should pass down?\n            if (sel[0] === \">\") { if (sel.length > 2) { m = false; sels.push(sel.slice(2)); } }\n            else if (sel.length > 1) { m = false; sels.push(sel.slice(1)); }\n        }\n\n        return [m, sels];\n    }\n\n    function forEach(sel, obj, fun, id, num, tot) {\n        var a = (sel[0] === \",\") ? sel.slice(1) : [sel],\n        a0 = [],\n        call = false,\n        i = 0, j = 0, l = 0, k, x;\n        for (i = 0; i < a.length; i++) {\n            x = mn(obj, a[i], id, num, tot);\n            if (x[0]) {\n                call = true;\n            }\n            for (j = 0; j < x[1].length; j++) {\n                a0.push(x[1][j]);\n            }\n        }\n        if (a0.length && typeof obj === \"object\") {\n            if (a0.length >= 1) {\n                a0.unshift(\",\");\n            }\n            if (isArray(obj)) {\n                for (i = 0; i < obj.length; i++) {\n                    forEach(a0, obj[i], fun, undefined, i, obj.length);\n                }\n            } else {\n                // it's a shame to do this for :last-child and other\n                // properties which count from the end when we don't\n                // even know if they're present.  Also, the stream\n                // parser is going to be pissed.\n                l = 0;\n                for (k in obj) {\n                    if (obj.hasOwnProperty(k)) {\n                        l++;\n                    }\n                }\n                i = 0;\n                for (k in obj) {\n                    if (obj.hasOwnProperty(k)) {\n                        forEach(a0, obj[k], fun, k, i++, l);\n                    }\n                }\n            }\n        }\n        if (call && fun) {\n            fun(obj);\n        }\n    }\n\n    function match(sel, obj) {\n        var a = [];\n        forEach(sel, obj, function(x) {\n            a.push(x);\n        });\n        return a;\n    }\n\n    function compile(sel) {\n        return {\n            sel: parse(sel),\n            match: function(obj){\n                return match(this.sel, obj);\n            },\n            forEach: function(obj, fun) {\n                return forEach(this.sel, obj, fun);\n            }\n        };\n    }\n\n    exports._lex = lex;\n    exports._parse = parse;\n    exports.match = function (sel, obj) {\n        return compile(sel).match(obj);\n    };\n    exports.forEach = function(sel, obj, fun) {\n        return compile(sel).forEach(obj, fun);\n    };\n    exports.compile = compile;\n})(typeof exports === \"undefined\" ? (window.JSONSelect = {}) : exports);\n\n"]},"hash":"75f1043dfe63124b36766647884e621e7f1ecaf3"}
