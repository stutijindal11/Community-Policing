{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/assert.js","filenameRelative":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/assert.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/assert.js.map","sourceFileName":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/assert.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"assert"},"ignored":false,"code":"function Assert(testContext) {\n\tthis.test = testContext;\n}\n\n// Assert helpers\nQUnit.assert = Assert.prototype = {\n\n\t// Specify the number of expected assertions to guarantee that failed test\n\t// (no assertions are run at all) don't slip through.\n\texpect: function expect(asserts) {\n\t\tif (arguments.length === 1) {\n\t\t\tthis.test.expected = asserts;\n\t\t} else {\n\t\t\treturn this.test.expected;\n\t\t}\n\t},\n\n\t// Increment this Test's semaphore counter, then return a function that\n\t// decrements that counter a maximum of once.\n\tasync: function async(count) {\n\t\tvar test = this.test,\n\t\t    popped = false,\n\t\t    acceptCallCount = count;\n\n\t\tif (typeof acceptCallCount === \"undefined\") {\n\t\t\tacceptCallCount = 1;\n\t\t}\n\n\t\ttest.semaphore += 1;\n\t\ttest.usedAsync = true;\n\t\tpauseProcessing();\n\n\t\treturn function done() {\n\n\t\t\tif (popped) {\n\t\t\t\ttest.pushFailure(\"Too many calls to the `assert.async` callback\", sourceFromStacktrace(2));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tacceptCallCount -= 1;\n\t\t\tif (acceptCallCount > 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttest.semaphore -= 1;\n\t\t\tpopped = true;\n\t\t\tresumeProcessing();\n\t\t};\n\t},\n\n\t// Exports test.push() to the user API\n\tpush: function push() /* result, actual, expected, message, negative */{\n\t\tvar assert = this,\n\t\t    currentTest = assert instanceof Assert && assert.test || QUnit.config.current;\n\n\t\t// Backwards compatibility fix.\n\t\t// Allows the direct use of global exported assertions and QUnit.assert.*\n\t\t// Although, it's use is not recommended as it can leak assertions\n\t\t// to other tests from async tests, because we only get a reference to the current test,\n\t\t// not exactly the test where assertion were intended to be called.\n\t\tif (!currentTest) {\n\t\t\tthrow new Error(\"assertion outside test context, in \" + sourceFromStacktrace(2));\n\t\t}\n\n\t\tif (currentTest.usedAsync === true && currentTest.semaphore === 0) {\n\t\t\tcurrentTest.pushFailure(\"Assertion after the final `assert.async` was resolved\", sourceFromStacktrace(2));\n\n\t\t\t// Allow this assertion to continue running anyway...\n\t\t}\n\n\t\tif (!(assert instanceof Assert)) {\n\t\t\tassert = currentTest.assert;\n\t\t}\n\t\treturn assert.test.push.apply(assert.test, arguments);\n\t},\n\n\tok: function ok(result, message) {\n\t\tmessage = message || (result ? \"okay\" : \"failed, expected argument to be truthy, was: \" + QUnit.dump.parse(result));\n\t\tthis.push(!!result, result, true, message);\n\t},\n\n\tnotOk: function notOk(result, message) {\n\t\tmessage = message || (!result ? \"okay\" : \"failed, expected argument to be falsy, was: \" + QUnit.dump.parse(result));\n\t\tthis.push(!result, result, false, message, true);\n\t},\n\n\tequal: function equal(actual, expected, message) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.push(expected == actual, actual, expected, message);\n\t},\n\n\tnotEqual: function notEqual(actual, expected, message) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.push(expected != actual, actual, expected, message, true);\n\t},\n\n\tpropEqual: function propEqual(actual, expected, message) {\n\t\tactual = objectValues(actual);\n\t\texpected = objectValues(expected);\n\t\tthis.push(QUnit.equiv(actual, expected), actual, expected, message);\n\t},\n\n\tnotPropEqual: function notPropEqual(actual, expected, message) {\n\t\tactual = objectValues(actual);\n\t\texpected = objectValues(expected);\n\t\tthis.push(!QUnit.equiv(actual, expected), actual, expected, message, true);\n\t},\n\n\tdeepEqual: function deepEqual(actual, expected, message) {\n\t\tthis.push(QUnit.equiv(actual, expected), actual, expected, message);\n\t},\n\n\tnotDeepEqual: function notDeepEqual(actual, expected, message) {\n\t\tthis.push(!QUnit.equiv(actual, expected), actual, expected, message, true);\n\t},\n\n\tstrictEqual: function strictEqual(actual, expected, message) {\n\t\tthis.push(expected === actual, actual, expected, message);\n\t},\n\n\tnotStrictEqual: function notStrictEqual(actual, expected, message) {\n\t\tthis.push(expected !== actual, actual, expected, message, true);\n\t},\n\n\t\"throws\": function throws(block, expected, message) {\n\t\tvar actual,\n\t\t    expectedType,\n\t\t    expectedOutput = expected,\n\t\t    ok = false,\n\t\t    currentTest = this instanceof Assert && this.test || QUnit.config.current;\n\n\t\t// 'expected' is optional unless doing string comparison\n\t\tif (message == null && typeof expected === \"string\") {\n\t\t\tmessage = expected;\n\t\t\texpected = null;\n\t\t}\n\n\t\tcurrentTest.ignoreGlobalErrors = true;\n\t\ttry {\n\t\t\tblock.call(currentTest.testEnvironment);\n\t\t} catch (e) {\n\t\t\tactual = e;\n\t\t}\n\t\tcurrentTest.ignoreGlobalErrors = false;\n\n\t\tif (actual) {\n\t\t\texpectedType = QUnit.objectType(expected);\n\n\t\t\t// we don't want to validate thrown error\n\t\t\tif (!expected) {\n\t\t\t\tok = true;\n\t\t\t\texpectedOutput = null;\n\n\t\t\t\t// expected is a regexp\n\t\t\t} else if (expectedType === \"regexp\") {\n\t\t\t\t\tok = expected.test(errorString(actual));\n\n\t\t\t\t\t// expected is a string\n\t\t\t\t} else if (expectedType === \"string\") {\n\t\t\t\t\t\tok = expected === errorString(actual);\n\n\t\t\t\t\t\t// expected is a constructor, maybe an Error constructor\n\t\t\t\t\t} else if (expectedType === \"function\" && actual instanceof expected) {\n\t\t\t\t\t\t\tok = true;\n\n\t\t\t\t\t\t\t// expected is an Error object\n\t\t\t\t\t\t} else if (expectedType === \"object\") {\n\t\t\t\t\t\t\t\tok = actual instanceof expected.constructor && actual.name === expected.name && actual.message === expected.message;\n\n\t\t\t\t\t\t\t\t// expected is a validation function which returns true if validation passed\n\t\t\t\t\t\t\t} else if (expectedType === \"function\" && expected.call({}, actual) === true) {\n\t\t\t\t\t\t\t\t\texpectedOutput = null;\n\t\t\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t\t\t}\n\t\t}\n\n\t\tcurrentTest.assert.push(ok, actual, expectedOutput, message);\n\t}\n};\n\n// Provide an alternative to assert.throws(), for environments that consider throws a reserved word\n// Known to us are: Closure Compiler, Narwhal\n(function () {\n\t/*jshint sub:true */\n\tAssert.prototype.raises = Assert.prototype[\"throws\"];\n})();\n\nfunction errorString(error) {\n\tvar name,\n\t    message,\n\t    resultErrorString = error.toString();\n\tif (resultErrorString.substring(0, 7) === \"[object\") {\n\t\tname = error.name ? error.name.toString() : \"Error\";\n\t\tmessage = error.message ? error.message.toString() : \"\";\n\t\tif (name && message) {\n\t\t\treturn name + \": \" + message;\n\t\t} else if (name) {\n\t\t\treturn name;\n\t\t} else if (message) {\n\t\t\treturn message;\n\t\t} else {\n\t\t\treturn \"Error\";\n\t\t}\n\t} else {\n\t\treturn resultErrorString;\n\t}\n}","ast":null,"map":{"version":3,"sources":["/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/assert.js"],"names":[],"mappings":"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","file":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/qunit/src/assert.js.map","sourcesContent":["function Assert( testContext ) {\n\tthis.test = testContext;\n}\n\n// Assert helpers\nQUnit.assert = Assert.prototype = {\n\n\t// Specify the number of expected assertions to guarantee that failed test\n\t// (no assertions are run at all) don't slip through.\n\texpect: function( asserts ) {\n\t\tif ( arguments.length === 1 ) {\n\t\t\tthis.test.expected = asserts;\n\t\t} else {\n\t\t\treturn this.test.expected;\n\t\t}\n\t},\n\n\t// Increment this Test's semaphore counter, then return a function that\n\t// decrements that counter a maximum of once.\n\tasync: function( count ) {\n\t\tvar test = this.test,\n\t\t\tpopped = false,\n\t\t\tacceptCallCount = count;\n\n\t\tif ( typeof acceptCallCount === \"undefined\" ) {\n\t\t\tacceptCallCount = 1;\n\t\t}\n\n\t\ttest.semaphore += 1;\n\t\ttest.usedAsync = true;\n\t\tpauseProcessing();\n\n\t\treturn function done() {\n\n\t\t\tif ( popped ) {\n\t\t\t\ttest.pushFailure( \"Too many calls to the `assert.async` callback\",\n\t\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tacceptCallCount -= 1;\n\t\t\tif ( acceptCallCount > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttest.semaphore -= 1;\n\t\t\tpopped = true;\n\t\t\tresumeProcessing();\n\t\t};\n\t},\n\n\t// Exports test.push() to the user API\n\tpush: function( /* result, actual, expected, message, negative */ ) {\n\t\tvar assert = this,\n\t\t\tcurrentTest = ( assert instanceof Assert && assert.test ) || QUnit.config.current;\n\n\t\t// Backwards compatibility fix.\n\t\t// Allows the direct use of global exported assertions and QUnit.assert.*\n\t\t// Although, it's use is not recommended as it can leak assertions\n\t\t// to other tests from async tests, because we only get a reference to the current test,\n\t\t// not exactly the test where assertion were intended to be called.\n\t\tif ( !currentTest ) {\n\t\t\tthrow new Error( \"assertion outside test context, in \" + sourceFromStacktrace( 2 ) );\n\t\t}\n\n\t\tif ( currentTest.usedAsync === true && currentTest.semaphore === 0 ) {\n\t\t\tcurrentTest.pushFailure( \"Assertion after the final `assert.async` was resolved\",\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\n\t\t\t// Allow this assertion to continue running anyway...\n\t\t}\n\n\t\tif ( !( assert instanceof Assert ) ) {\n\t\t\tassert = currentTest.assert;\n\t\t}\n\t\treturn assert.test.push.apply( assert.test, arguments );\n\t},\n\n\tok: function( result, message ) {\n\t\tmessage = message || ( result ? \"okay\" : \"failed, expected argument to be truthy, was: \" +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tthis.push( !!result, result, true, message );\n\t},\n\n\tnotOk: function( result, message ) {\n\t\tmessage = message || ( !result ? \"okay\" : \"failed, expected argument to be falsy, was: \" +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tthis.push( !result, result, false, message, true );\n\t},\n\n\tequal: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.push( expected == actual, actual, expected, message );\n\t},\n\n\tnotEqual: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.push( expected != actual, actual, expected, message, true );\n\t},\n\n\tpropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.push( QUnit.equiv( actual, expected ), actual, expected, message );\n\t},\n\n\tnotPropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.push( !QUnit.equiv( actual, expected ), actual, expected, message, true );\n\t},\n\n\tdeepEqual: function( actual, expected, message ) {\n\t\tthis.push( QUnit.equiv( actual, expected ), actual, expected, message );\n\t},\n\n\tnotDeepEqual: function( actual, expected, message ) {\n\t\tthis.push( !QUnit.equiv( actual, expected ), actual, expected, message, true );\n\t},\n\n\tstrictEqual: function( actual, expected, message ) {\n\t\tthis.push( expected === actual, actual, expected, message );\n\t},\n\n\tnotStrictEqual: function( actual, expected, message ) {\n\t\tthis.push( expected !== actual, actual, expected, message, true );\n\t},\n\n\t\"throws\": function( block, expected, message ) {\n\t\tvar actual, expectedType,\n\t\t\texpectedOutput = expected,\n\t\t\tok = false,\n\t\t\tcurrentTest = ( this instanceof Assert && this.test ) || QUnit.config.current;\n\n\t\t// 'expected' is optional unless doing string comparison\n\t\tif ( message == null && typeof expected === \"string\" ) {\n\t\t\tmessage = expected;\n\t\t\texpected = null;\n\t\t}\n\n\t\tcurrentTest.ignoreGlobalErrors = true;\n\t\ttry {\n\t\t\tblock.call( currentTest.testEnvironment );\n\t\t} catch (e) {\n\t\t\tactual = e;\n\t\t}\n\t\tcurrentTest.ignoreGlobalErrors = false;\n\n\t\tif ( actual ) {\n\t\t\texpectedType = QUnit.objectType( expected );\n\n\t\t\t// we don't want to validate thrown error\n\t\t\tif ( !expected ) {\n\t\t\t\tok = true;\n\t\t\t\texpectedOutput = null;\n\n\t\t\t// expected is a regexp\n\t\t\t} else if ( expectedType === \"regexp\" ) {\n\t\t\t\tok = expected.test( errorString( actual ) );\n\n\t\t\t// expected is a string\n\t\t\t} else if ( expectedType === \"string\" ) {\n\t\t\t\tok = expected === errorString( actual );\n\n\t\t\t// expected is a constructor, maybe an Error constructor\n\t\t\t} else if ( expectedType === \"function\" && actual instanceof expected ) {\n\t\t\t\tok = true;\n\n\t\t\t// expected is an Error object\n\t\t\t} else if ( expectedType === \"object\" ) {\n\t\t\t\tok = actual instanceof expected.constructor &&\n\t\t\t\t\tactual.name === expected.name &&\n\t\t\t\t\tactual.message === expected.message;\n\n\t\t\t// expected is a validation function which returns true if validation passed\n\t\t\t} else if ( expectedType === \"function\" && expected.call( {}, actual ) === true ) {\n\t\t\t\texpectedOutput = null;\n\t\t\t\tok = true;\n\t\t\t}\n\t\t}\n\n\t\tcurrentTest.assert.push( ok, actual, expectedOutput, message );\n\t}\n};\n\n// Provide an alternative to assert.throws(), for environments that consider throws a reserved word\n// Known to us are: Closure Compiler, Narwhal\n(function() {\n\t/*jshint sub:true */\n\tAssert.prototype.raises = Assert.prototype[ \"throws\" ];\n}());\n\nfunction errorString( error ) {\n\tvar name, message,\n\t\tresultErrorString = error.toString();\n\tif ( resultErrorString.substring( 0, 7 ) === \"[object\" ) {\n\t\tname = error.name ? error.name.toString() : \"Error\";\n\t\tmessage = error.message ? error.message.toString() : \"\";\n\t\tif ( name && message ) {\n\t\t\treturn name + \": \" + message;\n\t\t} else if ( name ) {\n\t\t\treturn name;\n\t\t} else if ( message ) {\n\t\t\treturn message;\n\t\t} else {\n\t\t\treturn \"Error\";\n\t\t}\n\t} else {\n\t\treturn resultErrorString;\n\t}\n}\n"]},"hash":"4fa74a8cadd265f16bc2baa9dc5a5a9a81912a79"}
