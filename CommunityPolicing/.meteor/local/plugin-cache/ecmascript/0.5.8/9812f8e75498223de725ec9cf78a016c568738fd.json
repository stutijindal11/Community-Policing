{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/prism/components/prism-elixir.js","filenameRelative":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/prism/components/prism-elixir.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/prism/components/prism-elixir.js.map","sourceFileName":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/prism/components/prism-elixir.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"prism-elixir"},"ignored":false,"code":"Prism.languages.elixir = {\n\t// Negative look-ahead is needed for string interpolation\n\t// Negative look-behind is needed to avoid highlighting markdown headers in\n\t// multi-line doc strings\n\t'comment': {\n\t\tpattern: /(^|[^#])#(?![{#]).*/m,\n\t\tlookbehind: true\n\t},\n\t// ~r\"\"\"foo\"\"\", ~r'''foo''', ~r/foo/, ~r|foo|, ~r\"foo\", ~r'foo', ~r(foo), ~r[foo], ~r{foo}, ~r<foo>\n\t'regex': /~[rR](?:(\"\"\"|'''|[\\/|\"'])(?:\\\\.|(?!\\1)[^\\\\])+\\1|\\((?:\\\\\\)|[^)])+\\)|\\[(?:\\\\\\]|[^\\]])+\\]|\\{(?:\\\\\\}|[^}])+\\}|<(?:\\\\>|[^>])+>)[uismxfr]*/,\n\t'string': [{\n\t\t// ~s\"\"\"foo\"\"\", ~s'''foo''', ~s/foo/, ~s|foo|, ~s\"foo\", ~s'foo', ~s(foo), ~s[foo], ~s{foo}, ~s<foo>\n\t\tpattern: /~[cCsSwW](?:(\"\"\"|'''|[\\/|\"'])(?:\\\\.|(?!\\1)[^\\\\])+\\1|\\((?:\\\\\\)|[^)])+\\)|\\[(?:\\\\\\]|[^\\]])+\\]|\\{(?:\\\\\\}|#\\{[^}]+\\}|[^}])+\\}|<(?:\\\\>|[^>])+>)[csa]?/,\n\t\tinside: {\n\t\t\t// See interpolation below\n\t\t}\n\t}, {\n\t\tpattern: /(\"\"\"|''')[\\s\\S]*?\\1/,\n\t\tinside: {\n\t\t\t// See interpolation below\n\t\t}\n\t}, {\n\t\t// Multi-line strings are allowed\n\t\tpattern: /(\"|')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1/,\n\t\tinside: {\n\t\t\t// See interpolation below\n\t\t}\n\t}],\n\t'atom': {\n\t\t// Look-behind prevents bad highlighting of the :: operator\n\t\tpattern: /(^|[^:]):\\w+/,\n\t\tlookbehind: true,\n\t\talias: 'symbol'\n\t},\n\t// Look-ahead prevents bad highlighting of the :: operator\n\t'attr-name': /\\w+:(?!:)/,\n\t'capture': {\n\t\t// Look-behind prevents bad highlighting of the && operator\n\t\tpattern: /(^|[^&])&(?:[^&\\s\\d()][^\\s()]*|(?=\\())/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'argument': {\n\t\t// Look-behind prevents bad highlighting of the && operator\n\t\tpattern: /(^|[^&])&\\d+/,\n\t\tlookbehind: true,\n\t\talias: 'variable'\n\t},\n\t'attribute': {\n\t\tpattern: /@[\\S]+/,\n\t\talias: 'variable'\n\t},\n\t'number': /\\b(?:0[box][a-f\\d_]+|\\d[\\d_]*)(?:\\.[\\d_]+)?(?:e[+-]?[\\d_]+)?\\b/i,\n\t'keyword': /\\b(?:after|alias|and|case|catch|cond|def(?:callback|exception|impl|module|p|protocol|struct)?|do|else|end|fn|for|if|import|not|or|require|rescue|try|unless|use|when)\\b/,\n\t'boolean': /\\b(?:true|false|nil)\\b/,\n\t'operator': [/\\bin\\b|&&?|\\|[|>]?|\\\\\\\\|::|\\.\\.\\.?|\\+\\+?|-[->]?|<[-=>]|>=|!==?|\\B!|=(?:==?|[>~])?|[*\\/^]/, {\n\t\t// We don't want to match <<\n\t\tpattern: /([^<])<(?!<)/,\n\t\tlookbehind: true\n\t}, {\n\t\t// We don't want to match >>\n\t\tpattern: /([^>])>(?!>)/,\n\t\tlookbehind: true\n\t}],\n\t'punctuation': /<<|>>|[.,%\\[\\]{}()]/\n};\n\nPrism.languages.elixir.string.forEach(function (o) {\n\to.inside = {\n\t\t'interpolation': {\n\t\t\tpattern: /#\\{[^}]+\\}/,\n\t\t\tinside: {\n\t\t\t\t'delimiter': {\n\t\t\t\t\tpattern: /^#\\{|\\}$/,\n\t\t\t\t\talias: 'punctuation'\n\t\t\t\t},\n\t\t\t\trest: Prism.util.clone(Prism.languages.elixir)\n\t\t\t}\n\t\t}\n\t};\n});","ast":null,"map":{"version":3,"sources":["/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/prism/components/prism-elixir.js"],"names":[],"mappings":"AAAA,MAAM,SAAN,CAAgB,MAAhB,GAAyB;;;;AAIxB,YAAW;AACV,WAAS,sBADC;AAEV,cAAY;AAFF,EAJa;;AASxB,UAAS,sIATe;AAUxB,WAAU,CACT;;AAEC,WAAS,iJAFV;AAGC,UAAQ;;AAAA;AAHT,EADS,EAQT;AACC,WAAS,qBADV;AAEC,UAAQ;;AAAA;AAFT,EARS,EAcT;;AAEC,WAAS,kCAFV;AAGC,UAAQ;;AAAA;AAHT,EAdS,CAVc;AAgCxB,SAAQ;;AAEP,WAAS,cAFF;AAGP,cAAY,IAHL;AAIP,SAAO;AAJA,EAhCgB;;AAuCxB,cAAa,WAvCW;AAwCxB,YAAW;;AAEV,WAAS,wCAFC;AAGV,cAAY,IAHF;AAIV,SAAO;AAJG,EAxCa;AA8CxB,aAAY;;AAEX,WAAS,cAFE;AAGX,cAAY,IAHD;AAIX,SAAO;AAJI,EA9CY;AAoDxB,cAAa;AACZ,WAAS,QADG;AAEZ,SAAO;AAFK,EApDW;AAwDxB,WAAU,iEAxDc;AAyDxB,YAAW,yKAzDa;AA0DxB,YAAW,wBA1Da;AA2DxB,aAAY,CACX,0FADW,EAEX;;AAEC,WAAS,cAFV;AAGC,cAAY;AAHb,EAFW,EAOX;;AAEC,WAAS,cAFV;AAGC,cAAY;AAHb,EAPW,CA3DY;AAwExB,gBAAe;AAxES,CAAzB;;AA2EA,MAAM,SAAN,CAAgB,MAAhB,CAAuB,MAAvB,CAA8B,OAA9B,CAAsC,UAAS,CAAT,EAAY;AACjD,GAAE,MAAF,GAAW;AACV,mBAAiB;AAChB,YAAS,YADO;AAEhB,WAAQ;AACP,iBAAa;AACZ,cAAS,UADG;AAEZ,YAAO;AAFK,KADN;AAKP,UAAM,MAAM,IAAN,CAAW,KAAX,CAAiB,MAAM,SAAN,CAAgB,MAAjC;AALC;AAFQ;AADP,EAAX;AAYA,CAbD","file":"/packages/anbuselvan:meteor-toggle-switch/vendor/css-toggle-switch/bower_components/prism/components/prism-elixir.js.map","sourcesContent":["Prism.languages.elixir = {\n\t// Negative look-ahead is needed for string interpolation\n\t// Negative look-behind is needed to avoid highlighting markdown headers in\n\t// multi-line doc strings\n\t'comment': {\n\t\tpattern: /(^|[^#])#(?![{#]).*/m,\n\t\tlookbehind: true\n\t},\n\t// ~r\"\"\"foo\"\"\", ~r'''foo''', ~r/foo/, ~r|foo|, ~r\"foo\", ~r'foo', ~r(foo), ~r[foo], ~r{foo}, ~r<foo>\n\t'regex': /~[rR](?:(\"\"\"|'''|[\\/|\"'])(?:\\\\.|(?!\\1)[^\\\\])+\\1|\\((?:\\\\\\)|[^)])+\\)|\\[(?:\\\\\\]|[^\\]])+\\]|\\{(?:\\\\\\}|[^}])+\\}|<(?:\\\\>|[^>])+>)[uismxfr]*/,\n\t'string': [\n\t\t{\n\t\t\t// ~s\"\"\"foo\"\"\", ~s'''foo''', ~s/foo/, ~s|foo|, ~s\"foo\", ~s'foo', ~s(foo), ~s[foo], ~s{foo}, ~s<foo>\n\t\t\tpattern: /~[cCsSwW](?:(\"\"\"|'''|[\\/|\"'])(?:\\\\.|(?!\\1)[^\\\\])+\\1|\\((?:\\\\\\)|[^)])+\\)|\\[(?:\\\\\\]|[^\\]])+\\]|\\{(?:\\\\\\}|#\\{[^}]+\\}|[^}])+\\}|<(?:\\\\>|[^>])+>)[csa]?/,\n\t\t\tinside: {\n\t\t\t\t// See interpolation below\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tpattern: /(\"\"\"|''')[\\s\\S]*?\\1/,\n\t\t\tinside: {\n\t\t\t\t// See interpolation below\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t// Multi-line strings are allowed\n\t\t\tpattern: /(\"|')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1/,\n\t\t\tinside: {\n\t\t\t\t// See interpolation below\n\t\t\t}\n\t\t}\n\t],\n\t'atom': {\n\t\t// Look-behind prevents bad highlighting of the :: operator\n\t\tpattern: /(^|[^:]):\\w+/,\n\t\tlookbehind: true,\n\t\talias: 'symbol'\n\t},\n\t// Look-ahead prevents bad highlighting of the :: operator\n\t'attr-name': /\\w+:(?!:)/,\n\t'capture': {\n\t\t// Look-behind prevents bad highlighting of the && operator\n\t\tpattern: /(^|[^&])&(?:[^&\\s\\d()][^\\s()]*|(?=\\())/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'argument': {\n\t\t// Look-behind prevents bad highlighting of the && operator\n\t\tpattern: /(^|[^&])&\\d+/,\n\t\tlookbehind: true,\n\t\talias: 'variable'\n\t},\n\t'attribute': {\n\t\tpattern: /@[\\S]+/,\n\t\talias: 'variable'\n\t},\n\t'number': /\\b(?:0[box][a-f\\d_]+|\\d[\\d_]*)(?:\\.[\\d_]+)?(?:e[+-]?[\\d_]+)?\\b/i,\n\t'keyword': /\\b(?:after|alias|and|case|catch|cond|def(?:callback|exception|impl|module|p|protocol|struct)?|do|else|end|fn|for|if|import|not|or|require|rescue|try|unless|use|when)\\b/,\n\t'boolean': /\\b(?:true|false|nil)\\b/,\n\t'operator': [\n\t\t/\\bin\\b|&&?|\\|[|>]?|\\\\\\\\|::|\\.\\.\\.?|\\+\\+?|-[->]?|<[-=>]|>=|!==?|\\B!|=(?:==?|[>~])?|[*\\/^]/,\n\t\t{\n\t\t\t// We don't want to match <<\n\t\t\tpattern: /([^<])<(?!<)/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t{\n\t\t\t// We don't want to match >>\n\t\t\tpattern: /([^>])>(?!>)/,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t'punctuation': /<<|>>|[.,%\\[\\]{}()]/\n};\n\nPrism.languages.elixir.string.forEach(function(o) {\n\to.inside = {\n\t\t'interpolation': {\n\t\t\tpattern: /#\\{[^}]+\\}/,\n\t\t\tinside: {\n\t\t\t\t'delimiter': {\n\t\t\t\t\tpattern: /^#\\{|\\}$/,\n\t\t\t\t\talias: 'punctuation'\n\t\t\t\t},\n\t\t\t\trest: Prism.util.clone(Prism.languages.elixir)\n\t\t\t}\n\t\t}\n\t};\n});\n\n"]},"hash":"9812f8e75498223de725ec9cf78a016c568738fd"}
